{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"b3684ec6fd1e32c11f1c97a6ef96efde082f6c17","modified":1513325578870},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1513325578914},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1513325578915},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1513325578914},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1513325578916},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1513325578917},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1513325578916},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1513325578916},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1513325578917},{"_id":"themes/next/README.cn.md","hash":"6d9177e7dad87e6129760e4b559bd3f7a15429d7","modified":1513325578918},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1513325578917},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1513325578917},{"_id":"themes/next/README.md","hash":"aba736f1b934f2b169035ccf94d2771a270ec21d","modified":1513325578918},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1513325578919},{"_id":"themes/next/_config.yml","hash":"5b20d45c60800757d219c39d2b54b7bc53aecdd2","modified":1513325578918},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1513325578919},{"_id":"themes/next/package.json","hash":"2174d61cbc9fa276a82b02649426842f088825ab","modified":1513325578944},{"_id":"source/about/index.md","hash":"23b104700c489d9323ea4b8c8ea2e368edce23b0","modified":1513325578876},{"_id":"source/categories/index.md","hash":"6bf992f3b1d23a756a52aa4ee882552bba0dee24","modified":1513325578877},{"_id":"source/tags/index.md","hash":"e9da18cb94d457043fde79d4a4ab01606671392a","modified":1513325578877},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1513325578915},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1513325578915},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1513325578916},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1513325578916},{"_id":"themes/next/languages/en.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1513325578920},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1513325578920},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1513325578919},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1513325578920},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1513325578921},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1513325578921},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1513325578922},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1513325578921},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1513325578921},{"_id":"themes/next/languages/zh-hk.yml","hash":"2ef272bcb1f325480f59f1e2ab95584de3c6b8da","modified":1513325578923},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3f800f69b02af67956cedd9a3db8152417f62f46","modified":1513325578922},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1513325578922},{"_id":"themes/next/languages/zh-tw.yml","hash":"c53941a2eaac8e3a2f8dacc73ed555d3c6c5bd59","modified":1513325578923},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1513325578920},{"_id":"themes/next/layout/_layout.swig","hash":"72a1a2612f7c14cc9af51c55c8dfac39d6c0a2bf","modified":1513325578924},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1513325578943},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1513325578943},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1513325578943},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1513325578943},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1513325578944},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1513325578944},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1513325578944},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1513325578945},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1513325578945},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1513325579052},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1513325579052},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1513325579052},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578987},{"_id":"source/_posts/angular/windows-npm-error.md","hash":"fa9cfb5398a155a48f4096918637e46586d070a6","modified":1516360051017},{"_id":"source/_posts/angular/nvm-install.md","hash":"663bbcc4ae77eb94cc37eb120ac84cf03a5d9d37","modified":1513867577293},{"_id":"source/_posts/db/Navicat-Premium-For-Mac-Activate.md","hash":"8b901d568276e479e6f2a235547b96b8f51040ec","modified":1515260283000},{"_id":"source/_posts/daily/2017-summary.md","hash":"72f32f0f9af093348a3e393c3cd19b56d45aa0d5","modified":1515028509969},{"_id":"source/_posts/design/Hospital.md","hash":"3992dc234c66cbac876ae085c9aab0612fad445f","modified":1515126939901},{"_id":"source/_posts/linux/常用命令.md","hash":"3a952557a9fb7b96fec2d3cfd3877c0a41ba23ec","modified":1514981451971},{"_id":"source/_posts/design/Technical-introduction.md","hash":"8c77542ddff95222abf7581362e55d26e5ed3c0a","modified":1516177724204},{"_id":"source/_posts/design/开题报告","hash":"54d8ac9b2e9f7ceeae9f2566eb682cd3cf484636","modified":1516344926000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1513325578923},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1513325578923},{"_id":"themes/next/layout/_macro/post.swig","hash":"767e1d5503ecce85f577c8fb673a3503b65484ce","modified":1513325578925},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1513325578925},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1513325578925},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1513325578924},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1513325578926},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1513325578926},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1513325578927},{"_id":"themes/next/layout/_partials/comments.swig","hash":"0fbeb56e9c4d5193c6a181d45c4b1b7a44a0e027","modified":1513325578927},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1513325578928},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1513325578929},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1513325578929},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1513325578929},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1513325578929},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1513325578931},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1513325578932},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a745f29e9f60c9c6d1104d6e88199f34c116067f","modified":1513325578933},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1513325578939},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1513325578939},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1513325578940},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1513325578940},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1513325578939},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1513325578940},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1513325578987},{"_id":"themes/next/source/images/apple-touch-icon.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1513325578988},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1513325578987},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1513325578988},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1513325578988},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1513325578989},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1513325578989},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1513325578989},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1513325578990},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1513325578991},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1513325578991},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1513325578990},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1513325578991},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513325578991},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1513325578992},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1513325578992},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1513325578992},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1513325578993},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1513325578993},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1513325578946},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1513325578946},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1513325578946},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1513325578946},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1513325578947},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1513325578947},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1513325578947},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1513325578947},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1513325578947},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578933},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578933},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578974},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578974},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578975},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578986},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1513325578987},{"_id":"source/_posts/Java/basic/Java-equals-Research.md","hash":"0e22928be21f41597fa4b5497628f1f9dac99914","modified":1513325578871},{"_id":"source/_posts/Java/basic/HashMap-intro.md","hash":"355929621e27c351f44861e4ff0cea84efb0baac","modified":1513325578870},{"_id":"source/_posts/Java/basic/Java-String-Research.md","hash":"806dfca370f774ff7ce3aa8b468b464a12361563","modified":1513325578871},{"_id":"source/_posts/Java/taskScheduler/Timer.md","hash":"e897f0a9e65156d276f75cd3a075db9fe1ddc303","modified":1513325578873},{"_id":"source/_posts/Java/taskScheduler/Quartz.md","hash":"fd5cf56f3243d0622569cef93fcbaa6c5cc0a13b","modified":1513325578873},{"_id":"source/_posts/Java/basic/Java-Stream-API-Research.md","hash":"4ad0901744ae6822a5414067306d03bff4d77d4a","modified":1513325578871},{"_id":"source/_posts/Java/taskScheduler/Scheduler.md","hash":"97a3b9723559c758a3e0ede28e2000f96f1cf41c","modified":1513325578873},{"_id":"source/_posts/OS/Mac/Mac-NTFS.md","hash":"a4486e696f347b0898333461da2d741ba4d7624d","modified":1515028559221},{"_id":"source/_posts/Python/basic/pyenv.md","hash":"d1d1ce9eaa5b51191ae95bfac79e195cc5ffbc43","modified":1513868605341},{"_id":"source/_posts/Python/scrapy/scrapy-error.md","hash":"0ec4b8e35bbf3513f70d82d0ccc291d08782f9f5","modified":1514436265710},{"_id":"source/_posts/service/docker/Docker-intro.md","hash":"8da52aeaaaeab62fe515b2d9359af73ec14f384e","modified":1513325578873},{"_id":"source/_posts/service/git/hexo+gitPage+travis-ci.md","hash":"69ad43b7d97e9ff787edb19e1722ff997d552a47","modified":1513325578874},{"_id":"source/_posts/service/elasticsearch/elasticsearch.md","hash":"5935661a71876fce3dd1ec15de20d529a17d424f","modified":1513325578874},{"_id":"source/_posts/service/git/git.md","hash":"7717970b375814698f247dcc987de77098fa0508","modified":1513325578874},{"_id":"source/_posts/service/linux/linux-note.md","hash":"76dac91599838e9b4c0046e330f0d4b2d8bec91e","modified":1513325578875},{"_id":"source/_posts/service/other/leanote-install.md","hash":"83b25cd16e378222232cc311b9d629f2611262e9","modified":1513325578875},{"_id":"source/_posts/service/mongo/mongo_backup.md","hash":"98a5d8fb29e02f34896650fdb7172beb83d6bb7c","modified":1513325578875},{"_id":"source/_posts/service/pc/soft.md","hash":"15b2582a532d96d7773f7a73fe2b6def920f51e9","modified":1513325578876},{"_id":"source/_posts/OS/Mac/Mac-handle.md","hash":"e1e0df008c5629e8e5cc1b108624be0f2e051b4f","modified":1514185895907},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1513325578928},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1513325578928},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1513325578930},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1513325578930},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1513325578930},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1513325578930},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1513325578931},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1513325578931},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1513325578932},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1513325578931},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1513325578933},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1513325578937},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1513325578932},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"576e716893153a855eaf6d136fad7cb6d4065e09","modified":1513325578938},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1513325578938},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1513325578937},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1513325578937},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1513325578934},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1513325578938},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1513325578939},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1513325578934},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1513325578934},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"9f4ed36c73e890909b8ebbe601fb60e13d048288","modified":1513325578938},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1513325578934},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1513325578935},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1513325578935},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1513325578935},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1513325578935},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1513325578936},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1513325578936},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1513325578936},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1513325578936},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1513325578941},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1513325578942},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1513325578942},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1513325578942},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1513325578975},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1513325578974},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1513325578974},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1513325578975},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1513325578985},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"ec79c23f1956bade7bcaa7189d97b7463b8f9f75","modified":1513325578986},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1513325578986},{"_id":"themes/next/source/css/_variables/base.styl","hash":"4df88b33f4bd31b872b5c842405267256024f75a","modified":1513325578986},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1513325578994},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1513325578994},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1513325578993},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1513325578994},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1513325578995},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1513325578997},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1513325578996},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1513325578996},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1513325578995},{"_id":"themes/next/source/js/src/utils.js","hash":"6b0eeeb9dda4a7c94c1c4f6fafd2c801da6e8f96","modified":1513325578997},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1513325578997},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1513325579004},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1513325579007},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1513325579008},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1513325579013},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1513325579014},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1513325579015},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1513325579014},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1513325579016},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1513325579017},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1513325579017},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1513325579017},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1513325579017},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1513325579025},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1513325579027},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1513325579027},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1513325579027},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1513325579027},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1513325579028},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1513325579028},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1513325579028},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1513325579029},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1513325579029},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1513325579029},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1513325579029},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1513325579029},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1513325579030},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1513325579030},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1513325579030},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1513325579031},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1513325579031},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1513325579031},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1513325579031},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1513325579032},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1513325579032},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1513325579032},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1513325579047},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1513325579033},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1513325579048},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1513325579050},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1513325579051},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1513325579051},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1513325579026},{"_id":"source/_posts/Java/frame/spring/spring-scope-intro.md","hash":"f14ed3fcb3a5c85187efca3cfb8b75861a3fad9a","modified":1513325578872},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1513325578941},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1513325578941},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1513325578948},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1513325578948},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1513325578949},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1513325578948},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1513325578949},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1513325578958},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1513325578967},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1513325578972},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1513325578973},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1513325578972},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1513325578972},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1513325578973},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1513325578976},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1513325578973},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1513325578973},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1513325578976},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1513325578977},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1513325578977},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"5e6c9f8a730b78c7ce5572d327c2a7311c3609b9","modified":1513325578977},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1513325578978},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1513325578978},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1513325578976},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1513325578979},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1513325578980},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1513325578980},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1513325578980},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1513325578981},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1513325578982},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1513325578983},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1513325578983},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1513325578984},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"f3991aeca25d0814f5cea800b58f25d0222cd246","modified":1513325578984},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1513325578985},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1513325578996},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1513325579000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1513325579003},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1513325579002},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513325579009},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513325579008},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513325579009},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513325579009},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513325579009},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513325579010},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1513325579012},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1513325579013},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1513325579016},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1513325579013},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1513325579015},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1513325579018},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1513325579018},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1513325579018},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1513325579038},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1513325579038},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1513325579001},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1513325579024},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1513325579025},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1513325579050},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1513325578949},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1513325578950},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1513325578950},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1513325578949},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1513325578950},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1513325578951},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1513325578950},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1513325578951},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1513325578951},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1513325578952},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1513325578957},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1513325578957},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1513325578958},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"f958da71d211f592ca64d0cf1328d801fffd3179","modified":1513325578959},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1513325578958},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1513325578959},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1513325578960},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1513325578960},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1513325578959},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1513325578961},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1513325578962},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1513325578961},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1513325578961},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1513325578962},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1513325578962},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1513325578963},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1513325578964},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fb0d3ae0f0c26393199de8f81fb3658d86fbbfaf","modified":1513325578964},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1513325578963},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1513325578964},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"08a500b2984f109b751f3697ca33172d1340591a","modified":1513325578963},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1513325578965},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1513325578965},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1513325578965},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1513325578965},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1513325578966},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1513325578966},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1513325578966},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1513325578967},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1513325578967},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1513325578967},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1513325578966},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1513325578968},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1513325578968},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"45df0cf4c97b47e05573bcd41028ee50f3fdf432","modified":1513325578968},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1513325578968},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1513325578969},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1513325578969},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1513325578969},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1513325578970},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1513325578970},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1513325578970},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1513325578971},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1513325578970},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1513325578971},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"aeff0e6e23725e8baea27c890ccbbf466024f767","modified":1513325578971},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1513325578978},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1513325578979},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1513325578981},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1513325578999},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1513325578998},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1513325578999},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1513325578999},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1513325579000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1513325579011},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1513325579011},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513325579010},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1513325579010},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1513325579011},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1513325579012},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1513325579021},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1513325579019},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1513325579024},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1513325579007},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1513325579037},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1513325579023}],"Category":[{"name":"前端","_id":"cjclsgbo500056dofcditth6u"},{"name":"个人","_id":"cjclsgboc000e6dofe4i52iga"},{"name":"Crack","_id":"cjclsgboe000k6dof45xykhy4"},{"name":"design","_id":"cjclsgbog000o6dofi4l6ihmq"},{"name":"Linux","_id":"cjclsgbog000t6doffy7t41k5"},{"name":"Java","_id":"cjclsgbqc00186dof6v2vhare"},{"name":"TaskScheduler","_id":"cjclsgbqq001o6dofa6u13y6l"},{"name":"PC","_id":"cjclsgbqy00296dof3swn4zh6"},{"name":"Python","_id":"cjclsgbr0002h6dofvew8e0wn"},{"name":"服务器","_id":"cjclsgbr2002p6dof9ol8mg0e"},{"name":"框架","_id":"cjclsgbsg003q6dofgbdyeqv9"}],"Data":[],"Page":[{"layout":"about","title":"关于","type":"about","_content":"","source":"about/index.md","raw":"---\nlayout: about \ntitle: 关于 \ntype: \"about\"\n---\n","date":"2017-12-15T08:12:58.876Z","updated":"2017-12-15T08:12:58.876Z","path":"about/index.html","comments":1,"_id":"cjclsgbiu00006dof2iawqfh7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2015-10-19T22:49:50.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2015-10-20 06:49:50\ntype: \"categories\"\ncomments: false\n---","updated":"2017-12-15T08:12:58.877Z","path":"categories/index.html","layout":"page","_id":"cjclsgbna00016dofl2ilu0bb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\ncomments: false\n---","date":"2017-12-15T08:12:58.877Z","updated":"2017-12-15T08:12:58.877Z","path":"tags/index.html","layout":"page","_id":"cjclsgbnd00026dofdxlpga7q","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"nvm-install","date":"2017-12-18T02:34:22.000Z","description":"Mac下安装Node并切换taobao.org源","_content":"\n## Mac下安装Node并切换taobao.org源\n\n### 安装 nvm\n\n```bash\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n```\n或\n```bash\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n```\n载入环境变量\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n### 安装Node\n\n```bash\nnvm install 8.2.1\n```\n### 设置淘宝镜像源\n\n```bash\nnpm config set registry https://registry.npm.taobao.org\n```\n","source":"_posts/angular/nvm-install.md","raw":"---\ntitle: nvm-install\ndate: 2017-12-18 10:34:22\ncategories: 前端\ntags: [angular,nvm]\ndescription: Mac下安装Node并切换taobao.org源\n---\n\n## Mac下安装Node并切换taobao.org源\n\n### 安装 nvm\n\n```bash\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n```\n或\n```bash\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash\n```\n载入环境变量\n```bash\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm\n```\n\n### 安装Node\n\n```bash\nnvm install 8.2.1\n```\n### 设置淘宝镜像源\n\n```bash\nnpm config set registry https://registry.npm.taobao.org\n```\n","slug":"angular/nvm-install","published":1,"updated":"2017-12-21T14:46:17.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbnz00036dofraukfkce","content":"<h2 id=\"Mac下安装Node并切换taobao-org源\"><a href=\"#Mac下安装Node并切换taobao-org源\" class=\"headerlink\" title=\"Mac下安装Node并切换taobao.org源\"></a>Mac下安装Node并切换taobao.org源</h2><h3 id=\"安装-nvm\"><a href=\"#安装-nvm\" class=\"headerlink\" title=\"安装 nvm\"></a>安装 nvm</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>或<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure></p>\n<p>载入环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">\"<span class=\"variable\">$HOME</span>/.nvm\"</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> ] &amp;&amp; . <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"comment\"># This loads nvm</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install 8.2.1</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置淘宝镜像源\"><a href=\"#设置淘宝镜像源\" class=\"headerlink\" title=\"设置淘宝镜像源\"></a>设置淘宝镜像源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Mac下安装Node并切换taobao-org源\"><a href=\"#Mac下安装Node并切换taobao-org源\" class=\"headerlink\" title=\"Mac下安装Node并切换taobao.org源\"></a>Mac下安装Node并切换taobao.org源</h2><h3 id=\"安装-nvm\"><a href=\"#安装-nvm\" class=\"headerlink\" title=\"安装 nvm\"></a>安装 nvm</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>或<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure></p>\n<p>载入环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">\"<span class=\"variable\">$HOME</span>/.nvm\"</span></span><br><span class=\"line\">[ -s <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> ] &amp;&amp; . <span class=\"string\">\"<span class=\"variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"comment\"># This loads nvm</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install 8.2.1</span><br></pre></td></tr></table></figure>\n<h3 id=\"设置淘宝镜像源\"><a href=\"#设置淘宝镜像源\" class=\"headerlink\" title=\"设置淘宝镜像源\"></a>设置淘宝镜像源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n"},{"title":"npm那些坑","date":"2018-01-19T02:34:22.000Z","description":"npm遇到那些坑","_content":"\n## windows环境下：\n### 1. node-gyp需要python环境\n错误原因：node-gyp需要python环境\n\n报错信息如下：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/905DEFB5-7FF8-4829-B9F7-6639FF4FF0D8.png)\n\n解决方案：\n\n以管理员权限运行CMD：\n\n```bash\nnpm install --global --production windows-build-tools\n```\n\n参考资料：[node-gyp](https://github.com/nodejs/node-gyp#on-windows)\n\n### 2. Unexpected end of input at 1:10971 se,\"deprecated\":\"We\\\\'re really excited that you\\\\'re trying to use E\n\n错误原因：未知，猜测可能是npm-cache影响\n\n报错信息如下：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/36D8795D-C4B5-41CF-88DB-84280F675536.png)\n解决方案：\n\n清空`C:\\Users\\lit\\AppData\\Roaming\\npm-cache`目录\n\n### 3. 'webpack-dev-server' 不是内部或外部命令，也不是可运行的程序或批处理文件。\n\n","source":"_posts/angular/windows-npm-error.md","raw":"---\ntitle: npm那些坑\ndate: 2018-01-19 10:34:22\ncategories: 前端\ntags: [angular,nvm]\ndescription: npm遇到那些坑\n---\n\n## windows环境下：\n### 1. node-gyp需要python环境\n错误原因：node-gyp需要python环境\n\n报错信息如下：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/905DEFB5-7FF8-4829-B9F7-6639FF4FF0D8.png)\n\n解决方案：\n\n以管理员权限运行CMD：\n\n```bash\nnpm install --global --production windows-build-tools\n```\n\n参考资料：[node-gyp](https://github.com/nodejs/node-gyp#on-windows)\n\n### 2. Unexpected end of input at 1:10971 se,\"deprecated\":\"We\\\\'re really excited that you\\\\'re trying to use E\n\n错误原因：未知，猜测可能是npm-cache影响\n\n报错信息如下：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/36D8795D-C4B5-41CF-88DB-84280F675536.png)\n解决方案：\n\n清空`C:\\Users\\lit\\AppData\\Roaming\\npm-cache`目录\n\n### 3. 'webpack-dev-server' 不是内部或外部命令，也不是可运行的程序或批处理文件。\n\n","slug":"angular/windows-npm-error","published":1,"updated":"2018-01-19T11:07:31.017Z","_id":"cjclsgbo100046dofzpx5idzs","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"windows环境下：\"><a href=\"#windows环境下：\" class=\"headerlink\" title=\"windows环境下：\"></a>windows环境下：</h2><h3 id=\"1-node-gyp需要python环境\"><a href=\"#1-node-gyp需要python环境\" class=\"headerlink\" title=\"1. node-gyp需要python环境\"></a>1. node-gyp需要python环境</h3><p>错误原因：node-gyp需要python环境</p>\n<p>报错信息如下：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/905DEFB5-7FF8-4829-B9F7-6639FF4FF0D8.png\" alt=\"avatar\"></p>\n<p>解决方案：</p>\n<p>以管理员权限运行CMD：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure>\n<p>参考资料：<a href=\"https://github.com/nodejs/node-gyp#on-windows\" target=\"_blank\" rel=\"noopener\">node-gyp</a></p>\n<h3 id=\"2-Unexpected-end-of-input-at-1-10971-se-”deprecated”-”We-‘re-really-excited-that-you-‘re-trying-to-use-E\"><a href=\"#2-Unexpected-end-of-input-at-1-10971-se-”deprecated”-”We-‘re-really-excited-that-you-‘re-trying-to-use-E\" class=\"headerlink\" title=\"2. Unexpected end of input at 1:10971 se,”deprecated”:”We\\‘re really excited that you\\‘re trying to use E\"></a>2. Unexpected end of input at 1:10971 se,”deprecated”:”We\\‘re really excited that you\\‘re trying to use E</h3><p>错误原因：未知，猜测可能是npm-cache影响</p>\n<p>报错信息如下：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/36D8795D-C4B5-41CF-88DB-84280F675536.png\" alt=\"avatar\"><br>解决方案：</p>\n<p>清空<code>C:\\Users\\lit\\AppData\\Roaming\\npm-cache</code>目录</p>\n<h3 id=\"3-‘webpack-dev-server’-不是内部或外部命令，也不是可运行的程序或批处理文件。\"><a href=\"#3-‘webpack-dev-server’-不是内部或外部命令，也不是可运行的程序或批处理文件。\" class=\"headerlink\" title=\"3. ‘webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序或批处理文件。\"></a>3. ‘webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"windows环境下：\"><a href=\"#windows环境下：\" class=\"headerlink\" title=\"windows环境下：\"></a>windows环境下：</h2><h3 id=\"1-node-gyp需要python环境\"><a href=\"#1-node-gyp需要python环境\" class=\"headerlink\" title=\"1. node-gyp需要python环境\"></a>1. node-gyp需要python环境</h3><p>错误原因：node-gyp需要python环境</p>\n<p>报错信息如下：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/905DEFB5-7FF8-4829-B9F7-6639FF4FF0D8.png\" alt=\"avatar\"></p>\n<p>解决方案：</p>\n<p>以管理员权限运行CMD：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure>\n<p>参考资料：<a href=\"https://github.com/nodejs/node-gyp#on-windows\" target=\"_blank\" rel=\"noopener\">node-gyp</a></p>\n<h3 id=\"2-Unexpected-end-of-input-at-1-10971-se-”deprecated”-”We-‘re-really-excited-that-you-‘re-trying-to-use-E\"><a href=\"#2-Unexpected-end-of-input-at-1-10971-se-”deprecated”-”We-‘re-really-excited-that-you-‘re-trying-to-use-E\" class=\"headerlink\" title=\"2. Unexpected end of input at 1:10971 se,”deprecated”:”We\\‘re really excited that you\\‘re trying to use E\"></a>2. Unexpected end of input at 1:10971 se,”deprecated”:”We\\‘re really excited that you\\‘re trying to use E</h3><p>错误原因：未知，猜测可能是npm-cache影响</p>\n<p>报错信息如下：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/36D8795D-C4B5-41CF-88DB-84280F675536.png\" alt=\"avatar\"><br>解决方案：</p>\n<p>清空<code>C:\\Users\\lit\\AppData\\Roaming\\npm-cache</code>目录</p>\n<h3 id=\"3-‘webpack-dev-server’-不是内部或外部命令，也不是可运行的程序或批处理文件。\"><a href=\"#3-‘webpack-dev-server’-不是内部或外部命令，也不是可运行的程序或批处理文件。\" class=\"headerlink\" title=\"3. ‘webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序或批处理文件。\"></a>3. ‘webpack-dev-server’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</h3>"},{"title":"2017 年终总结","date":"2017-12-20T02:34:22.000Z","description":"这一年，我的本命年，好似蕴含着特殊的意义一般，如期而至。 2017 风风雨雨，好像就一直没有停歇过，在挣扎中度日。这一年，特别漫长，却也特别短暂。2017 像是一个玩笑，却一点也不好笑，到最后，自己仿若成了一个笑话。","_content":"\n## 2017 年终总结\n\n### 题记\n\n这一年，我的本命年，好似蕴含着特殊的意义一般，如期而至。 2017 风风雨雨，好像就一直没有停歇过，在挣扎中度日。这一年，特别漫长，却也特别短暂。2017 像是一个玩笑，却一点也不好笑，到最后，自己仿若成了一个笑话。\n\n### \n2016年末，我还在上海，当时只是犹豫着年后会换一家公司。2017年初，却毅然辞去了上海的工作，回西安！\n\n那会儿，我和她因为异地，经常吵架，吵的特别厉害，最严重的时候，一个星期，吵了三次。后院失火，如何还有心思在外面待着，毕竟，什么都没有她重要！当然，当时也考虑到一些其他因素，比如自己一个人在外地，的确想家了，吃不到好吃的面食。但是，这些原因不足以成为回去的理由。\n\n回到西安后，家都没有回，爸妈也没有看，直接先去陕北找她，陕北很冷，主要是风大吧，弄的在上海待了半年的我一时不能适应。但是，只要在一起，其他什么都不重要了！一个星期，很开心，仿佛把几个月的思念揉在了一起，说不完的话，道不尽的思念。\n\n临近农历年关，总是要回家的！想着之后就在西安工作了，放下不舍，回到家里。很快就沉浸在家人给的温暖，很温馨。过完年后，由于金三银四的黄金法则，怀着满满的激情，想着之后再也不用分离了，开始了西安的求职之路。\n\n现实狠狠的给我打了一巴掌，一个月时间，只面试上一家公司。，还不舍得交公积金！呵，我竟如此不济。曾经那个心高气傲的少年，他不曾想过，原来他也有今天。上天是公平的，虽然我很恨那个贼老天，但是，这件事却没有一丝偏袒，我输的心服口服！只恨自己年少不知事，太过轻狂。在连翻打击下，我总结了自己何以落魄如此：\n\n1. 从实习公司到次年找工作这段时间，自己一直在吃老本，没有学习东西，而以前的东西却也一年没碰，忘的七七八八。\n2. 这一年，其他人都在成长，我却快把老本忘光了。\n3. 傲，傲气太重，太过自负，对自己没有一个合适的定位。\n4. 西安的软件行业大市场环境较差。\n\n那会儿，信用卡又开始负债累累了，老姐也一直催着我不行再去外地。去更大的市场，潜心修行~ 而，自己一直在犹豫，毕竟，这次回来的初衷，不能忘！我可以随便在西安先找一个，等到她实习的时候，和她一起去外地。而这个时间段，短则半年，长则一年多一些，我觉得自己等得起。\n\n后来发生了一件事，在我犹豫的时候！我生日，她送我了一个钱包，说实话，蛮喜欢的，瞄了一眼盒子上的价签，贵的超出了我那会儿对钱包的价值认知，一下觉得不是那么有必要了，还是穷吧。后来因为这个就吵起来了，吵的特别厉害！有一句话，我现在还记得特别清晰“你没钱，你穷，我有钱，我花我的钱你还管，你不想要，扔了！”男人的自尊心受到了极大的挫伤，是啊，我不过一穷小子罢了！仿佛一下子让我认清了现实，什么是现实，现实就是你穷，没钱，你最爱的人也会从潜意识里认为你没用，会瞧不起你！\n\n那次吵架，成为压倒我再次去外地的主力军，势如破竹！只因为，我不能再穷下去了！我要挣钱，以后，这类的事件再也不会成为我们吵架的原因，待年底去见她家长，我能够挺直腰杆，向她父母证明，我有能力照顾好她！我爱她，但是如果不出去，我们可能没有明天。似乎，有千千万万的理由，出去的理由，每条都是那么实际，不再包含理想色彩！既然决定再次出发，这次我选择了杭州，原因如下：\n1. 杭州生活节奏没有上海那么快，最起码上下班不用花三个小时。\n2. 杭州湿度没有上海那么大，尤其是梅雨季节。\n3. 杭州综合环境、玩的地方要比上海多很多，以后，可以带她在这边玩。\n4. 杭州作为二线城市里面的一线城市，很有发展潜力。\n5. 杭州有阿里在，在电商的带动下，软件行业发展的也很不错，由于电商性质，之后可以往大数据、数据分析等方面延伸，对职业发展符合。\n\n毅然而然的来到杭州。走的时候，她要送我，没敢让送。我怕我一回头，好不容易积攒出来的勇气又没了！到杭州后，只身一人，暂时住在宾馆里面。或许因为之前西安所受的挫折，面试时不够自信，恶性循环，结果当然不尽人意！直至，第二周的周四。我来到钱皇，也是我在杭州命运的转折点。第一次遇到我们老大——般若，一直板着个脸，从看人的经验来看，应该是一个搞技术的，刻板，严肃，认真，技术应该很牛，属于一心研究技术，情商为负的那种！这是对般若的第一印象！说实话，有点吓到。也很没有底气！毕竟，耽搁了一年，技术上没有什么成长，估计一吹牛就会被很尴尬的拆穿！面试的过程不是很顺利，问了很多基础的问题，逐渐深入，到最后只能模棱两可的回答！有时候，说错了，般若会告诉我应该是什么样子的！逐渐放松，觉得估计面试不上，但是即使这样，也可以学到很多东西！这一趟，来的值！最后，般若问我，学习主要看什么。由于之前的经历，很清楚自己到底想要什么！我说，主要看自己，当然外部环境的推动也很重要！就这样，心情很舒畅的回去了。毕竟，自己清楚自己现在到底几斤几两，而且这次面试完全被虐了，很惨，怎么看都没什么戏的！\n\n令人意外的是，下午两点多，接到了人事的电话！人事说的很直白，到现在都觉得说的也太直接了吧！人事告诉我：“这边的技术主管说，你的技术水平是不符合公司要求的，但是你的学习态度很好！可以过来试试，薪资就按照你和般若谈的来” 天啦，感觉整场面试最重要的是最后一句话。。。\n\n第二周办完所有手续，到公司入职。想着这次碰到一个大牛了，一定要跟着大牛好好混，同样的错误坚决不能犯两次！而且，时刻铭记着这次为什么出来！她半年后，也能过来实习了。这半年，我在杭州打好基础！等她过来！满怀期待的进入了工作中，第一天我就开始加班，当时只想多学习一些东西。（没想到后来加班成了家常便饭，当然这是后话！）\n","source":"_posts/daily/2017-summary.md","raw":"---\ntitle: 2017 年终总结\ndate: 2017-12-20 10:34:22\ncategories: 个人\ntags: [Person]\ndescription: 这一年，我的本命年，好似蕴含着特殊的意义一般，如期而至。 2017 风风雨雨，好像就一直没有停歇过，在挣扎中度日。这一年，特别漫长，却也特别短暂。2017 像是一个玩笑，却一点也不好笑，到最后，自己仿若成了一个笑话。\n---\n\n## 2017 年终总结\n\n### 题记\n\n这一年，我的本命年，好似蕴含着特殊的意义一般，如期而至。 2017 风风雨雨，好像就一直没有停歇过，在挣扎中度日。这一年，特别漫长，却也特别短暂。2017 像是一个玩笑，却一点也不好笑，到最后，自己仿若成了一个笑话。\n\n### \n2016年末，我还在上海，当时只是犹豫着年后会换一家公司。2017年初，却毅然辞去了上海的工作，回西安！\n\n那会儿，我和她因为异地，经常吵架，吵的特别厉害，最严重的时候，一个星期，吵了三次。后院失火，如何还有心思在外面待着，毕竟，什么都没有她重要！当然，当时也考虑到一些其他因素，比如自己一个人在外地，的确想家了，吃不到好吃的面食。但是，这些原因不足以成为回去的理由。\n\n回到西安后，家都没有回，爸妈也没有看，直接先去陕北找她，陕北很冷，主要是风大吧，弄的在上海待了半年的我一时不能适应。但是，只要在一起，其他什么都不重要了！一个星期，很开心，仿佛把几个月的思念揉在了一起，说不完的话，道不尽的思念。\n\n临近农历年关，总是要回家的！想着之后就在西安工作了，放下不舍，回到家里。很快就沉浸在家人给的温暖，很温馨。过完年后，由于金三银四的黄金法则，怀着满满的激情，想着之后再也不用分离了，开始了西安的求职之路。\n\n现实狠狠的给我打了一巴掌，一个月时间，只面试上一家公司。，还不舍得交公积金！呵，我竟如此不济。曾经那个心高气傲的少年，他不曾想过，原来他也有今天。上天是公平的，虽然我很恨那个贼老天，但是，这件事却没有一丝偏袒，我输的心服口服！只恨自己年少不知事，太过轻狂。在连翻打击下，我总结了自己何以落魄如此：\n\n1. 从实习公司到次年找工作这段时间，自己一直在吃老本，没有学习东西，而以前的东西却也一年没碰，忘的七七八八。\n2. 这一年，其他人都在成长，我却快把老本忘光了。\n3. 傲，傲气太重，太过自负，对自己没有一个合适的定位。\n4. 西安的软件行业大市场环境较差。\n\n那会儿，信用卡又开始负债累累了，老姐也一直催着我不行再去外地。去更大的市场，潜心修行~ 而，自己一直在犹豫，毕竟，这次回来的初衷，不能忘！我可以随便在西安先找一个，等到她实习的时候，和她一起去外地。而这个时间段，短则半年，长则一年多一些，我觉得自己等得起。\n\n后来发生了一件事，在我犹豫的时候！我生日，她送我了一个钱包，说实话，蛮喜欢的，瞄了一眼盒子上的价签，贵的超出了我那会儿对钱包的价值认知，一下觉得不是那么有必要了，还是穷吧。后来因为这个就吵起来了，吵的特别厉害！有一句话，我现在还记得特别清晰“你没钱，你穷，我有钱，我花我的钱你还管，你不想要，扔了！”男人的自尊心受到了极大的挫伤，是啊，我不过一穷小子罢了！仿佛一下子让我认清了现实，什么是现实，现实就是你穷，没钱，你最爱的人也会从潜意识里认为你没用，会瞧不起你！\n\n那次吵架，成为压倒我再次去外地的主力军，势如破竹！只因为，我不能再穷下去了！我要挣钱，以后，这类的事件再也不会成为我们吵架的原因，待年底去见她家长，我能够挺直腰杆，向她父母证明，我有能力照顾好她！我爱她，但是如果不出去，我们可能没有明天。似乎，有千千万万的理由，出去的理由，每条都是那么实际，不再包含理想色彩！既然决定再次出发，这次我选择了杭州，原因如下：\n1. 杭州生活节奏没有上海那么快，最起码上下班不用花三个小时。\n2. 杭州湿度没有上海那么大，尤其是梅雨季节。\n3. 杭州综合环境、玩的地方要比上海多很多，以后，可以带她在这边玩。\n4. 杭州作为二线城市里面的一线城市，很有发展潜力。\n5. 杭州有阿里在，在电商的带动下，软件行业发展的也很不错，由于电商性质，之后可以往大数据、数据分析等方面延伸，对职业发展符合。\n\n毅然而然的来到杭州。走的时候，她要送我，没敢让送。我怕我一回头，好不容易积攒出来的勇气又没了！到杭州后，只身一人，暂时住在宾馆里面。或许因为之前西安所受的挫折，面试时不够自信，恶性循环，结果当然不尽人意！直至，第二周的周四。我来到钱皇，也是我在杭州命运的转折点。第一次遇到我们老大——般若，一直板着个脸，从看人的经验来看，应该是一个搞技术的，刻板，严肃，认真，技术应该很牛，属于一心研究技术，情商为负的那种！这是对般若的第一印象！说实话，有点吓到。也很没有底气！毕竟，耽搁了一年，技术上没有什么成长，估计一吹牛就会被很尴尬的拆穿！面试的过程不是很顺利，问了很多基础的问题，逐渐深入，到最后只能模棱两可的回答！有时候，说错了，般若会告诉我应该是什么样子的！逐渐放松，觉得估计面试不上，但是即使这样，也可以学到很多东西！这一趟，来的值！最后，般若问我，学习主要看什么。由于之前的经历，很清楚自己到底想要什么！我说，主要看自己，当然外部环境的推动也很重要！就这样，心情很舒畅的回去了。毕竟，自己清楚自己现在到底几斤几两，而且这次面试完全被虐了，很惨，怎么看都没什么戏的！\n\n令人意外的是，下午两点多，接到了人事的电话！人事说的很直白，到现在都觉得说的也太直接了吧！人事告诉我：“这边的技术主管说，你的技术水平是不符合公司要求的，但是你的学习态度很好！可以过来试试，薪资就按照你和般若谈的来” 天啦，感觉整场面试最重要的是最后一句话。。。\n\n第二周办完所有手续，到公司入职。想着这次碰到一个大牛了，一定要跟着大牛好好混，同样的错误坚决不能犯两次！而且，时刻铭记着这次为什么出来！她半年后，也能过来实习了。这半年，我在杭州打好基础！等她过来！满怀期待的进入了工作中，第一天我就开始加班，当时只想多学习一些东西。（没想到后来加班成了家常便饭，当然这是后话！）\n","slug":"daily/2017-summary","published":1,"updated":"2018-01-04T01:15:09.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbo700076dofhsd2w2gq","content":"<h2 id=\"2017-年终总结\"><a href=\"#2017-年终总结\" class=\"headerlink\" title=\"2017 年终总结\"></a>2017 年终总结</h2><h3 id=\"题记\"><a href=\"#题记\" class=\"headerlink\" title=\"题记\"></a>题记</h3><p>这一年，我的本命年，好似蕴含着特殊的意义一般，如期而至。 2017 风风雨雨，好像就一直没有停歇过，在挣扎中度日。这一年，特别漫长，却也特别短暂。2017 像是一个玩笑，却一点也不好笑，到最后，自己仿若成了一个笑话。</p>\n<p>###<br>2016年末，我还在上海，当时只是犹豫着年后会换一家公司。2017年初，却毅然辞去了上海的工作，回西安！</p>\n<p>那会儿，我和她因为异地，经常吵架，吵的特别厉害，最严重的时候，一个星期，吵了三次。后院失火，如何还有心思在外面待着，毕竟，什么都没有她重要！当然，当时也考虑到一些其他因素，比如自己一个人在外地，的确想家了，吃不到好吃的面食。但是，这些原因不足以成为回去的理由。</p>\n<p>回到西安后，家都没有回，爸妈也没有看，直接先去陕北找她，陕北很冷，主要是风大吧，弄的在上海待了半年的我一时不能适应。但是，只要在一起，其他什么都不重要了！一个星期，很开心，仿佛把几个月的思念揉在了一起，说不完的话，道不尽的思念。</p>\n<p>临近农历年关，总是要回家的！想着之后就在西安工作了，放下不舍，回到家里。很快就沉浸在家人给的温暖，很温馨。过完年后，由于金三银四的黄金法则，怀着满满的激情，想着之后再也不用分离了，开始了西安的求职之路。</p>\n<p>现实狠狠的给我打了一巴掌，一个月时间，只面试上一家公司。，还不舍得交公积金！呵，我竟如此不济。曾经那个心高气傲的少年，他不曾想过，原来他也有今天。上天是公平的，虽然我很恨那个贼老天，但是，这件事却没有一丝偏袒，我输的心服口服！只恨自己年少不知事，太过轻狂。在连翻打击下，我总结了自己何以落魄如此：</p>\n<ol>\n<li>从实习公司到次年找工作这段时间，自己一直在吃老本，没有学习东西，而以前的东西却也一年没碰，忘的七七八八。</li>\n<li>这一年，其他人都在成长，我却快把老本忘光了。</li>\n<li>傲，傲气太重，太过自负，对自己没有一个合适的定位。</li>\n<li>西安的软件行业大市场环境较差。</li>\n</ol>\n<p>那会儿，信用卡又开始负债累累了，老姐也一直催着我不行再去外地。去更大的市场，潜心修行~ 而，自己一直在犹豫，毕竟，这次回来的初衷，不能忘！我可以随便在西安先找一个，等到她实习的时候，和她一起去外地。而这个时间段，短则半年，长则一年多一些，我觉得自己等得起。</p>\n<p>后来发生了一件事，在我犹豫的时候！我生日，她送我了一个钱包，说实话，蛮喜欢的，瞄了一眼盒子上的价签，贵的超出了我那会儿对钱包的价值认知，一下觉得不是那么有必要了，还是穷吧。后来因为这个就吵起来了，吵的特别厉害！有一句话，我现在还记得特别清晰“你没钱，你穷，我有钱，我花我的钱你还管，你不想要，扔了！”男人的自尊心受到了极大的挫伤，是啊，我不过一穷小子罢了！仿佛一下子让我认清了现实，什么是现实，现实就是你穷，没钱，你最爱的人也会从潜意识里认为你没用，会瞧不起你！</p>\n<p>那次吵架，成为压倒我再次去外地的主力军，势如破竹！只因为，我不能再穷下去了！我要挣钱，以后，这类的事件再也不会成为我们吵架的原因，待年底去见她家长，我能够挺直腰杆，向她父母证明，我有能力照顾好她！我爱她，但是如果不出去，我们可能没有明天。似乎，有千千万万的理由，出去的理由，每条都是那么实际，不再包含理想色彩！既然决定再次出发，这次我选择了杭州，原因如下：</p>\n<ol>\n<li>杭州生活节奏没有上海那么快，最起码上下班不用花三个小时。</li>\n<li>杭州湿度没有上海那么大，尤其是梅雨季节。</li>\n<li>杭州综合环境、玩的地方要比上海多很多，以后，可以带她在这边玩。</li>\n<li>杭州作为二线城市里面的一线城市，很有发展潜力。</li>\n<li>杭州有阿里在，在电商的带动下，软件行业发展的也很不错，由于电商性质，之后可以往大数据、数据分析等方面延伸，对职业发展符合。</li>\n</ol>\n<p>毅然而然的来到杭州。走的时候，她要送我，没敢让送。我怕我一回头，好不容易积攒出来的勇气又没了！到杭州后，只身一人，暂时住在宾馆里面。或许因为之前西安所受的挫折，面试时不够自信，恶性循环，结果当然不尽人意！直至，第二周的周四。我来到钱皇，也是我在杭州命运的转折点。第一次遇到我们老大——般若，一直板着个脸，从看人的经验来看，应该是一个搞技术的，刻板，严肃，认真，技术应该很牛，属于一心研究技术，情商为负的那种！这是对般若的第一印象！说实话，有点吓到。也很没有底气！毕竟，耽搁了一年，技术上没有什么成长，估计一吹牛就会被很尴尬的拆穿！面试的过程不是很顺利，问了很多基础的问题，逐渐深入，到最后只能模棱两可的回答！有时候，说错了，般若会告诉我应该是什么样子的！逐渐放松，觉得估计面试不上，但是即使这样，也可以学到很多东西！这一趟，来的值！最后，般若问我，学习主要看什么。由于之前的经历，很清楚自己到底想要什么！我说，主要看自己，当然外部环境的推动也很重要！就这样，心情很舒畅的回去了。毕竟，自己清楚自己现在到底几斤几两，而且这次面试完全被虐了，很惨，怎么看都没什么戏的！</p>\n<p>令人意外的是，下午两点多，接到了人事的电话！人事说的很直白，到现在都觉得说的也太直接了吧！人事告诉我：“这边的技术主管说，你的技术水平是不符合公司要求的，但是你的学习态度很好！可以过来试试，薪资就按照你和般若谈的来” 天啦，感觉整场面试最重要的是最后一句话。。。</p>\n<p>第二周办完所有手续，到公司入职。想着这次碰到一个大牛了，一定要跟着大牛好好混，同样的错误坚决不能犯两次！而且，时刻铭记着这次为什么出来！她半年后，也能过来实习了。这半年，我在杭州打好基础！等她过来！满怀期待的进入了工作中，第一天我就开始加班，当时只想多学习一些东西。（没想到后来加班成了家常便饭，当然这是后话！）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"2017-年终总结\"><a href=\"#2017-年终总结\" class=\"headerlink\" title=\"2017 年终总结\"></a>2017 年终总结</h2><h3 id=\"题记\"><a href=\"#题记\" class=\"headerlink\" title=\"题记\"></a>题记</h3><p>这一年，我的本命年，好似蕴含着特殊的意义一般，如期而至。 2017 风风雨雨，好像就一直没有停歇过，在挣扎中度日。这一年，特别漫长，却也特别短暂。2017 像是一个玩笑，却一点也不好笑，到最后，自己仿若成了一个笑话。</p>\n<p>###<br>2016年末，我还在上海，当时只是犹豫着年后会换一家公司。2017年初，却毅然辞去了上海的工作，回西安！</p>\n<p>那会儿，我和她因为异地，经常吵架，吵的特别厉害，最严重的时候，一个星期，吵了三次。后院失火，如何还有心思在外面待着，毕竟，什么都没有她重要！当然，当时也考虑到一些其他因素，比如自己一个人在外地，的确想家了，吃不到好吃的面食。但是，这些原因不足以成为回去的理由。</p>\n<p>回到西安后，家都没有回，爸妈也没有看，直接先去陕北找她，陕北很冷，主要是风大吧，弄的在上海待了半年的我一时不能适应。但是，只要在一起，其他什么都不重要了！一个星期，很开心，仿佛把几个月的思念揉在了一起，说不完的话，道不尽的思念。</p>\n<p>临近农历年关，总是要回家的！想着之后就在西安工作了，放下不舍，回到家里。很快就沉浸在家人给的温暖，很温馨。过完年后，由于金三银四的黄金法则，怀着满满的激情，想着之后再也不用分离了，开始了西安的求职之路。</p>\n<p>现实狠狠的给我打了一巴掌，一个月时间，只面试上一家公司。，还不舍得交公积金！呵，我竟如此不济。曾经那个心高气傲的少年，他不曾想过，原来他也有今天。上天是公平的，虽然我很恨那个贼老天，但是，这件事却没有一丝偏袒，我输的心服口服！只恨自己年少不知事，太过轻狂。在连翻打击下，我总结了自己何以落魄如此：</p>\n<ol>\n<li>从实习公司到次年找工作这段时间，自己一直在吃老本，没有学习东西，而以前的东西却也一年没碰，忘的七七八八。</li>\n<li>这一年，其他人都在成长，我却快把老本忘光了。</li>\n<li>傲，傲气太重，太过自负，对自己没有一个合适的定位。</li>\n<li>西安的软件行业大市场环境较差。</li>\n</ol>\n<p>那会儿，信用卡又开始负债累累了，老姐也一直催着我不行再去外地。去更大的市场，潜心修行~ 而，自己一直在犹豫，毕竟，这次回来的初衷，不能忘！我可以随便在西安先找一个，等到她实习的时候，和她一起去外地。而这个时间段，短则半年，长则一年多一些，我觉得自己等得起。</p>\n<p>后来发生了一件事，在我犹豫的时候！我生日，她送我了一个钱包，说实话，蛮喜欢的，瞄了一眼盒子上的价签，贵的超出了我那会儿对钱包的价值认知，一下觉得不是那么有必要了，还是穷吧。后来因为这个就吵起来了，吵的特别厉害！有一句话，我现在还记得特别清晰“你没钱，你穷，我有钱，我花我的钱你还管，你不想要，扔了！”男人的自尊心受到了极大的挫伤，是啊，我不过一穷小子罢了！仿佛一下子让我认清了现实，什么是现实，现实就是你穷，没钱，你最爱的人也会从潜意识里认为你没用，会瞧不起你！</p>\n<p>那次吵架，成为压倒我再次去外地的主力军，势如破竹！只因为，我不能再穷下去了！我要挣钱，以后，这类的事件再也不会成为我们吵架的原因，待年底去见她家长，我能够挺直腰杆，向她父母证明，我有能力照顾好她！我爱她，但是如果不出去，我们可能没有明天。似乎，有千千万万的理由，出去的理由，每条都是那么实际，不再包含理想色彩！既然决定再次出发，这次我选择了杭州，原因如下：</p>\n<ol>\n<li>杭州生活节奏没有上海那么快，最起码上下班不用花三个小时。</li>\n<li>杭州湿度没有上海那么大，尤其是梅雨季节。</li>\n<li>杭州综合环境、玩的地方要比上海多很多，以后，可以带她在这边玩。</li>\n<li>杭州作为二线城市里面的一线城市，很有发展潜力。</li>\n<li>杭州有阿里在，在电商的带动下，软件行业发展的也很不错，由于电商性质，之后可以往大数据、数据分析等方面延伸，对职业发展符合。</li>\n</ol>\n<p>毅然而然的来到杭州。走的时候，她要送我，没敢让送。我怕我一回头，好不容易积攒出来的勇气又没了！到杭州后，只身一人，暂时住在宾馆里面。或许因为之前西安所受的挫折，面试时不够自信，恶性循环，结果当然不尽人意！直至，第二周的周四。我来到钱皇，也是我在杭州命运的转折点。第一次遇到我们老大——般若，一直板着个脸，从看人的经验来看，应该是一个搞技术的，刻板，严肃，认真，技术应该很牛，属于一心研究技术，情商为负的那种！这是对般若的第一印象！说实话，有点吓到。也很没有底气！毕竟，耽搁了一年，技术上没有什么成长，估计一吹牛就会被很尴尬的拆穿！面试的过程不是很顺利，问了很多基础的问题，逐渐深入，到最后只能模棱两可的回答！有时候，说错了，般若会告诉我应该是什么样子的！逐渐放松，觉得估计面试不上，但是即使这样，也可以学到很多东西！这一趟，来的值！最后，般若问我，学习主要看什么。由于之前的经历，很清楚自己到底想要什么！我说，主要看自己，当然外部环境的推动也很重要！就这样，心情很舒畅的回去了。毕竟，自己清楚自己现在到底几斤几两，而且这次面试完全被虐了，很惨，怎么看都没什么戏的！</p>\n<p>令人意外的是，下午两点多，接到了人事的电话！人事说的很直白，到现在都觉得说的也太直接了吧！人事告诉我：“这边的技术主管说，你的技术水平是不符合公司要求的，但是你的学习态度很好！可以过来试试，薪资就按照你和般若谈的来” 天啦，感觉整场面试最重要的是最后一句话。。。</p>\n<p>第二周办完所有手续，到公司入职。想着这次碰到一个大牛了，一定要跟着大牛好好混，同样的错误坚决不能犯两次！而且，时刻铭记着这次为什么出来！她半年后，也能过来实习了。这半年，我在杭州打好基础！等她过来！满怀期待的进入了工作中，第一天我就开始加班，当时只想多学习一些东西。（没想到后来加班成了家常便饭，当然这是后话！）</p>\n"},{"title":"Navicat Premium For Mac激活","date":"2018-01-06T17:33:22.000Z","description":"之前一直用的win版的Navicat Premium激活比较容易，后来换了Mac找了蛮久才找到该大牛提供的方案。","_content":"\n直接上干货！！！\n\n先附上注册码算法脚本链接：https://pan.baidu.com/s/1pKYDYzD\n\n1. 附件里有rpk文件，这个东西是整个过程中要用的公钥文件，请替换掉程序里对应的文件：Navicat Premium.app/Contents/Resources/rpk\n\n2. private.pem是对应的私钥文件，navicat-keygen是我生成的程序，所以直接在终端（Terminals）进入所在目录：\n\n```bash\n$ ./navicat-keygen private.pem\n```\n先填名字和组织名称，之后会生成一个序列号，并要求填入请求码。\n\n打开navicat，断网。\n\n在注册界面填入序列号，然后激活。这时会提示要手动激活，ok就选这个,接下来会有请求码，复制然后贴入控制台，就可以得到注册码了。剩下的就不用说了吧。\n\n\n[更多细节参考作者原文！！！](https://www.52pojie.cn/forum.php?mod=viewthread&tid=674330&pid=18228081&page=1)\n\n","source":"_posts/db/Navicat-Premium-For-Mac-Activate.md","raw":"---\ntitle: Navicat Premium For Mac激活\ndate: 2018-01-07 01:33:22\ncategories: Crack\ntags: [Crack]\ndescription: 之前一直用的win版的Navicat Premium激活比较容易，后来换了Mac找了蛮久才找到该大牛提供的方案。\n---\n\n直接上干货！！！\n\n先附上注册码算法脚本链接：https://pan.baidu.com/s/1pKYDYzD\n\n1. 附件里有rpk文件，这个东西是整个过程中要用的公钥文件，请替换掉程序里对应的文件：Navicat Premium.app/Contents/Resources/rpk\n\n2. private.pem是对应的私钥文件，navicat-keygen是我生成的程序，所以直接在终端（Terminals）进入所在目录：\n\n```bash\n$ ./navicat-keygen private.pem\n```\n先填名字和组织名称，之后会生成一个序列号，并要求填入请求码。\n\n打开navicat，断网。\n\n在注册界面填入序列号，然后激活。这时会提示要手动激活，ok就选这个,接下来会有请求码，复制然后贴入控制台，就可以得到注册码了。剩下的就不用说了吧。\n\n\n[更多细节参考作者原文！！！](https://www.52pojie.cn/forum.php?mod=viewthread&tid=674330&pid=18228081&page=1)\n\n","slug":"db/Navicat-Premium-For-Mac-Activate","published":1,"updated":"2018-01-06T17:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbo700086dofx87cxaqi","content":"<p>直接上干货！！！</p>\n<p>先附上注册码算法脚本链接：<a href=\"https://pan.baidu.com/s/1pKYDYzD\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1pKYDYzD</a></p>\n<ol>\n<li><p>附件里有rpk文件，这个东西是整个过程中要用的公钥文件，请替换掉程序里对应的文件：Navicat Premium.app/Contents/Resources/rpk</p>\n</li>\n<li><p>private.pem是对应的私钥文件，navicat-keygen是我生成的程序，所以直接在终端（Terminals）进入所在目录：</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./navicat-keygen private.pem</span><br></pre></td></tr></table></figure>\n<p>先填名字和组织名称，之后会生成一个序列号，并要求填入请求码。</p>\n<p>打开navicat，断网。</p>\n<p>在注册界面填入序列号，然后激活。这时会提示要手动激活，ok就选这个,接下来会有请求码，复制然后贴入控制台，就可以得到注册码了。剩下的就不用说了吧。</p>\n<p><a href=\"https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=674330&amp;pid=18228081&amp;page=1\" target=\"_blank\" rel=\"noopener\">更多细节参考作者原文！！！</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>直接上干货！！！</p>\n<p>先附上注册码算法脚本链接：<a href=\"https://pan.baidu.com/s/1pKYDYzD\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1pKYDYzD</a></p>\n<ol>\n<li><p>附件里有rpk文件，这个东西是整个过程中要用的公钥文件，请替换掉程序里对应的文件：Navicat Premium.app/Contents/Resources/rpk</p>\n</li>\n<li><p>private.pem是对应的私钥文件，navicat-keygen是我生成的程序，所以直接在终端（Terminals）进入所在目录：</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./navicat-keygen private.pem</span><br></pre></td></tr></table></figure>\n<p>先填名字和组织名称，之后会生成一个序列号，并要求填入请求码。</p>\n<p>打开navicat，断网。</p>\n<p>在注册界面填入序列号，然后激活。这时会提示要手动激活，ok就选这个,接下来会有请求码，复制然后贴入控制台，就可以得到注册码了。剩下的就不用说了吧。</p>\n<p><a href=\"https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=674330&amp;pid=18228081&amp;page=1\" target=\"_blank\" rel=\"noopener\">更多细节参考作者原文！！！</a></p>\n"},{"title":"病房管理系统","date":"2018-01-05T02:33:22.000Z","description":"病房管理系统初步设计方案","_content":"\n## 工作台\n\n主要针对不同人员登录进来后的待办事项进行规划\n\n可能会去掉患者自动注册的功能，主要考虑到该系统的使用人群是医院的工作人员，患者主动注册，使用的目标人群就不清晰了，功能点设计也就会变得很乱\n\n## 人员管理\n该模块只有系统管理员可以操作\n### 医生管理\n\n管理员对医生的信息进行维护\n\n### 护士管理\n\n管理员对护士的信息进行维护\n\n### 患者管理\n\n管理员对患者的信息进行维护\n## 分诊\n\n### 医生门诊\n\n医生进来后的工作区域，主要内容包含，对病人进行快速接诊，开处方药、分配陪护人员、分配病房、医嘱等功能\n### 门诊记录\n当前登录医生查看自己门诊的记录，包含病人的基本信息、所开的处方药、病人的康复状态、病人的病房状态、病人的陪护状态\n\n## 陪护管理\n\n### 医嘱处理\n当前护士对分配到自己下面的患者，按照医生对病人开的药按时进行监护服用、换药、等操作、患者转病房\n### 看护记录\n护士看护的记录\n## 病房管理\n### 病房管理\n当前医院各类型病房的状态，病床的使用情况、病床的报修\n### 病房记录\n各个病房的使用记录\n## 系统设置\n该模块的内容只有系统管理员可以操作\n### 病房设置\n管理员设置病房信息，包含床位价格等\n### 处方设置\n管理员对处方药进行设置，包含药品类型、价格、等信息\n\n\n    \n    \n","source":"_posts/design/Hospital.md","raw":"---\ntitle: 病房管理系统\ndate: 2018-01-05 10:33:22\ncategories: design\ntags: [design]\ndescription: 病房管理系统初步设计方案\n---\n\n## 工作台\n\n主要针对不同人员登录进来后的待办事项进行规划\n\n可能会去掉患者自动注册的功能，主要考虑到该系统的使用人群是医院的工作人员，患者主动注册，使用的目标人群就不清晰了，功能点设计也就会变得很乱\n\n## 人员管理\n该模块只有系统管理员可以操作\n### 医生管理\n\n管理员对医生的信息进行维护\n\n### 护士管理\n\n管理员对护士的信息进行维护\n\n### 患者管理\n\n管理员对患者的信息进行维护\n## 分诊\n\n### 医生门诊\n\n医生进来后的工作区域，主要内容包含，对病人进行快速接诊，开处方药、分配陪护人员、分配病房、医嘱等功能\n### 门诊记录\n当前登录医生查看自己门诊的记录，包含病人的基本信息、所开的处方药、病人的康复状态、病人的病房状态、病人的陪护状态\n\n## 陪护管理\n\n### 医嘱处理\n当前护士对分配到自己下面的患者，按照医生对病人开的药按时进行监护服用、换药、等操作、患者转病房\n### 看护记录\n护士看护的记录\n## 病房管理\n### 病房管理\n当前医院各类型病房的状态，病床的使用情况、病床的报修\n### 病房记录\n各个病房的使用记录\n## 系统设置\n该模块的内容只有系统管理员可以操作\n### 病房设置\n管理员设置病房信息，包含床位价格等\n### 处方设置\n管理员对处方药进行设置，包含药品类型、价格、等信息\n\n\n    \n    \n","slug":"design/Hospital","published":1,"updated":"2018-01-05T04:35:39.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbo800096doftbfg0ble","content":"<h2 id=\"工作台\"><a href=\"#工作台\" class=\"headerlink\" title=\"工作台\"></a>工作台</h2><p>主要针对不同人员登录进来后的待办事项进行规划</p>\n<p>可能会去掉患者自动注册的功能，主要考虑到该系统的使用人群是医院的工作人员，患者主动注册，使用的目标人群就不清晰了，功能点设计也就会变得很乱</p>\n<h2 id=\"人员管理\"><a href=\"#人员管理\" class=\"headerlink\" title=\"人员管理\"></a>人员管理</h2><p>该模块只有系统管理员可以操作</p>\n<h3 id=\"医生管理\"><a href=\"#医生管理\" class=\"headerlink\" title=\"医生管理\"></a>医生管理</h3><p>管理员对医生的信息进行维护</p>\n<h3 id=\"护士管理\"><a href=\"#护士管理\" class=\"headerlink\" title=\"护士管理\"></a>护士管理</h3><p>管理员对护士的信息进行维护</p>\n<h3 id=\"患者管理\"><a href=\"#患者管理\" class=\"headerlink\" title=\"患者管理\"></a>患者管理</h3><p>管理员对患者的信息进行维护</p>\n<h2 id=\"分诊\"><a href=\"#分诊\" class=\"headerlink\" title=\"分诊\"></a>分诊</h2><h3 id=\"医生门诊\"><a href=\"#医生门诊\" class=\"headerlink\" title=\"医生门诊\"></a>医生门诊</h3><p>医生进来后的工作区域，主要内容包含，对病人进行快速接诊，开处方药、分配陪护人员、分配病房、医嘱等功能</p>\n<h3 id=\"门诊记录\"><a href=\"#门诊记录\" class=\"headerlink\" title=\"门诊记录\"></a>门诊记录</h3><p>当前登录医生查看自己门诊的记录，包含病人的基本信息、所开的处方药、病人的康复状态、病人的病房状态、病人的陪护状态</p>\n<h2 id=\"陪护管理\"><a href=\"#陪护管理\" class=\"headerlink\" title=\"陪护管理\"></a>陪护管理</h2><h3 id=\"医嘱处理\"><a href=\"#医嘱处理\" class=\"headerlink\" title=\"医嘱处理\"></a>医嘱处理</h3><p>当前护士对分配到自己下面的患者，按照医生对病人开的药按时进行监护服用、换药、等操作、患者转病房</p>\n<h3 id=\"看护记录\"><a href=\"#看护记录\" class=\"headerlink\" title=\"看护记录\"></a>看护记录</h3><p>护士看护的记录</p>\n<h2 id=\"病房管理\"><a href=\"#病房管理\" class=\"headerlink\" title=\"病房管理\"></a>病房管理</h2><h3 id=\"病房管理-1\"><a href=\"#病房管理-1\" class=\"headerlink\" title=\"病房管理\"></a>病房管理</h3><p>当前医院各类型病房的状态，病床的使用情况、病床的报修</p>\n<h3 id=\"病房记录\"><a href=\"#病房记录\" class=\"headerlink\" title=\"病房记录\"></a>病房记录</h3><p>各个病房的使用记录</p>\n<h2 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h2><p>该模块的内容只有系统管理员可以操作</p>\n<h3 id=\"病房设置\"><a href=\"#病房设置\" class=\"headerlink\" title=\"病房设置\"></a>病房设置</h3><p>管理员设置病房信息，包含床位价格等</p>\n<h3 id=\"处方设置\"><a href=\"#处方设置\" class=\"headerlink\" title=\"处方设置\"></a>处方设置</h3><p>管理员对处方药进行设置，包含药品类型、价格、等信息</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工作台\"><a href=\"#工作台\" class=\"headerlink\" title=\"工作台\"></a>工作台</h2><p>主要针对不同人员登录进来后的待办事项进行规划</p>\n<p>可能会去掉患者自动注册的功能，主要考虑到该系统的使用人群是医院的工作人员，患者主动注册，使用的目标人群就不清晰了，功能点设计也就会变得很乱</p>\n<h2 id=\"人员管理\"><a href=\"#人员管理\" class=\"headerlink\" title=\"人员管理\"></a>人员管理</h2><p>该模块只有系统管理员可以操作</p>\n<h3 id=\"医生管理\"><a href=\"#医生管理\" class=\"headerlink\" title=\"医生管理\"></a>医生管理</h3><p>管理员对医生的信息进行维护</p>\n<h3 id=\"护士管理\"><a href=\"#护士管理\" class=\"headerlink\" title=\"护士管理\"></a>护士管理</h3><p>管理员对护士的信息进行维护</p>\n<h3 id=\"患者管理\"><a href=\"#患者管理\" class=\"headerlink\" title=\"患者管理\"></a>患者管理</h3><p>管理员对患者的信息进行维护</p>\n<h2 id=\"分诊\"><a href=\"#分诊\" class=\"headerlink\" title=\"分诊\"></a>分诊</h2><h3 id=\"医生门诊\"><a href=\"#医生门诊\" class=\"headerlink\" title=\"医生门诊\"></a>医生门诊</h3><p>医生进来后的工作区域，主要内容包含，对病人进行快速接诊，开处方药、分配陪护人员、分配病房、医嘱等功能</p>\n<h3 id=\"门诊记录\"><a href=\"#门诊记录\" class=\"headerlink\" title=\"门诊记录\"></a>门诊记录</h3><p>当前登录医生查看自己门诊的记录，包含病人的基本信息、所开的处方药、病人的康复状态、病人的病房状态、病人的陪护状态</p>\n<h2 id=\"陪护管理\"><a href=\"#陪护管理\" class=\"headerlink\" title=\"陪护管理\"></a>陪护管理</h2><h3 id=\"医嘱处理\"><a href=\"#医嘱处理\" class=\"headerlink\" title=\"医嘱处理\"></a>医嘱处理</h3><p>当前护士对分配到自己下面的患者，按照医生对病人开的药按时进行监护服用、换药、等操作、患者转病房</p>\n<h3 id=\"看护记录\"><a href=\"#看护记录\" class=\"headerlink\" title=\"看护记录\"></a>看护记录</h3><p>护士看护的记录</p>\n<h2 id=\"病房管理\"><a href=\"#病房管理\" class=\"headerlink\" title=\"病房管理\"></a>病房管理</h2><h3 id=\"病房管理-1\"><a href=\"#病房管理-1\" class=\"headerlink\" title=\"病房管理\"></a>病房管理</h3><p>当前医院各类型病房的状态，病床的使用情况、病床的报修</p>\n<h3 id=\"病房记录\"><a href=\"#病房记录\" class=\"headerlink\" title=\"病房记录\"></a>病房记录</h3><p>各个病房的使用记录</p>\n<h2 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h2><p>该模块的内容只有系统管理员可以操作</p>\n<h3 id=\"病房设置\"><a href=\"#病房设置\" class=\"headerlink\" title=\"病房设置\"></a>病房设置</h3><p>管理员设置病房信息，包含床位价格等</p>\n<h3 id=\"处方设置\"><a href=\"#处方设置\" class=\"headerlink\" title=\"处方设置\"></a>处方设置</h3><p>管理员对处方药进行设置，包含药品类型、价格、等信息</p>\n"},{"title":"linux一些好用的命令","date":"2017-12-20T02:34:22.000Z","description":"linux一些好用的命令","_content":"\n\n打印当前文件结构命令为：\n```bash\nfind . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'\n```\n","source":"_posts/linux/常用命令.md","raw":"---\ntitle: linux一些好用的命令\ndate: 2017-12-20 10:34:22\ncategories: Linux\ntags: [Linux]\ndescription: linux一些好用的命令\n---\n\n\n打印当前文件结构命令为：\n```bash\nfind . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'\n```\n","slug":"linux/常用命令","published":1,"updated":"2018-01-03T12:10:51.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbob000c6dofjd374o5a","content":"<p>打印当前文件结构命令为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -<span class=\"built_in\">print</span> | sed -e <span class=\"string\">'s;[^/]*/;|____;g;s;____|; |;g'</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>打印当前文件结构命令为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find . -<span class=\"built_in\">print</span> | sed -e <span class=\"string\">'s;[^/]*/;|____;g;s;____|; |;g'</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"病房管理系统技术简介","date":"2018-01-17T02:33:22.000Z","description":"病房管理系统技术简介","_content":"\n## 服务器端：\n\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。\n\n### 特点\n1. 创建独立的Spring应用程序\n2. 嵌入的Tomcat，无需部署WAR文件\n3. 简化Maven配置\n4. 自动配置Spring\n5. 提供生产就绪型功能，如指标，健康检查和外部配置\n6. 绝对没有代码生成和对XML没有要求配置\n","source":"_posts/design/Technical-introduction.md","raw":"---\ntitle: 病房管理系统技术简介\ndate: 2018-01-17 10:33:22\ncategories: design\ntags: [design]\ndescription: 病房管理系统技术简介\n---\n\n## 服务器端：\n\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。\n\n### 特点\n1. 创建独立的Spring应用程序\n2. 嵌入的Tomcat，无需部署WAR文件\n3. 简化Maven配置\n4. 自动配置Spring\n5. 提供生产就绪型功能，如指标，健康检查和外部配置\n6. 绝对没有代码生成和对XML没有要求配置\n","slug":"design/Technical-introduction","published":1,"updated":"2018-01-17T08:28:44.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgboc000d6dof1ajrucen","content":"<h2 id=\"服务器端：\"><a href=\"#服务器端：\" class=\"headerlink\" title=\"服务器端：\"></a>服务器端：</h2><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>创建独立的Spring应用程序</li>\n<li>嵌入的Tomcat，无需部署WAR文件</li>\n<li>简化Maven配置</li>\n<li>自动配置Spring</li>\n<li>提供生产就绪型功能，如指标，健康检查和外部配置</li>\n<li>绝对没有代码生成和对XML没有要求配置</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"服务器端：\"><a href=\"#服务器端：\" class=\"headerlink\" title=\"服务器端：\"></a>服务器端：</h2><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ol>\n<li>创建独立的Spring应用程序</li>\n<li>嵌入的Tomcat，无需部署WAR文件</li>\n<li>简化Maven配置</li>\n<li>自动配置Spring</li>\n<li>提供生产就绪型功能，如指标，健康检查和外部配置</li>\n<li>绝对没有代码生成和对XML没有要求配置</li>\n</ol>\n"},{"title":"深入equals方法","date":"2017-11-21T02:33:22.000Z","description":"在java编程或者面试中经常会遇到 == 、equals()的比较。自己看了看源码，结合自己的理解记录一下。","_content":"\n## equals\n先来看一下的默认实现：\n```java\n/** 默认同==，直接比较对象 */  \npublic boolean equals(Object obj) {  \n    return (this == obj);  \n}  \n```\n默认的equals方法，直接调用==，比较对象地址。String类中重写了equals方法，比较的是字符串值，看一下源码实现：\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\nString类中的equals首先比较地址，如果是同一个对象的引用，可知对象相等，返回true。\n\n若果不是同一个对象，equals方法挨个比较两个字符串对象内的字符，只有完全相等才返回true，否则返回false。\n\n## hashcode\n\nhashCode是根类Obeject中的方法。\n\n默认情况下，Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。\n\nString类源码中重写的hashCode方法如下:\n```java\npublic int hashCode() {\n    int h = hash;    //Default to 0 ### String类中的私有变量，\n    if (h == 0 && value.length > 0) {    //private final char value[]; ### Sting类中保存的字符串内容的的数组\n        char val[] = value;\n\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\nString源码中使用private final char value[];保存字符串内容，因此String是不可变的。\n\n## 总结\n\n### 绑定。\n当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n### 绑定原因。\nHashtable实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法。同(1)，必须保证equals相等的对象，hashCode 也相等。因为哈希表通过hashCode检索对象。\n### 默认\n    * ==默认比较对象在JVM中的地址。\n\n    * hashCode 默认返回对象在JVM中的存储地址。\n\n    * equal比较对象，默认也是比较对象在JVM中的地址，同==\n","source":"_posts/Java/basic/Java-equals-Research.md","raw":"---\ntitle: 深入equals方法\ndate: 2017-11-21 10:33:22\ncategories: Java\ntags: [Java]\ndescription: 在java编程或者面试中经常会遇到 == 、equals()的比较。自己看了看源码，结合自己的理解记录一下。\n---\n\n## equals\n先来看一下的默认实现：\n```java\n/** 默认同==，直接比较对象 */  \npublic boolean equals(Object obj) {  \n    return (this == obj);  \n}  \n```\n默认的equals方法，直接调用==，比较对象地址。String类中重写了equals方法，比较的是字符串值，看一下源码实现：\n```java\npublic boolean equals(Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\nString类中的equals首先比较地址，如果是同一个对象的引用，可知对象相等，返回true。\n\n若果不是同一个对象，equals方法挨个比较两个字符串对象内的字符，只有完全相等才返回true，否则返回false。\n\n## hashcode\n\nhashCode是根类Obeject中的方法。\n\n默认情况下，Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。\n\nString类源码中重写的hashCode方法如下:\n```java\npublic int hashCode() {\n    int h = hash;    //Default to 0 ### String类中的私有变量，\n    if (h == 0 && value.length > 0) {    //private final char value[]; ### Sting类中保存的字符串内容的的数组\n        char val[] = value;\n\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\nString源码中使用private final char value[];保存字符串内容，因此String是不可变的。\n\n## 总结\n\n### 绑定。\n当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n### 绑定原因。\nHashtable实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法。同(1)，必须保证equals相等的对象，hashCode 也相等。因为哈希表通过hashCode检索对象。\n### 默认\n    * ==默认比较对象在JVM中的地址。\n\n    * hashCode 默认返回对象在JVM中的存储地址。\n\n    * equal比较对象，默认也是比较对象在JVM中的地址，同==\n","slug":"Java/basic/Java-equals-Research","published":1,"updated":"2017-12-15T08:12:58.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqb00166dofhj4x9j8w","content":"<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h2><p>先来看一下的默认实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 默认同==，直接比较对象 */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认的equals方法，直接调用==，比较对象地址。String类中重写了equals方法，比较的是字符串值，看一下源码实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">            String anotherString = (String)anObject;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>String类中的equals首先比较地址，如果是同一个对象的引用，可知对象相等，返回true。</p>\n<p>若果不是同一个对象，equals方法挨个比较两个字符串对象内的字符，只有完全相等才返回true，否则返回false。</p>\n<h2 id=\"hashcode\"><a href=\"#hashcode\" class=\"headerlink\" title=\"hashcode\"></a>hashcode</h2><p>hashCode是根类Obeject中的方法。</p>\n<p>默认情况下，Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。</p>\n<p>String类源码中重写的hashCode方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash;    <span class=\"comment\">//Default to 0 ### String类中的私有变量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;    <span class=\"comment\">//private final char value[]; ### Sting类中保存的字符串内容的的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> val[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</span><br><span class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>String源码中使用private final char value[];保存字符串内容，因此String是不可变的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"绑定。\"><a href=\"#绑定。\" class=\"headerlink\" title=\"绑定。\"></a>绑定。</h3><p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>\n<h3 id=\"绑定原因。\"><a href=\"#绑定原因。\" class=\"headerlink\" title=\"绑定原因。\"></a>绑定原因。</h3><p>Hashtable实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法。同(1)，必须保证equals相等的对象，hashCode 也相等。因为哈希表通过hashCode检索对象。</p>\n<h3 id=\"默认\"><a href=\"#默认\" class=\"headerlink\" title=\"默认\"></a>默认</h3><pre><code>* ==默认比较对象在JVM中的地址。\n\n* hashCode 默认返回对象在JVM中的存储地址。\n\n* equal比较对象，默认也是比较对象在JVM中的地址，同==\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h2><p>先来看一下的默认实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 默认同==，直接比较对象 */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>默认的equals方法，直接调用==，比较对象地址。String类中重写了equals方法，比较的是字符串值，看一下源码实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">            String anotherString = (String)anObject;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    i++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>String类中的equals首先比较地址，如果是同一个对象的引用，可知对象相等，返回true。</p>\n<p>若果不是同一个对象，equals方法挨个比较两个字符串对象内的字符，只有完全相等才返回true，否则返回false。</p>\n<h2 id=\"hashcode\"><a href=\"#hashcode\" class=\"headerlink\" title=\"hashcode\"></a>hashcode</h2><p>hashCode是根类Obeject中的方法。</p>\n<p>默认情况下，Object中的hashCode() 返回对象的32位jvm内存地址。也就是说如果对象不重写该方法，则返回相应对象的32为JVM内存地址。</p>\n<p>String类源码中重写的hashCode方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash;    <span class=\"comment\">//Default to 0 ### String类中的私有变量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;    <span class=\"comment\">//private final char value[]; ### Sting类中保存的字符串内容的的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> val[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</span><br><span class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>String源码中使用private final char value[];保存字符串内容，因此String是不可变的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"绑定。\"><a href=\"#绑定。\" class=\"headerlink\" title=\"绑定。\"></a>绑定。</h3><p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>\n<h3 id=\"绑定原因。\"><a href=\"#绑定原因。\" class=\"headerlink\" title=\"绑定原因。\"></a>绑定原因。</h3><p>Hashtable实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法。同(1)，必须保证equals相等的对象，hashCode 也相等。因为哈希表通过hashCode检索对象。</p>\n<h3 id=\"默认\"><a href=\"#默认\" class=\"headerlink\" title=\"默认\"></a>默认</h3><pre><code>* ==默认比较对象在JVM中的地址。\n\n* hashCode 默认返回对象在JVM中的存储地址。\n\n* equal比较对象，默认也是比较对象在JVM中的地址，同==\n</code></pre>"},{"title":"Java中String创建原理深入分析","date":"2017-11-21T02:33:22.000Z","description":"Java中String创建原理深入分析","_content":"### 基本概念\n1、  使用new关键字 \nString s1 = new String(“ab”);  //\n2、  使用字符串常量直接赋值\nString s2 = “abc”;\n3、  使用”+”运算符进行字符串连接\nString s3 = “abc” + “d”;\nString s4 = s3 + 5;  //abcd5\n**常量池概念：**\nJava运行时会维护一个String Pool（String池）， 也叫“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。\n\n### 原理\n* 原理1：当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个s在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。\n* 原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。\n* 原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。\n* 原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。最后指向堆内存中的对象\n\n### 栗子\n```java\npublic class StringTest {\n    publicstaticvoid main(String args[]) {\n       // 在池中和堆中分别创建String对象\"abc\",s1指向堆中对象\n       String s1 = new String(\"abc\");\n       // s2直接指向池中对象\"abc\"\n       String s2 = \"abc\";\n       // 在堆中新创建\"abc\"对象，s3指向该对象\n       String s3 = new String(\"abc\");\n       // 在池中创建对象\"ab\"  和 \"c\"，并且s4指向池中对象\"abc\"\n       String s4 = \"ab\" + \"c\";\n       // c指向池中对象\"c\"\n       String c = \"c\";\n       // 在堆中创建新的对象\"abc\"，并且s5指向该对象\n       String s5 = \"ab\" + c;\n \n       System.out.println(\"------------实串-----------\");\n       System.out.println(s1 == s2); // false\n       System.out.println(s1 == s3); // false\n       System.out.println(s2 == s3); // false\n       System.out.println(s2 == s4); // true\n       System.out.println(s2 == s5); // false\n    }\n}\n```","source":"_posts/Java/basic/Java-String-Research.md","raw":"---\ntitle: Java中String创建原理深入分析\ndate: 2017-11-21 10:33:22\ncategories: Java\ntags: [Java]\ndescription: Java中String创建原理深入分析\n---\n### 基本概念\n1、  使用new关键字 \nString s1 = new String(“ab”);  //\n2、  使用字符串常量直接赋值\nString s2 = “abc”;\n3、  使用”+”运算符进行字符串连接\nString s3 = “abc” + “d”;\nString s4 = s3 + 5;  //abcd5\n**常量池概念：**\nJava运行时会维护一个String Pool（String池）， 也叫“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。\n\n### 原理\n* 原理1：当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个s在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。\n* 原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。\n* 原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。\n* 原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。最后指向堆内存中的对象\n\n### 栗子\n```java\npublic class StringTest {\n    publicstaticvoid main(String args[]) {\n       // 在池中和堆中分别创建String对象\"abc\",s1指向堆中对象\n       String s1 = new String(\"abc\");\n       // s2直接指向池中对象\"abc\"\n       String s2 = \"abc\";\n       // 在堆中新创建\"abc\"对象，s3指向该对象\n       String s3 = new String(\"abc\");\n       // 在池中创建对象\"ab\"  和 \"c\"，并且s4指向池中对象\"abc\"\n       String s4 = \"ab\" + \"c\";\n       // c指向池中对象\"c\"\n       String c = \"c\";\n       // 在堆中创建新的对象\"abc\"，并且s5指向该对象\n       String s5 = \"ab\" + c;\n \n       System.out.println(\"------------实串-----------\");\n       System.out.println(s1 == s2); // false\n       System.out.println(s1 == s3); // false\n       System.out.println(s2 == s3); // false\n       System.out.println(s2 == s4); // true\n       System.out.println(s2 == s5); // false\n    }\n}\n```","slug":"Java/basic/Java-String-Research","published":1,"updated":"2017-12-15T08:12:58.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqc00176dofunkmdj81","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1、  使用new关键字<br>String s1 = new String(“ab”);  //<br>2、  使用字符串常量直接赋值<br>String s2 = “abc”;<br>3、  使用”+”运算符进行字符串连接<br>String s3 = “abc” + “d”;<br>String s4 = s3 + 5;  //abcd5<br><strong>常量池概念：</strong><br>Java运行时会维护一个String Pool（String池）， 也叫“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>原理1：当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个s在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。</li>\n<li>原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。</li>\n<li>原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。</li>\n<li>原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。最后指向堆内存中的对象</li>\n</ul>\n<h3 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">publicstaticvoid <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 在池中和堆中分别创建String对象\"abc\",s1指向堆中对象</span></span><br><span class=\"line\">       String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// s2直接指向池中对象\"abc\"</span></span><br><span class=\"line\">       String s2 = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 在堆中新创建\"abc\"对象，s3指向该对象</span></span><br><span class=\"line\">       String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 在池中创建对象\"ab\"  和 \"c\"，并且s4指向池中对象\"abc\"</span></span><br><span class=\"line\">       String s4 = <span class=\"string\">\"ab\"</span> + <span class=\"string\">\"c\"</span>;</span><br><span class=\"line\">       <span class=\"comment\">// c指向池中对象\"c\"</span></span><br><span class=\"line\">       String c = <span class=\"string\">\"c\"</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 在堆中创建新的对象\"abc\"，并且s5指向该对象</span></span><br><span class=\"line\">       String s5 = <span class=\"string\">\"ab\"</span> + c;</span><br><span class=\"line\"> </span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"------------实串-----------\"</span>);</span><br><span class=\"line\">       System.out.println(s1 == s2); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s1 == s3); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s2 == s3); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s2 == s4); <span class=\"comment\">// true</span></span><br><span class=\"line\">       System.out.println(s2 == s5); <span class=\"comment\">// false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1、  使用new关键字<br>String s1 = new String(“ab”);  //<br>2、  使用字符串常量直接赋值<br>String s2 = “abc”;<br>3、  使用”+”运算符进行字符串连接<br>String s3 = “abc” + “d”;<br>String s4 = s3 + 5;  //abcd5<br><strong>常量池概念：</strong><br>Java运行时会维护一个String Pool（String池）， 也叫“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li>原理1：当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个s在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。</li>\n<li>原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。</li>\n<li>原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。</li>\n<li>原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。最后指向堆内存中的对象</li>\n</ul>\n<h3 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">publicstaticvoid <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 在池中和堆中分别创建String对象\"abc\",s1指向堆中对象</span></span><br><span class=\"line\">       String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// s2直接指向池中对象\"abc\"</span></span><br><span class=\"line\">       String s2 = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 在堆中新创建\"abc\"对象，s3指向该对象</span></span><br><span class=\"line\">       String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 在池中创建对象\"ab\"  和 \"c\"，并且s4指向池中对象\"abc\"</span></span><br><span class=\"line\">       String s4 = <span class=\"string\">\"ab\"</span> + <span class=\"string\">\"c\"</span>;</span><br><span class=\"line\">       <span class=\"comment\">// c指向池中对象\"c\"</span></span><br><span class=\"line\">       String c = <span class=\"string\">\"c\"</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 在堆中创建新的对象\"abc\"，并且s5指向该对象</span></span><br><span class=\"line\">       String s5 = <span class=\"string\">\"ab\"</span> + c;</span><br><span class=\"line\"> </span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"------------实串-----------\"</span>);</span><br><span class=\"line\">       System.out.println(s1 == s2); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s1 == s3); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s2 == s3); <span class=\"comment\">// false</span></span><br><span class=\"line\">       System.out.println(s2 == s4); <span class=\"comment\">// true</span></span><br><span class=\"line\">       System.out.println(s2 == s5); <span class=\"comment\">// false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"HashMap深度解析","date":"2017-11-21T02:33:22.000Z","description":"HashMap可以说是Java中最常用的集合类框架之一，是Java语言中非常典型的数据结构，我们总会在不经意间用到它，很大程度上方便了我们日常开发。那么，HashMap和HashTable有什么区别？HashMap为什么是线程不安全的？HashMap还有哪些不为人知的特点？","_content":"\n## HashMap认知\n了解HashMap之前，我们先看看Object类的两个方法hashCode和equals。\n\n详情参考 [深入equals方法](http://blog.bigspray.top/2017/11/21/Java/basic/%E6%B7%B1%E5%85%A5equals%E6%96%B9%E6%B3%95/)\n\n众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。\n\nHashMap数组每一个元素的初始值都是Null。\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/640.webp)\n\n对于HashMap，我们最常使用的是两个方法：Get 和 Put。\n\n### Put方法的原理\n调用Put方法的时候发生了什么呢？\n\n比如调用 hashMap.put(\"apple\", 0) ，插入一个Key为“apple\"的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：\n**index =  Hash（“apple”）**\n\n假定最后计算出的index是2，那么结果如下：\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/641.webp)\n\n但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。比如下面这样：\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/642.webp)\n\n这时候该怎么办呢？我们可以利用链表来解决。\n\nHashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/644.webp)\n\n需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。\n\n### Get方法的原理\n\n\n使用Get方法根据Key来查找Value的时候，发生了什么呢？\n\n首先会把输入的Key做一次Hash映射，得到对应的index：\n\nindex =  Hash（“apple”）\n\n由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/645.webp)\n\n第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。\n\n第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。\n\n之所以把Entry6放在头节点，是因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。\n\n\n## HashMap初始长度问题\n\n来看看HashMap默认初始长度是多少？为什么这么规定？\n\n首先第一个问题，我们可以在源码中找到答案：\n```java\n/**\n    * The default initial capacity - MUST be a power of two.\n    */\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n```\n在初始化给出的初始长度是16，并且规定了每次扩展或者手动初始化时，长度必须是2的幂\n\n而为什么这么做在查阅了一些资料后，整理出原因如下：\n\n为了实现高效率的hash运算，HashMap采用了位运算的方式。公式（Length是HashMap的长度）如下：\n\n**index =  HashCode（Key） &  （Length - 1）**\n\n长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。\n\n## HashMap线程不安全(hash碰撞与扩容导致)\n### hash碰撞\n\n如上面所说，HashMap底层是一个Entry数组，一旦发生Hash冲突的的时候，HashMap采用拉链法解决碰撞冲突，而，Entry内部使用的是链表。\n\n如果多个线程，在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，这个时候需要解决碰撞冲突，最终的结果可想而知，两个数据中势必会有一个会丢失\n\n看看put()方法\n```java\npublic V put(K key, V value) {  \n    // 处理key为null，HashMap允许key和value为null  \n    if (key == null)  \n        return putForNullKey(value);  \n    // 得到key的哈希码  \n    int hash = hash(key);  \n    // 通过哈希码计算出bucketIndex  \n    int i = indexFor(hash, table.length);  \n    // 取出bucketIndex位置上的元素，并循环单链表，判断key是否已存在  \n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // 哈希码相同并且对象相同时  \n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  \n            // 新值替换旧值，并返回旧值  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n            return oldValue;  \n        }  \n    }  \n  \n    // key不存在时，加入新元素  \n    modCount++;  \n    addEntry(hash, key, value, i);  \n    return null;  \n}  \n```\nput方法不是同步的，同时调用了addEntry方法：\n```java\nvoid addEntry(int i, Object obj, Object obj1, int j)\n    {\n        if(size >= threshold && null != table[j])\n        {\n            resize(2 * table.length);\n            i = null == obj ? 0 : hash(obj);\n            j = indexFor(i, table.length);\n        }\n        createEntry(i, obj, obj1, j);\n    }\n```\naddEntry方法依然不是同步的，所以导致了线程不安全问题\n\n### 扩容\nHashMap存在扩容的情况，对应的方法为HashMap中的resize方法：\n```java\nvoid resize(int i)\n    {\n        Entry aentry[] = table;\n        int j = aentry.length;\n        if(j == 1073741824)\n        {\n            threshold = 2147483647;\n            return;\n        } else\n        {\n            Entry aentry1[] = new Entry[i];\n            transfer(aentry1, initHashSeedAsNeeded(i));\n            table = aentry1;\n            threshold = (int)Math.min((float)i * loadFactor, 1.073742E+009F);\n            return;\n        }\n    }\n```\n可以看到扩容方法也不是同步的，通过代码我们知道在扩容过程中，会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。\n\n当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。\n\n### 多线程下使用HashMap\n多线程下使用HashMap，几种方案：\n\n* 在外部包装HashMap，实现同步机制\n* 使用Map m = Collections.synchronizedMap(new HashMap(...));，这里就是对HashMap做了一次包装\n* 使用java.util.HashTable，效率最低\n* 使用java.util.concurrent.ConcurrentHashMap，相对安全，效率较高\n\n## HashMap和HashTable\n\n### HashMap和Hashtable的区别\nHashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。\n\n* HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。\n* HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。\n* 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。\n* 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。\n* HashMap不能保证随着时间的推移Map中的元素次序是不变的。\n\n\n参考资料：\n[HashMap为什么线程不安全](http://blog.csdn.net/a_lele123/article/details/47660869)\n[HashMap深度解析(一)](http://blog.csdn.net/ghsau/article/details/16843543/)\n[HashMap深度解析(二)](http://blog.csdn.net/ghsau/article/details/16890151)\n[HashMap和Hashtable的区别](http://www.importnew.com/7010.html)\n\n","source":"_posts/Java/basic/HashMap-intro.md","raw":"---\ntitle: HashMap深度解析\ndate: 2017-11-21 10:33:22\ncategories: Java\ntags: [Java]\ndescription: HashMap可以说是Java中最常用的集合类框架之一，是Java语言中非常典型的数据结构，我们总会在不经意间用到它，很大程度上方便了我们日常开发。那么，HashMap和HashTable有什么区别？HashMap为什么是线程不安全的？HashMap还有哪些不为人知的特点？\n---\n\n## HashMap认知\n了解HashMap之前，我们先看看Object类的两个方法hashCode和equals。\n\n详情参考 [深入equals方法](http://blog.bigspray.top/2017/11/21/Java/basic/%E6%B7%B1%E5%85%A5equals%E6%96%B9%E6%B3%95/)\n\n众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。\n\nHashMap数组每一个元素的初始值都是Null。\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/640.webp)\n\n对于HashMap，我们最常使用的是两个方法：Get 和 Put。\n\n### Put方法的原理\n调用Put方法的时候发生了什么呢？\n\n比如调用 hashMap.put(\"apple\", 0) ，插入一个Key为“apple\"的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：\n**index =  Hash（“apple”）**\n\n假定最后计算出的index是2，那么结果如下：\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/641.webp)\n\n但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。比如下面这样：\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/642.webp)\n\n这时候该怎么办呢？我们可以利用链表来解决。\n\nHashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：\n\n![avatar](http://ozqzyzixv.bkt.clouddn.com/644.webp)\n\n需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。\n\n### Get方法的原理\n\n\n使用Get方法根据Key来查找Value的时候，发生了什么呢？\n\n首先会把输入的Key做一次Hash映射，得到对应的index：\n\nindex =  Hash（“apple”）\n\n由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/645.webp)\n\n第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。\n\n第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。\n\n之所以把Entry6放在头节点，是因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。\n\n\n## HashMap初始长度问题\n\n来看看HashMap默认初始长度是多少？为什么这么规定？\n\n首先第一个问题，我们可以在源码中找到答案：\n```java\n/**\n    * The default initial capacity - MUST be a power of two.\n    */\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n```\n在初始化给出的初始长度是16，并且规定了每次扩展或者手动初始化时，长度必须是2的幂\n\n而为什么这么做在查阅了一些资料后，整理出原因如下：\n\n为了实现高效率的hash运算，HashMap采用了位运算的方式。公式（Length是HashMap的长度）如下：\n\n**index =  HashCode（Key） &  （Length - 1）**\n\n长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。\n\n## HashMap线程不安全(hash碰撞与扩容导致)\n### hash碰撞\n\n如上面所说，HashMap底层是一个Entry数组，一旦发生Hash冲突的的时候，HashMap采用拉链法解决碰撞冲突，而，Entry内部使用的是链表。\n\n如果多个线程，在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，这个时候需要解决碰撞冲突，最终的结果可想而知，两个数据中势必会有一个会丢失\n\n看看put()方法\n```java\npublic V put(K key, V value) {  \n    // 处理key为null，HashMap允许key和value为null  \n    if (key == null)  \n        return putForNullKey(value);  \n    // 得到key的哈希码  \n    int hash = hash(key);  \n    // 通过哈希码计算出bucketIndex  \n    int i = indexFor(hash, table.length);  \n    // 取出bucketIndex位置上的元素，并循环单链表，判断key是否已存在  \n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // 哈希码相同并且对象相同时  \n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  \n            // 新值替换旧值，并返回旧值  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n            return oldValue;  \n        }  \n    }  \n  \n    // key不存在时，加入新元素  \n    modCount++;  \n    addEntry(hash, key, value, i);  \n    return null;  \n}  \n```\nput方法不是同步的，同时调用了addEntry方法：\n```java\nvoid addEntry(int i, Object obj, Object obj1, int j)\n    {\n        if(size >= threshold && null != table[j])\n        {\n            resize(2 * table.length);\n            i = null == obj ? 0 : hash(obj);\n            j = indexFor(i, table.length);\n        }\n        createEntry(i, obj, obj1, j);\n    }\n```\naddEntry方法依然不是同步的，所以导致了线程不安全问题\n\n### 扩容\nHashMap存在扩容的情况，对应的方法为HashMap中的resize方法：\n```java\nvoid resize(int i)\n    {\n        Entry aentry[] = table;\n        int j = aentry.length;\n        if(j == 1073741824)\n        {\n            threshold = 2147483647;\n            return;\n        } else\n        {\n            Entry aentry1[] = new Entry[i];\n            transfer(aentry1, initHashSeedAsNeeded(i));\n            table = aentry1;\n            threshold = (int)Math.min((float)i * loadFactor, 1.073742E+009F);\n            return;\n        }\n    }\n```\n可以看到扩容方法也不是同步的，通过代码我们知道在扩容过程中，会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。\n\n当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。\n\n### 多线程下使用HashMap\n多线程下使用HashMap，几种方案：\n\n* 在外部包装HashMap，实现同步机制\n* 使用Map m = Collections.synchronizedMap(new HashMap(...));，这里就是对HashMap做了一次包装\n* 使用java.util.HashTable，效率最低\n* 使用java.util.concurrent.ConcurrentHashMap，相对安全，效率较高\n\n## HashMap和HashTable\n\n### HashMap和Hashtable的区别\nHashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。\n\n* HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。\n* HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。\n* 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。\n* 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。\n* HashMap不能保证随着时间的推移Map中的元素次序是不变的。\n\n\n参考资料：\n[HashMap为什么线程不安全](http://blog.csdn.net/a_lele123/article/details/47660869)\n[HashMap深度解析(一)](http://blog.csdn.net/ghsau/article/details/16843543/)\n[HashMap深度解析(二)](http://blog.csdn.net/ghsau/article/details/16890151)\n[HashMap和Hashtable的区别](http://www.importnew.com/7010.html)\n\n","slug":"Java/basic/HashMap-intro","published":1,"updated":"2017-12-15T08:12:58.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqd001a6doffzwf5tw9","content":"<h2 id=\"HashMap认知\"><a href=\"#HashMap认知\" class=\"headerlink\" title=\"HashMap认知\"></a>HashMap认知</h2><p>了解HashMap之前，我们先看看Object类的两个方法hashCode和equals。</p>\n<p>详情参考 <a href=\"http://blog.bigspray.top/2017/11/21/Java/basic/%E6%B7%B1%E5%85%A5equals%E6%96%B9%E6%B3%95/\">深入equals方法</a></p>\n<p>众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p>\n<p>HashMap数组每一个元素的初始值都是Null。</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/640.webp\" alt=\"avatar\"></p>\n<p>对于HashMap，我们最常使用的是两个方法：Get 和 Put。</p>\n<h3 id=\"Put方法的原理\"><a href=\"#Put方法的原理\" class=\"headerlink\" title=\"Put方法的原理\"></a>Put方法的原理</h3><p>调用Put方法的时候发生了什么呢？</p>\n<p>比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：<br><strong>index =  Hash（“apple”）</strong></p>\n<p>假定最后计算出的index是2，那么结果如下：</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/641.webp\" alt=\"avatar\"></p>\n<p>但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。比如下面这样：</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/642.webp\" alt=\"avatar\"></p>\n<p>这时候该怎么办呢？我们可以利用链表来解决。</p>\n<p>HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/644.webp\" alt=\"avatar\"></p>\n<p>需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。</p>\n<h3 id=\"Get方法的原理\"><a href=\"#Get方法的原理\" class=\"headerlink\" title=\"Get方法的原理\"></a>Get方法的原理</h3><p>使用Get方法根据Key来查找Value的时候，发生了什么呢？</p>\n<p>首先会把输入的Key做一次Hash映射，得到对应的index：</p>\n<p>index =  Hash（“apple”）</p>\n<p>由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/645.webp\" alt=\"avatar\"></p>\n<p>第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。</p>\n<p>第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。</p>\n<p>之所以把Entry6放在头节点，是因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。</p>\n<h2 id=\"HashMap初始长度问题\"><a href=\"#HashMap初始长度问题\" class=\"headerlink\" title=\"HashMap初始长度问题\"></a>HashMap初始长度问题</h2><p>来看看HashMap默认初始长度是多少？为什么这么规定？</p>\n<p>首先第一个问题，我们可以在源码中找到答案：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * The default initial capacity - MUST be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16</span></span><br></pre></td></tr></table></figure></p>\n<p>在初始化给出的初始长度是16，并且规定了每次扩展或者手动初始化时，长度必须是2的幂</p>\n<p>而为什么这么做在查阅了一些资料后，整理出原因如下：</p>\n<p>为了实现高效率的hash运算，HashMap采用了位运算的方式。公式（Length是HashMap的长度）如下：</p>\n<p><strong>index =  HashCode（Key） &amp;  （Length - 1）</strong></p>\n<p>长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>\n<h2 id=\"HashMap线程不安全-hash碰撞与扩容导致\"><a href=\"#HashMap线程不安全-hash碰撞与扩容导致\" class=\"headerlink\" title=\"HashMap线程不安全(hash碰撞与扩容导致)\"></a>HashMap线程不安全(hash碰撞与扩容导致)</h2><h3 id=\"hash碰撞\"><a href=\"#hash碰撞\" class=\"headerlink\" title=\"hash碰撞\"></a>hash碰撞</h3><p>如上面所说，HashMap底层是一个Entry数组，一旦发生Hash冲突的的时候，HashMap采用拉链法解决碰撞冲突，而，Entry内部使用的是链表。</p>\n<p>如果多个线程，在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，这个时候需要解决碰撞冲突，最终的结果可想而知，两个数据中势必会有一个会丢失</p>\n<p>看看put()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 处理key为null，HashMap允许key和value为null  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);  </span><br><span class=\"line\">    <span class=\"comment\">// 得到key的哈希码  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);  </span><br><span class=\"line\">    <span class=\"comment\">// 通过哈希码计算出bucketIndex  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);  </span><br><span class=\"line\">    <span class=\"comment\">// 取出bucketIndex位置上的元素，并循环单链表，判断key是否已存在  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">// 哈希码相同并且对象相同时  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 新值替换旧值，并返回旧值  </span></span><br><span class=\"line\">            V oldValue = e.value;  </span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// key不存在时，加入新元素  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    addEntry(hash, key, value, i);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>put方法不是同步的，同时调用了addEntry方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Object obj, Object obj1, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size &gt;= threshold &amp;&amp; <span class=\"keyword\">null</span> != table[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">            i = <span class=\"keyword\">null</span> == obj ? <span class=\"number\">0</span> : hash(obj);</span><br><span class=\"line\">            j = indexFor(i, table.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        createEntry(i, obj, obj1, j);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>addEntry方法依然不是同步的，所以导致了线程不安全问题</p>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><p>HashMap存在扩容的情况，对应的方法为HashMap中的resize方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Entry aentry[] = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = aentry.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">1073741824</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            threshold = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Entry aentry1[] = <span class=\"keyword\">new</span> Entry[i];</span><br><span class=\"line\">            transfer(aentry1, initHashSeedAsNeeded(i));</span><br><span class=\"line\">            table = aentry1;</span><br><span class=\"line\">            threshold = (<span class=\"keyword\">int</span>)Math.min((<span class=\"keyword\">float</span>)i * loadFactor, <span class=\"number\">1.073742E+009F</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到扩容方法也不是同步的，通过代码我们知道在扩容过程中，会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。</p>\n<p>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p>\n<h3 id=\"多线程下使用HashMap\"><a href=\"#多线程下使用HashMap\" class=\"headerlink\" title=\"多线程下使用HashMap\"></a>多线程下使用HashMap</h3><p>多线程下使用HashMap，几种方案：</p>\n<ul>\n<li>在外部包装HashMap，实现同步机制</li>\n<li>使用Map m = Collections.synchronizedMap(new HashMap(…));，这里就是对HashMap做了一次包装</li>\n<li>使用java.util.HashTable，效率最低</li>\n<li>使用java.util.concurrent.ConcurrentHashMap，相对安全，效率较高</li>\n</ul>\n<h2 id=\"HashMap和HashTable\"><a href=\"#HashMap和HashTable\" class=\"headerlink\" title=\"HashMap和HashTable\"></a>HashMap和HashTable</h2><h3 id=\"HashMap和Hashtable的区别\"><a href=\"#HashMap和Hashtable的区别\" class=\"headerlink\" title=\"HashMap和Hashtable的区别\"></a>HashMap和Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>\n<ul>\n<li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li>\n<li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li>\n<li>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>\n<li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>\n<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li>\n</ul>\n<p>参考资料：<br><a href=\"http://blog.csdn.net/a_lele123/article/details/47660869\" target=\"_blank\" rel=\"noopener\">HashMap为什么线程不安全</a><br><a href=\"http://blog.csdn.net/ghsau/article/details/16843543/\" target=\"_blank\" rel=\"noopener\">HashMap深度解析(一)</a><br><a href=\"http://blog.csdn.net/ghsau/article/details/16890151\" target=\"_blank\" rel=\"noopener\">HashMap深度解析(二)</a><br><a href=\"http://www.importnew.com/7010.html\" target=\"_blank\" rel=\"noopener\">HashMap和Hashtable的区别</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HashMap认知\"><a href=\"#HashMap认知\" class=\"headerlink\" title=\"HashMap认知\"></a>HashMap认知</h2><p>了解HashMap之前，我们先看看Object类的两个方法hashCode和equals。</p>\n<p>详情参考 <a href=\"http://blog.bigspray.top/2017/11/21/Java/basic/%E6%B7%B1%E5%85%A5equals%E6%96%B9%E6%B3%95/\">深入equals方法</a></p>\n<p>众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做Entry。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p>\n<p>HashMap数组每一个元素的初始值都是Null。</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/640.webp\" alt=\"avatar\"></p>\n<p>对于HashMap，我们最常使用的是两个方法：Get 和 Put。</p>\n<h3 id=\"Put方法的原理\"><a href=\"#Put方法的原理\" class=\"headerlink\" title=\"Put方法的原理\"></a>Put方法的原理</h3><p>调用Put方法的时候发生了什么呢？</p>\n<p>比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：<br><strong>index =  Hash（“apple”）</strong></p>\n<p>假定最后计算出的index是2，那么结果如下：</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/641.webp\" alt=\"avatar\"></p>\n<p>但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。比如下面这样：</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/642.webp\" alt=\"avatar\"></p>\n<p>这时候该怎么办呢？我们可以利用链表来解决。</p>\n<p>HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/644.webp\" alt=\"avatar\"></p>\n<p>需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。</p>\n<h3 id=\"Get方法的原理\"><a href=\"#Get方法的原理\" class=\"headerlink\" title=\"Get方法的原理\"></a>Get方法的原理</h3><p>使用Get方法根据Key来查找Value的时候，发生了什么呢？</p>\n<p>首先会把输入的Key做一次Hash映射，得到对应的index：</p>\n<p>index =  Hash（“apple”）</p>\n<p>由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/645.webp\" alt=\"avatar\"></p>\n<p>第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。</p>\n<p>第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。</p>\n<p>之所以把Entry6放在头节点，是因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。</p>\n<h2 id=\"HashMap初始长度问题\"><a href=\"#HashMap初始长度问题\" class=\"headerlink\" title=\"HashMap初始长度问题\"></a>HashMap初始长度问题</h2><p>来看看HashMap默认初始长度是多少？为什么这么规定？</p>\n<p>首先第一个问题，我们可以在源码中找到答案：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * The default initial capacity - MUST be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16</span></span><br></pre></td></tr></table></figure></p>\n<p>在初始化给出的初始长度是16，并且规定了每次扩展或者手动初始化时，长度必须是2的幂</p>\n<p>而为什么这么做在查阅了一些资料后，整理出原因如下：</p>\n<p>为了实现高效率的hash运算，HashMap采用了位运算的方式。公式（Length是HashMap的长度）如下：</p>\n<p><strong>index =  HashCode（Key） &amp;  （Length - 1）</strong></p>\n<p>长度16或者其他2的幂，Length-1的值是所有二进制位全为1，这种情况下，index的结果等同于HashCode后几位的值。只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。</p>\n<h2 id=\"HashMap线程不安全-hash碰撞与扩容导致\"><a href=\"#HashMap线程不安全-hash碰撞与扩容导致\" class=\"headerlink\" title=\"HashMap线程不安全(hash碰撞与扩容导致)\"></a>HashMap线程不安全(hash碰撞与扩容导致)</h2><h3 id=\"hash碰撞\"><a href=\"#hash碰撞\" class=\"headerlink\" title=\"hash碰撞\"></a>hash碰撞</h3><p>如上面所说，HashMap底层是一个Entry数组，一旦发生Hash冲突的的时候，HashMap采用拉链法解决碰撞冲突，而，Entry内部使用的是链表。</p>\n<p>如果多个线程，在某一时刻同时操作HashMap并执行put操作，而有大于两个key的hash值相同，这个时候需要解决碰撞冲突，最终的结果可想而知，两个数据中势必会有一个会丢失</p>\n<p>看看put()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 处理key为null，HashMap允许key和value为null  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);  </span><br><span class=\"line\">    <span class=\"comment\">// 得到key的哈希码  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);  </span><br><span class=\"line\">    <span class=\"comment\">// 通过哈希码计算出bucketIndex  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);  </span><br><span class=\"line\">    <span class=\"comment\">// 取出bucketIndex位置上的元素，并循环单链表，判断key是否已存在  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">// 哈希码相同并且对象相同时  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 新值替换旧值，并返回旧值  </span></span><br><span class=\"line\">            V oldValue = e.value;  </span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// key不存在时，加入新元素  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    addEntry(hash, key, value, i);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>put方法不是同步的，同时调用了addEntry方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> i, Object obj, Object obj1, <span class=\"keyword\">int</span> j)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size &gt;= threshold &amp;&amp; <span class=\"keyword\">null</span> != table[j])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">            i = <span class=\"keyword\">null</span> == obj ? <span class=\"number\">0</span> : hash(obj);</span><br><span class=\"line\">            j = indexFor(i, table.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        createEntry(i, obj, obj1, j);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>addEntry方法依然不是同步的，所以导致了线程不安全问题</p>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><p>HashMap存在扩容的情况，对应的方法为HashMap中的resize方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Entry aentry[] = table;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = aentry.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">1073741824</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            threshold = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Entry aentry1[] = <span class=\"keyword\">new</span> Entry[i];</span><br><span class=\"line\">            transfer(aentry1, initHashSeedAsNeeded(i));</span><br><span class=\"line\">            table = aentry1;</span><br><span class=\"line\">            threshold = (<span class=\"keyword\">int</span>)Math.min((<span class=\"keyword\">float</span>)i * loadFactor, <span class=\"number\">1.073742E+009F</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到扩容方法也不是同步的，通过代码我们知道在扩容过程中，会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。</p>\n<p>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p>\n<h3 id=\"多线程下使用HashMap\"><a href=\"#多线程下使用HashMap\" class=\"headerlink\" title=\"多线程下使用HashMap\"></a>多线程下使用HashMap</h3><p>多线程下使用HashMap，几种方案：</p>\n<ul>\n<li>在外部包装HashMap，实现同步机制</li>\n<li>使用Map m = Collections.synchronizedMap(new HashMap(…));，这里就是对HashMap做了一次包装</li>\n<li>使用java.util.HashTable，效率最低</li>\n<li>使用java.util.concurrent.ConcurrentHashMap，相对安全，效率较高</li>\n</ul>\n<h2 id=\"HashMap和HashTable\"><a href=\"#HashMap和HashTable\" class=\"headerlink\" title=\"HashMap和HashTable\"></a>HashMap和HashTable</h2><h3 id=\"HashMap和Hashtable的区别\"><a href=\"#HashMap和Hashtable的区别\" class=\"headerlink\" title=\"HashMap和Hashtable的区别\"></a>HashMap和Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>\n<ul>\n<li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li>\n<li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li>\n<li>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>\n<li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>\n<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li>\n</ul>\n<p>参考资料：<br><a href=\"http://blog.csdn.net/a_lele123/article/details/47660869\" target=\"_blank\" rel=\"noopener\">HashMap为什么线程不安全</a><br><a href=\"http://blog.csdn.net/ghsau/article/details/16843543/\" target=\"_blank\" rel=\"noopener\">HashMap深度解析(一)</a><br><a href=\"http://blog.csdn.net/ghsau/article/details/16890151\" target=\"_blank\" rel=\"noopener\">HashMap深度解析(二)</a><br><a href=\"http://www.importnew.com/7010.html\" target=\"_blank\" rel=\"noopener\">HashMap和Hashtable的区别</a></p>\n"},{"title":"TimerTask","date":"2017-11-27T02:33:22.000Z","description":"目前的 Web 应用，多数应用都具备任务调度的功能。本系列大致介绍了几种任务调度的 Java 实现方法，包括 Timer,Scheduler, Quartz 以及 JCron Tab，并对其优缺点进行比较","_content":"\n## TimerTask\n### 简单使用\nTimerTask 是最简单的任务调度方式之一\n```java\n public class TimerTaskTest extends TimerTask {\n    private String jobName = \"\";\n\n    public TimerTaskTest(String jobName) {\n        super();\n        this.jobName = jobName;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"execute \" + jobName);\n    }\n\n}\n```\n调用执行任务\n```java\npublic class MainExecute {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        long delay1 = 1 * 1000;\n        long period1 = 1000;\n        // 从现在开始 1 秒钟之后，每隔 1 秒钟执行一次 job1\n        timer.schedule(new TimerTaskTest(\"job1\"), delay1, period1);\n        long delay2 = 2 * 1000;\n        long period2 = 2000;\n        // 从现在开始 2 秒钟之后，每隔 2 秒钟执行一次 job2\n        timer.schedule(new TimerTaskTest(\"job2\"), delay2, period2);\n    }\n}\n```\n使用 Timer 实现任务调度的核心类是 Timer 和 TimerTask。其中 Timer 负责设定 TimerTask 的起始与间隔执行时间。使用者只需要创建一个 TimerTask 的继承类，实现自己的 run 方法，然后将其丢给 Timer 去执行即可。\n\nTimer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程`mainLoop`。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。可以看看这个守护线程的源码：\n```java\nprivate void mainLoop() {\n        while (true) {\n            try {\n                TimerTask task;\n                boolean taskFired;\n                synchronized(queue) {\n                    // Wait for queue to become non-empty\n                    while (queue.isEmpty() && newTasksMayBeScheduled)\n                        queue.wait();\n                    if (queue.isEmpty())\n                        break; // Queue is empty and will forever remain; die\n\n                    // Queue nonempty; look at first evt and do the right thing\n                    long currentTime, executionTime;\n                    task = queue.getMin();\n                    synchronized(task.lock) {   //加锁\n                        if (task.state == TimerTask.CANCELLED) {\n                            queue.removeMin();\n                            continue;  // No action required, poll queue again\n                        }\n                        currentTime = System.currentTimeMillis();\n                        executionTime = task.nextExecutionTime;\n                        if (taskFired = (executionTime<=currentTime)) {\n                            if (task.period == 0) { // Non-repeating, remove\n                                queue.removeMin();\n                                task.state = TimerTask.EXECUTED;\n                            } else { // Repeating task, reschedule\n                                queue.rescheduleMin(\n                                  task.period<0 ? currentTime   - task.period\n                                                : executionTime + task.period);\n                            }\n                        }\n                    }\n                    if (!taskFired) // Task hasn't yet fired; wait\n                        queue.wait(executionTime - currentTime);\n                }\n                if (taskFired)  // Task fired; run it, holding no locks\n                    task.run();\n            } catch(InterruptedException e) {\n            }\n        }\n    }\n```\nTimer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。而且，Timer是线程安全的。\n\n### 终止Timer线程\n只要一个程序的timer线程在运行，那么这个程序就会保持运行。当然，你可以通过以下四种方法终止一个timer线程：\n* 调用timer的cancle方法。你可以从程序的任何地方调用此方法，甚至在一个timer task的run方法里。\n* 让timer线程成为一个daemon线程（可以在创建timer时使用new Timer(true)达到这个目地），这样当程序只有daemon线程的时候，它就会自动终止运行。\n* 当timer相关的所有task执行完毕以后，删除所有此timer对象的引用（置成null），这样timer线程也会终止。\n* 调用System.exit方法，使整个程序（所有线程）终止。\n\n### 更进一步\n`Timer` 提供了四种执行方式\n* `schedule(TimerTask task, long delay, long period)`\n* `schedule(TimerTask task, Date time, long period)`\n* `scheduleAtFixedRate(TimerTask task, long delay, long period)`\n* `scheduleAtFixedRate(TimerTask task, Date firstTime, long period)`\n当计划反复执行的任务时，如果你注重任务执行的平滑度，那么请使用`schedule`方法，如果你在乎的是任务的执行频度那么使用`scheduleAtFixedRate`方法。\n`schedule`更注重保持间隔时间的稳定。\n`scheduleAtFixedRate`这个方法更注重保持执行频率的稳定。\n\n","source":"_posts/Java/taskScheduler/Timer.md","raw":"---\ntitle: TimerTask\ndate: 2017-11-27 10:33:22\ncategories: TaskScheduler\ntags: [Java,Task]\ndescription: 目前的 Web 应用，多数应用都具备任务调度的功能。本系列大致介绍了几种任务调度的 Java 实现方法，包括 Timer,Scheduler, Quartz 以及 JCron Tab，并对其优缺点进行比较\n---\n\n## TimerTask\n### 简单使用\nTimerTask 是最简单的任务调度方式之一\n```java\n public class TimerTaskTest extends TimerTask {\n    private String jobName = \"\";\n\n    public TimerTaskTest(String jobName) {\n        super();\n        this.jobName = jobName;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"execute \" + jobName);\n    }\n\n}\n```\n调用执行任务\n```java\npublic class MainExecute {\n    public static void main(String[] args) {\n        Timer timer = new Timer();\n        long delay1 = 1 * 1000;\n        long period1 = 1000;\n        // 从现在开始 1 秒钟之后，每隔 1 秒钟执行一次 job1\n        timer.schedule(new TimerTaskTest(\"job1\"), delay1, period1);\n        long delay2 = 2 * 1000;\n        long period2 = 2000;\n        // 从现在开始 2 秒钟之后，每隔 2 秒钟执行一次 job2\n        timer.schedule(new TimerTaskTest(\"job2\"), delay2, period2);\n    }\n}\n```\n使用 Timer 实现任务调度的核心类是 Timer 和 TimerTask。其中 Timer 负责设定 TimerTask 的起始与间隔执行时间。使用者只需要创建一个 TimerTask 的继承类，实现自己的 run 方法，然后将其丢给 Timer 去执行即可。\n\nTimer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程`mainLoop`。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。可以看看这个守护线程的源码：\n```java\nprivate void mainLoop() {\n        while (true) {\n            try {\n                TimerTask task;\n                boolean taskFired;\n                synchronized(queue) {\n                    // Wait for queue to become non-empty\n                    while (queue.isEmpty() && newTasksMayBeScheduled)\n                        queue.wait();\n                    if (queue.isEmpty())\n                        break; // Queue is empty and will forever remain; die\n\n                    // Queue nonempty; look at first evt and do the right thing\n                    long currentTime, executionTime;\n                    task = queue.getMin();\n                    synchronized(task.lock) {   //加锁\n                        if (task.state == TimerTask.CANCELLED) {\n                            queue.removeMin();\n                            continue;  // No action required, poll queue again\n                        }\n                        currentTime = System.currentTimeMillis();\n                        executionTime = task.nextExecutionTime;\n                        if (taskFired = (executionTime<=currentTime)) {\n                            if (task.period == 0) { // Non-repeating, remove\n                                queue.removeMin();\n                                task.state = TimerTask.EXECUTED;\n                            } else { // Repeating task, reschedule\n                                queue.rescheduleMin(\n                                  task.period<0 ? currentTime   - task.period\n                                                : executionTime + task.period);\n                            }\n                        }\n                    }\n                    if (!taskFired) // Task hasn't yet fired; wait\n                        queue.wait(executionTime - currentTime);\n                }\n                if (taskFired)  // Task fired; run it, holding no locks\n                    task.run();\n            } catch(InterruptedException e) {\n            }\n        }\n    }\n```\nTimer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。而且，Timer是线程安全的。\n\n### 终止Timer线程\n只要一个程序的timer线程在运行，那么这个程序就会保持运行。当然，你可以通过以下四种方法终止一个timer线程：\n* 调用timer的cancle方法。你可以从程序的任何地方调用此方法，甚至在一个timer task的run方法里。\n* 让timer线程成为一个daemon线程（可以在创建timer时使用new Timer(true)达到这个目地），这样当程序只有daemon线程的时候，它就会自动终止运行。\n* 当timer相关的所有task执行完毕以后，删除所有此timer对象的引用（置成null），这样timer线程也会终止。\n* 调用System.exit方法，使整个程序（所有线程）终止。\n\n### 更进一步\n`Timer` 提供了四种执行方式\n* `schedule(TimerTask task, long delay, long period)`\n* `schedule(TimerTask task, Date time, long period)`\n* `scheduleAtFixedRate(TimerTask task, long delay, long period)`\n* `scheduleAtFixedRate(TimerTask task, Date firstTime, long period)`\n当计划反复执行的任务时，如果你注重任务执行的平滑度，那么请使用`schedule`方法，如果你在乎的是任务的执行频度那么使用`scheduleAtFixedRate`方法。\n`schedule`更注重保持间隔时间的稳定。\n`scheduleAtFixedRate`这个方法更注重保持执行频率的稳定。\n\n","slug":"Java/taskScheduler/Timer","published":1,"updated":"2017-12-15T08:12:58.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqe001b6dof7sosk7j2","content":"<h2 id=\"TimerTask\"><a href=\"#TimerTask\" class=\"headerlink\" title=\"TimerTask\"></a>TimerTask</h2><h3 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h3><p>TimerTask 是最简单的任务调度方式之一<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTaskTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jobName = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimerTaskTest</span><span class=\"params\">(String jobName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jobName = jobName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"execute \"</span> + jobName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用执行任务<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainExecute</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay1 = <span class=\"number\">1</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period1 = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始 1 秒钟之后，每隔 1 秒钟执行一次 job1</span></span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> TimerTaskTest(<span class=\"string\">\"job1\"</span>), delay1, period1);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay2 = <span class=\"number\">2</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period2 = <span class=\"number\">2000</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始 2 秒钟之后，每隔 2 秒钟执行一次 job2</span></span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> TimerTaskTest(<span class=\"string\">\"job2\"</span>), delay2, period2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 Timer 实现任务调度的核心类是 Timer 和 TimerTask。其中 Timer 负责设定 TimerTask 的起始与间隔执行时间。使用者只需要创建一个 TimerTask 的继承类，实现自己的 run 方法，然后将其丢给 Timer 去执行即可。</p>\n<p>Timer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程<code>mainLoop</code>。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。可以看看这个守护线程的源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mainLoop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimerTask task;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> taskFired;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span>(queue) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Wait for queue to become non-empty</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class=\"line\">                        queue.wait();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (queue.isEmpty())</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>; <span class=\"comment\">// Queue is empty and will forever remain; die</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> currentTime, executionTime;</span><br><span class=\"line\">                    task = queue.getMin();</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span>(task.lock) &#123;   <span class=\"comment\">//加锁</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class=\"line\">                            queue.removeMin();</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;  <span class=\"comment\">// No action required, poll queue again</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        currentTime = System.currentTimeMillis();</span><br><span class=\"line\">                        executionTime = task.nextExecutionTime;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (task.period == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Non-repeating, remove</span></span><br><span class=\"line\">                                queue.removeMin();</span><br><span class=\"line\">                                task.state = TimerTask.EXECUTED;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// Repeating task, reschedule</span></span><br><span class=\"line\">                                queue.rescheduleMin(</span><br><span class=\"line\">                                  task.period&lt;<span class=\"number\">0</span> ? currentTime   - task.period</span><br><span class=\"line\">                                                : executionTime + task.period);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!taskFired) <span class=\"comment\">// Task hasn't yet fired; wait</span></span><br><span class=\"line\">                        queue.wait(executionTime - currentTime);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (taskFired)  <span class=\"comment\">// Task fired; run it, holding no locks</span></span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。而且，Timer是线程安全的。</p>\n<h3 id=\"终止Timer线程\"><a href=\"#终止Timer线程\" class=\"headerlink\" title=\"终止Timer线程\"></a>终止Timer线程</h3><p>只要一个程序的timer线程在运行，那么这个程序就会保持运行。当然，你可以通过以下四种方法终止一个timer线程：</p>\n<ul>\n<li>调用timer的cancle方法。你可以从程序的任何地方调用此方法，甚至在一个timer task的run方法里。</li>\n<li>让timer线程成为一个daemon线程（可以在创建timer时使用new Timer(true)达到这个目地），这样当程序只有daemon线程的时候，它就会自动终止运行。</li>\n<li>当timer相关的所有task执行完毕以后，删除所有此timer对象的引用（置成null），这样timer线程也会终止。</li>\n<li>调用System.exit方法，使整个程序（所有线程）终止。</li>\n</ul>\n<h3 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h3><p><code>Timer</code> 提供了四种执行方式</p>\n<ul>\n<li><code>schedule(TimerTask task, long delay, long period)</code></li>\n<li><code>schedule(TimerTask task, Date time, long period)</code></li>\n<li><code>scheduleAtFixedRate(TimerTask task, long delay, long period)</code></li>\n<li><code>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code><br>当计划反复执行的任务时，如果你注重任务执行的平滑度，那么请使用<code>schedule</code>方法，如果你在乎的是任务的执行频度那么使用<code>scheduleAtFixedRate</code>方法。<br><code>schedule</code>更注重保持间隔时间的稳定。<br><code>scheduleAtFixedRate</code>这个方法更注重保持执行频率的稳定。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TimerTask\"><a href=\"#TimerTask\" class=\"headerlink\" title=\"TimerTask\"></a>TimerTask</h2><h3 id=\"简单使用\"><a href=\"#简单使用\" class=\"headerlink\" title=\"简单使用\"></a>简单使用</h3><p>TimerTask 是最简单的任务调度方式之一<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTaskTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jobName = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimerTaskTest</span><span class=\"params\">(String jobName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jobName = jobName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"execute \"</span> + jobName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用执行任务<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainExecute</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay1 = <span class=\"number\">1</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period1 = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始 1 秒钟之后，每隔 1 秒钟执行一次 job1</span></span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> TimerTaskTest(<span class=\"string\">\"job1\"</span>), delay1, period1);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay2 = <span class=\"number\">2</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period2 = <span class=\"number\">2000</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始 2 秒钟之后，每隔 2 秒钟执行一次 job2</span></span><br><span class=\"line\">        timer.schedule(<span class=\"keyword\">new</span> TimerTaskTest(<span class=\"string\">\"job2\"</span>), delay2, period2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 Timer 实现任务调度的核心类是 Timer 和 TimerTask。其中 Timer 负责设定 TimerTask 的起始与间隔执行时间。使用者只需要创建一个 TimerTask 的继承类，实现自己的 run 方法，然后将其丢给 Timer 去执行即可。</p>\n<p>Timer 的设计核心是一个 TaskList 和一个 TaskThread。Timer 将接收到的任务丢到自己的 TaskList 中，TaskList 按照 Task 的最初执行时间进行排序。TimerThread 在创建 Timer 时会启动成为一个守护线程<code>mainLoop</code>。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread 被唤醒并执行该任务。之后 TimerThread 更新最近一个要执行的任务，继续休眠。可以看看这个守护线程的源码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mainLoop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimerTask task;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> taskFired;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span>(queue) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Wait for queue to become non-empty</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class=\"line\">                        queue.wait();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (queue.isEmpty())</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>; <span class=\"comment\">// Queue is empty and will forever remain; die</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Queue nonempty; look at first evt and do the right thing</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> currentTime, executionTime;</span><br><span class=\"line\">                    task = queue.getMin();</span><br><span class=\"line\">                    <span class=\"keyword\">synchronized</span>(task.lock) &#123;   <span class=\"comment\">//加锁</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class=\"line\">                            queue.removeMin();</span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;  <span class=\"comment\">// No action required, poll queue again</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        currentTime = System.currentTimeMillis();</span><br><span class=\"line\">                        executionTime = task.nextExecutionTime;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (task.period == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Non-repeating, remove</span></span><br><span class=\"line\">                                queue.removeMin();</span><br><span class=\"line\">                                task.state = TimerTask.EXECUTED;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// Repeating task, reschedule</span></span><br><span class=\"line\">                                queue.rescheduleMin(</span><br><span class=\"line\">                                  task.period&lt;<span class=\"number\">0</span> ? currentTime   - task.period</span><br><span class=\"line\">                                                : executionTime + task.period);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!taskFired) <span class=\"comment\">// Task hasn't yet fired; wait</span></span><br><span class=\"line\">                        queue.wait(executionTime - currentTime);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (taskFired)  <span class=\"comment\">// Task fired; run it, holding no locks</span></span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。而且，Timer是线程安全的。</p>\n<h3 id=\"终止Timer线程\"><a href=\"#终止Timer线程\" class=\"headerlink\" title=\"终止Timer线程\"></a>终止Timer线程</h3><p>只要一个程序的timer线程在运行，那么这个程序就会保持运行。当然，你可以通过以下四种方法终止一个timer线程：</p>\n<ul>\n<li>调用timer的cancle方法。你可以从程序的任何地方调用此方法，甚至在一个timer task的run方法里。</li>\n<li>让timer线程成为一个daemon线程（可以在创建timer时使用new Timer(true)达到这个目地），这样当程序只有daemon线程的时候，它就会自动终止运行。</li>\n<li>当timer相关的所有task执行完毕以后，删除所有此timer对象的引用（置成null），这样timer线程也会终止。</li>\n<li>调用System.exit方法，使整个程序（所有线程）终止。</li>\n</ul>\n<h3 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h3><p><code>Timer</code> 提供了四种执行方式</p>\n<ul>\n<li><code>schedule(TimerTask task, long delay, long period)</code></li>\n<li><code>schedule(TimerTask task, Date time, long period)</code></li>\n<li><code>scheduleAtFixedRate(TimerTask task, long delay, long period)</code></li>\n<li><code>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</code><br>当计划反复执行的任务时，如果你注重任务执行的平滑度，那么请使用<code>schedule</code>方法，如果你在乎的是任务的执行频度那么使用<code>scheduleAtFixedRate</code>方法。<br><code>schedule</code>更注重保持间隔时间的稳定。<br><code>scheduleAtFixedRate</code>这个方法更注重保持执行频率的稳定。</li>\n</ul>\n"},{"title":"Quartz","date":"2017-11-27T02:33:22.000Z","description":"目前的 Web 应用，多数应用都具备任务调度的功能。本系列大致介绍了几种任务调度的 Java 实现方法，包括 Timer,Scheduler, Quartz 以及 JCron Tab，并对其优缺点进行比较","_content":"\n### 先看一个简单的Demo\n\n```java\npublic class JobImpl implements Job {\n    @Override\n    public void execute(JobExecutionContext context) throws JobExecutionException {\n        System.out.println(\"job impl running\");\n    }\n}\n```\n```java\npublic class TestQuartz {\n    public static void main(String[] args) throws SchedulerException, InterruptedException {\n        // 创建调度器\n        SchedulerFactory schedulerFactory = new StdSchedulerFactory();\n        Scheduler scheduler = schedulerFactory.getScheduler();\n\n        // 创建任务\n        JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(\"myJob\", \"jobGroup\").build();\n\n        // 创建触发器\n        // withIntervalInSeconds(2)表示每隔2s执行任务\n        Date triggerDate = new Date();\n        SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever();\n        TriggerBuilder<Trigger> triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(\"myTrigger\", \"triggerGroup\");\n        Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();\n\n        // 将任务及其触发器放入调度器\n        scheduler.scheduleJob(jobDetail, trigger);\n        // 调度器开始调度任务\n        scheduler.start();\n    }\n\n}\n```\n`quartz.properties`\n```\n#调度器名，默认名是QuartzScheduler\norg.quartz.scheduler.instanceName= TestQuartzScheduler\n\n#============================================================================\n# Configure ThreadPool   配置线程池\n#============================================================================\norg.quartz.threadPool.class= org.quartz.simpl.SimpleThreadPool\norg.quartz.threadPool.threadCount= 10\norg.quartz.threadPool.threadPriority= 5\n\n#============================================================================\n# Configure JobStore  配置任务存储方式\n#============================================================================\n#相当于扫描频率\norg.quartz.jobStore.misfireThreshold= 60000\norg.quartz.jobStore.class= org.quartz.simpl.RAMJobStore\n```\n`TestQuartz.main()`依次创建了`scheduler`（调度器）、`job`（任务）、`trigger`（触发器），其中，`job`指定了`JobImpl`，`trigger`保存`job`的触发执行策略（每隔2s执行一次），`scheduler`将`job`和`trigger`绑定在一起，最后`scheduler.start()`启动调度，每隔2s触发执行`JobImpl.execute()`，打印出job impl running。\n\n对于`quartz.properties`，简单场景下，开发者不用自定义配置，使用`quartz`默认配置即可，但在要求较高的使用场景中还是要自定义配置，比如通过`org.quartz.threadPool.threadCount`设置足够的线程数可提高多job场景下的运行性能。更详尽的配置见[官网配置说明页](http://www.quartz-scheduler.org/documentation/quartz-2.1.x/configuration/)。\n### job（任务）\njob由若干个`class`和`interface`实现。\n#### Job接口\n开发者想要`job`完成什么样的功能，必须且只能由开发者自己动手来编写实现，比如demo中的`JobImpl`，这点无容置疑。但要想让自己的`job`被`quartz`识别，就必须按照`quartz`的规则来办事，这个规则就是`job`实现类必须实现Job接口，比如`JobImpl`就实现了Job。\n\nJob只有一个`execute(JobExecutionContext)`，`JobExecutionContext`保存了`job`的上下文信息，比如绑定的是哪个`trigger`。`job`实现类必须重写`execute()`，执行job实际上就是运行`execute()`。\n#### JobDetailImpl类 / JobDetail接口\n`JobDetailImpl`类实现了`JobDetail`接口，用来描述一个job，定义了job所有属性及其get/set方法。了解job拥有哪些属性，就能知道quartz能提供什么样的能力，下面笔者用表格列出job若干核心属性。\n\n|属性名\t| 说明|\n|--------|-----------------------|\n| class | 必须是job实现类（比如`JobImpl`），用来绑定一个具体job|\n| name | job名称。如果未指定，会自动分配一个唯一名称。所有job都必须拥有一个唯一name，如果两个job的name重复，则只有最前面的job能被调度|\n| group | job所属的组名 |\n| description | job描述 |\n| durability | 是否持久化。如果job设置为非持久，当没有活跃的trigger与之关联的时候，job会自动从scheduler中删除。也就是说，非持久job的生命期是由trigger的存在与否决定的 |\n| shouldRecover | 是否可恢复。如果job设置为可恢复，一旦job执行时scheduler发生hard shutdown（比如进程崩溃或关机），当scheduler重启后，该job会被重新执行|\n| jobDataMap | 除了上面常规属性外，用户可以把任意kv数据存入jobDataMap，实现job属性的无限制扩展，执行job时可以使用这些属性数据。此属性的类型是`JobDataMap`，实现了`Serializable`接口，可做跨平台的序列化传输 |\n\n#### JobBuilder类\n```java\n// 创建任务\nJobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(\"myJob\", \"jobGroup\").build();\n```\n上面代码是demo一个片段，可以看出`JobBuilder`类的作用：接收job实现类`JobImpl`，生成`JobDetail`实例，默认生成`JobDetailImpl`实例。\n\n这里运用了建造者模式：`JobImpl`相当于Product；`JobDetail`相当于Builder，拥有job的各种属性及其get/set方法；`JobBuilder`相当于Director，可为一个job组装各种属性。\n\n### trigger（触发器）\ntrigger由若干个class和interface实现。\n#### SimpleTriggerImpl类 / SimpleTrigger接口 / Trigger接口\n`SimpleTriggerImpl`类实现了`SimpleTrigger`接口，`SimpleTrigger`接口继承了`Trigger`接口，它们表示触发器，用来保存触发job的策略，比如每隔几秒触发job。实际上，quartz有两大触发器：`SimpleTrigger`和`CronTrigger`\n\nTrigger诸类保存了trigger所有属性，同job属性一样，了解trigger属性有助于我们了解quartz能提供什么样的能力，下面笔者用表格列出trigger若干核心属性。\n\n|属性名\t|属性类型\t|说明|\n|---------|----------|----------|\n|name|所有trigger通用|trigger名称|\n|group|所有trigger通用|trigger所属的组名|\n|description|所有trigger通用|trigger描述|\n|calendarName|所有trigger通用|日历名称，指定使用哪个Calendar类，经常用来从trigger的调度计划中排除某些时间段|\n|misfireInstruction|所有trigger通用|错过job（未在指定时间执行的job）的处理策略，默认为`MISFIRE_INSTRUCTION_SMART_POLICY`。|\n|priority|所有trigger通用|优先级，默认为5。当多个trigger同时触发job时，线程池可能不够用，此时根据优先级来决定谁先触发|\n|jobDataMap|所有trigger通用|同job的jobDataMap。假如job和trigger的jobDataMap有同名key，通过`getMergedJobDataMap()`获取的jobDataMap，将以trigger的为准|\n|startTime|所有trigger通用|触发开始时间，默认为当前时间。决定什么时间开始触发job|\n|endTime|所有trigger通用|触发结束时间。决定什么时间停止触发job|\n|nextFireTime|SimpleTrigger私有|\t下一次触发job的时间|\n|previousFireTime|SimpleTrigger私有|上一次触发job的时间|\n|repeatCount|SimpleTrigger私有|需触发的总次数|\n|timesTriggered|SimpleTrigger私有|已经触发过的次数|\n|repeatInterval|SimpleTrigger私有|触发间隔时间|\n\n#### TriggerBuilder类\n```java\n// 创建触发器\n// withIntervalInSeconds(2)表示每隔2s执行任务\n  Date triggerDate = new Date();\n  SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever();\n  TriggerBuilder<Trigger> triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(\"myTrigger\", \"triggerGroup\");\n  Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();\n```\n上面代码是demo一个片段，可以看出`TriggerBuilder`类的作用：生成Trigger实例，默认生成`SimpleTriggerImpl`实例。同`JobBuilder`一样，这里也运用了建造者模式。\n### scheduler（调度器）\nscheduler主要由`StdScheduler类`、`Scheduler接口`、`StdSchedulerFactory类`、`SchedulerFactory接口`、`QuartzScheduler类`实现。\n\n```java\n// 创建调度器\n  SchedulerFactory schedulerFactory = new StdSchedulerFactory();\n  Scheduler scheduler = schedulerFactory.getScheduler();\n......\n// 将任务及其触发器放入调度器\n  scheduler.scheduleJob(jobDetail, trigger);\n// 调度器开始调度任务\n  scheduler.start();\n```\n上面代码是demo一个片段，可以看出这里运用了工厂模式，通过factory类（`StdSchedulerFactory`）生产出scheduler实例（`StdScheduler`）。scheduler是整个quartz的关键，为此，笔者把demo中用到的scheduler接口的源码加上中文注释做个讲解。\n\n* `StdSchedulerFactory.getScheduler()`源码\n```java\npublic Scheduler getScheduler() throws SchedulerException {\n        // 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件\n        // 解析出quartz配置内容和环境变量，存入PropertiesParser对象\n        // PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中\n        if (cfg == null) {\n            initialize();\n        }\n        // 获取调度器池，采用了单例模式\n        // 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例\n        // getInstance()用synchronized防止并发创建\n        SchedulerRepository schedRep = SchedulerRepository.getInstance();\n\n        // 从调度器池中取出当前配置所用的调度器\n        Scheduler sched = schedRep.lookup(getSchedulerName());\n\n        ......\n\n        // 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：\n        // 1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；\n        // 2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；\n        // 3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；\n        // 4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；\n        // 5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；\n        // 6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；\n        // 7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；\n        // 8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中\n        sched = instantiate();\n\n        return sched;\n}\n```\n上面有个过程是初始化jobStore，表示使用哪种方式存储scheduler相关数据。quartz有两大jobStore：`RAMJobStore和JDBCJobStore`。`RAMJobStore`把数据存入内存，性能最高，配置也简单，但缺点是系统挂了难以恢复数据。`JDBCJobStore`保存数据到数据库，保证数据的可恢复性，但性能较差且配置复杂。\n\n* `QuartzScheduler.scheduleJob(JobDetail, Trigger)`源码\n```java\npublic Date scheduleJob(JobDetail jobDetail,\n            Trigger trigger) throws SchedulerException {\n        // 检查调度器是否开启，如果关闭则throw异常到上层\n        validateState();\n        ......\n        // 获取trigger首次触发job的时间，以此时间为起点，每隔一段指定的时间触发job\n        Date ft = trig.computeFirstFireTime(cal);\n\n        if (ft == null) {\n            throw new SchedulerException(\n                    \"Based on configured schedule, the given trigger '\" + trigger.getKey() + \"' will never fire.\");\n        }\n\n        // 把job和trigger注册进调度器的jobStore\n        resources.getJobStore().storeJobAndTrigger(jobDetail, trig);\n        // 通知job监听者\n        notifySchedulerListenersJobAdded(jobDetail);                \n        // 通知调度器线程\n        notifySchedulerThread(trigger.getNextFireTime().getTime());\n        // 通知trigger监听者\n        notifySchedulerListenersSchduled(trigger);\n\n        return ft;\n    }\n```\n* `QuartzScheduler.start()`源码\n```java\npublic void start() throws SchedulerException {\n        ......\n        // 这句最关键，作用是使调度器线程跳出一个无限循环，开始轮询所有trigger触发job\n        // 原理详见“如何采用多线程进行任务调度”\n        schedThread.togglePause(false);\n        ......\n    }\n```\n\n","source":"_posts/Java/taskScheduler/Quartz.md","raw":"---\ntitle: Quartz\ndate: 2017-11-27 10:33:22\ncategories: TaskScheduler\ntags: [Java,Task]\ndescription: 目前的 Web 应用，多数应用都具备任务调度的功能。本系列大致介绍了几种任务调度的 Java 实现方法，包括 Timer,Scheduler, Quartz 以及 JCron Tab，并对其优缺点进行比较\n---\n\n### 先看一个简单的Demo\n\n```java\npublic class JobImpl implements Job {\n    @Override\n    public void execute(JobExecutionContext context) throws JobExecutionException {\n        System.out.println(\"job impl running\");\n    }\n}\n```\n```java\npublic class TestQuartz {\n    public static void main(String[] args) throws SchedulerException, InterruptedException {\n        // 创建调度器\n        SchedulerFactory schedulerFactory = new StdSchedulerFactory();\n        Scheduler scheduler = schedulerFactory.getScheduler();\n\n        // 创建任务\n        JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(\"myJob\", \"jobGroup\").build();\n\n        // 创建触发器\n        // withIntervalInSeconds(2)表示每隔2s执行任务\n        Date triggerDate = new Date();\n        SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever();\n        TriggerBuilder<Trigger> triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(\"myTrigger\", \"triggerGroup\");\n        Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();\n\n        // 将任务及其触发器放入调度器\n        scheduler.scheduleJob(jobDetail, trigger);\n        // 调度器开始调度任务\n        scheduler.start();\n    }\n\n}\n```\n`quartz.properties`\n```\n#调度器名，默认名是QuartzScheduler\norg.quartz.scheduler.instanceName= TestQuartzScheduler\n\n#============================================================================\n# Configure ThreadPool   配置线程池\n#============================================================================\norg.quartz.threadPool.class= org.quartz.simpl.SimpleThreadPool\norg.quartz.threadPool.threadCount= 10\norg.quartz.threadPool.threadPriority= 5\n\n#============================================================================\n# Configure JobStore  配置任务存储方式\n#============================================================================\n#相当于扫描频率\norg.quartz.jobStore.misfireThreshold= 60000\norg.quartz.jobStore.class= org.quartz.simpl.RAMJobStore\n```\n`TestQuartz.main()`依次创建了`scheduler`（调度器）、`job`（任务）、`trigger`（触发器），其中，`job`指定了`JobImpl`，`trigger`保存`job`的触发执行策略（每隔2s执行一次），`scheduler`将`job`和`trigger`绑定在一起，最后`scheduler.start()`启动调度，每隔2s触发执行`JobImpl.execute()`，打印出job impl running。\n\n对于`quartz.properties`，简单场景下，开发者不用自定义配置，使用`quartz`默认配置即可，但在要求较高的使用场景中还是要自定义配置，比如通过`org.quartz.threadPool.threadCount`设置足够的线程数可提高多job场景下的运行性能。更详尽的配置见[官网配置说明页](http://www.quartz-scheduler.org/documentation/quartz-2.1.x/configuration/)。\n### job（任务）\njob由若干个`class`和`interface`实现。\n#### Job接口\n开发者想要`job`完成什么样的功能，必须且只能由开发者自己动手来编写实现，比如demo中的`JobImpl`，这点无容置疑。但要想让自己的`job`被`quartz`识别，就必须按照`quartz`的规则来办事，这个规则就是`job`实现类必须实现Job接口，比如`JobImpl`就实现了Job。\n\nJob只有一个`execute(JobExecutionContext)`，`JobExecutionContext`保存了`job`的上下文信息，比如绑定的是哪个`trigger`。`job`实现类必须重写`execute()`，执行job实际上就是运行`execute()`。\n#### JobDetailImpl类 / JobDetail接口\n`JobDetailImpl`类实现了`JobDetail`接口，用来描述一个job，定义了job所有属性及其get/set方法。了解job拥有哪些属性，就能知道quartz能提供什么样的能力，下面笔者用表格列出job若干核心属性。\n\n|属性名\t| 说明|\n|--------|-----------------------|\n| class | 必须是job实现类（比如`JobImpl`），用来绑定一个具体job|\n| name | job名称。如果未指定，会自动分配一个唯一名称。所有job都必须拥有一个唯一name，如果两个job的name重复，则只有最前面的job能被调度|\n| group | job所属的组名 |\n| description | job描述 |\n| durability | 是否持久化。如果job设置为非持久，当没有活跃的trigger与之关联的时候，job会自动从scheduler中删除。也就是说，非持久job的生命期是由trigger的存在与否决定的 |\n| shouldRecover | 是否可恢复。如果job设置为可恢复，一旦job执行时scheduler发生hard shutdown（比如进程崩溃或关机），当scheduler重启后，该job会被重新执行|\n| jobDataMap | 除了上面常规属性外，用户可以把任意kv数据存入jobDataMap，实现job属性的无限制扩展，执行job时可以使用这些属性数据。此属性的类型是`JobDataMap`，实现了`Serializable`接口，可做跨平台的序列化传输 |\n\n#### JobBuilder类\n```java\n// 创建任务\nJobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(\"myJob\", \"jobGroup\").build();\n```\n上面代码是demo一个片段，可以看出`JobBuilder`类的作用：接收job实现类`JobImpl`，生成`JobDetail`实例，默认生成`JobDetailImpl`实例。\n\n这里运用了建造者模式：`JobImpl`相当于Product；`JobDetail`相当于Builder，拥有job的各种属性及其get/set方法；`JobBuilder`相当于Director，可为一个job组装各种属性。\n\n### trigger（触发器）\ntrigger由若干个class和interface实现。\n#### SimpleTriggerImpl类 / SimpleTrigger接口 / Trigger接口\n`SimpleTriggerImpl`类实现了`SimpleTrigger`接口，`SimpleTrigger`接口继承了`Trigger`接口，它们表示触发器，用来保存触发job的策略，比如每隔几秒触发job。实际上，quartz有两大触发器：`SimpleTrigger`和`CronTrigger`\n\nTrigger诸类保存了trigger所有属性，同job属性一样，了解trigger属性有助于我们了解quartz能提供什么样的能力，下面笔者用表格列出trigger若干核心属性。\n\n|属性名\t|属性类型\t|说明|\n|---------|----------|----------|\n|name|所有trigger通用|trigger名称|\n|group|所有trigger通用|trigger所属的组名|\n|description|所有trigger通用|trigger描述|\n|calendarName|所有trigger通用|日历名称，指定使用哪个Calendar类，经常用来从trigger的调度计划中排除某些时间段|\n|misfireInstruction|所有trigger通用|错过job（未在指定时间执行的job）的处理策略，默认为`MISFIRE_INSTRUCTION_SMART_POLICY`。|\n|priority|所有trigger通用|优先级，默认为5。当多个trigger同时触发job时，线程池可能不够用，此时根据优先级来决定谁先触发|\n|jobDataMap|所有trigger通用|同job的jobDataMap。假如job和trigger的jobDataMap有同名key，通过`getMergedJobDataMap()`获取的jobDataMap，将以trigger的为准|\n|startTime|所有trigger通用|触发开始时间，默认为当前时间。决定什么时间开始触发job|\n|endTime|所有trigger通用|触发结束时间。决定什么时间停止触发job|\n|nextFireTime|SimpleTrigger私有|\t下一次触发job的时间|\n|previousFireTime|SimpleTrigger私有|上一次触发job的时间|\n|repeatCount|SimpleTrigger私有|需触发的总次数|\n|timesTriggered|SimpleTrigger私有|已经触发过的次数|\n|repeatInterval|SimpleTrigger私有|触发间隔时间|\n\n#### TriggerBuilder类\n```java\n// 创建触发器\n// withIntervalInSeconds(2)表示每隔2s执行任务\n  Date triggerDate = new Date();\n  SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever();\n  TriggerBuilder<Trigger> triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(\"myTrigger\", \"triggerGroup\");\n  Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();\n```\n上面代码是demo一个片段，可以看出`TriggerBuilder`类的作用：生成Trigger实例，默认生成`SimpleTriggerImpl`实例。同`JobBuilder`一样，这里也运用了建造者模式。\n### scheduler（调度器）\nscheduler主要由`StdScheduler类`、`Scheduler接口`、`StdSchedulerFactory类`、`SchedulerFactory接口`、`QuartzScheduler类`实现。\n\n```java\n// 创建调度器\n  SchedulerFactory schedulerFactory = new StdSchedulerFactory();\n  Scheduler scheduler = schedulerFactory.getScheduler();\n......\n// 将任务及其触发器放入调度器\n  scheduler.scheduleJob(jobDetail, trigger);\n// 调度器开始调度任务\n  scheduler.start();\n```\n上面代码是demo一个片段，可以看出这里运用了工厂模式，通过factory类（`StdSchedulerFactory`）生产出scheduler实例（`StdScheduler`）。scheduler是整个quartz的关键，为此，笔者把demo中用到的scheduler接口的源码加上中文注释做个讲解。\n\n* `StdSchedulerFactory.getScheduler()`源码\n```java\npublic Scheduler getScheduler() throws SchedulerException {\n        // 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件\n        // 解析出quartz配置内容和环境变量，存入PropertiesParser对象\n        // PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中\n        if (cfg == null) {\n            initialize();\n        }\n        // 获取调度器池，采用了单例模式\n        // 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例\n        // getInstance()用synchronized防止并发创建\n        SchedulerRepository schedRep = SchedulerRepository.getInstance();\n\n        // 从调度器池中取出当前配置所用的调度器\n        Scheduler sched = schedRep.lookup(getSchedulerName());\n\n        ......\n\n        // 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：\n        // 1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；\n        // 2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；\n        // 3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；\n        // 4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；\n        // 5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；\n        // 6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；\n        // 7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；\n        // 8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中\n        sched = instantiate();\n\n        return sched;\n}\n```\n上面有个过程是初始化jobStore，表示使用哪种方式存储scheduler相关数据。quartz有两大jobStore：`RAMJobStore和JDBCJobStore`。`RAMJobStore`把数据存入内存，性能最高，配置也简单，但缺点是系统挂了难以恢复数据。`JDBCJobStore`保存数据到数据库，保证数据的可恢复性，但性能较差且配置复杂。\n\n* `QuartzScheduler.scheduleJob(JobDetail, Trigger)`源码\n```java\npublic Date scheduleJob(JobDetail jobDetail,\n            Trigger trigger) throws SchedulerException {\n        // 检查调度器是否开启，如果关闭则throw异常到上层\n        validateState();\n        ......\n        // 获取trigger首次触发job的时间，以此时间为起点，每隔一段指定的时间触发job\n        Date ft = trig.computeFirstFireTime(cal);\n\n        if (ft == null) {\n            throw new SchedulerException(\n                    \"Based on configured schedule, the given trigger '\" + trigger.getKey() + \"' will never fire.\");\n        }\n\n        // 把job和trigger注册进调度器的jobStore\n        resources.getJobStore().storeJobAndTrigger(jobDetail, trig);\n        // 通知job监听者\n        notifySchedulerListenersJobAdded(jobDetail);                \n        // 通知调度器线程\n        notifySchedulerThread(trigger.getNextFireTime().getTime());\n        // 通知trigger监听者\n        notifySchedulerListenersSchduled(trigger);\n\n        return ft;\n    }\n```\n* `QuartzScheduler.start()`源码\n```java\npublic void start() throws SchedulerException {\n        ......\n        // 这句最关键，作用是使调度器线程跳出一个无限循环，开始轮询所有trigger触发job\n        // 原理详见“如何采用多线程进行任务调度”\n        schedThread.togglePause(false);\n        ......\n    }\n```\n\n","slug":"Java/taskScheduler/Quartz","published":1,"updated":"2017-12-15T08:12:58.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqg001c6dofsixdh3li","content":"<h3 id=\"先看一个简单的Demo\"><a href=\"#先看一个简单的Demo\" class=\"headerlink\" title=\"先看一个简单的Demo\"></a>先看一个简单的Demo</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JobImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Job</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(JobExecutionContext context)</span> <span class=\"keyword\">throws</span> JobExecutionException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"job impl running\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestQuartz</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> SchedulerException, InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建调度器</span></span><br><span class=\"line\">        SchedulerFactory schedulerFactory = <span class=\"keyword\">new</span> StdSchedulerFactory();</span><br><span class=\"line\">        Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建任务</span></span><br><span class=\"line\">        JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(<span class=\"string\">\"myJob\"</span>, <span class=\"string\">\"jobGroup\"</span>).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建触发器</span></span><br><span class=\"line\">        <span class=\"comment\">// withIntervalInSeconds(2)表示每隔2s执行任务</span></span><br><span class=\"line\">        Date triggerDate = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class=\"number\">2</span>).repeatForever();</span><br><span class=\"line\">        TriggerBuilder&lt;Trigger&gt; triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(<span class=\"string\">\"myTrigger\"</span>, <span class=\"string\">\"triggerGroup\"</span>);</span><br><span class=\"line\">        Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将任务及其触发器放入调度器</span></span><br><span class=\"line\">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class=\"line\">        <span class=\"comment\">// 调度器开始调度任务</span></span><br><span class=\"line\">        scheduler.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>quartz.properties</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#调度器名，默认名是QuartzScheduler</span><br><span class=\"line\">org.quartz.scheduler.instanceName= TestQuartzScheduler</span><br><span class=\"line\"></span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure ThreadPool   配置线程池</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.threadPool.class= org.quartz.simpl.SimpleThreadPool</span><br><span class=\"line\">org.quartz.threadPool.threadCount= 10</span><br><span class=\"line\">org.quartz.threadPool.threadPriority= 5</span><br><span class=\"line\"></span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure JobStore  配置任务存储方式</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">#相当于扫描频率</span><br><span class=\"line\">org.quartz.jobStore.misfireThreshold= 60000</span><br><span class=\"line\">org.quartz.jobStore.class= org.quartz.simpl.RAMJobStore</span><br></pre></td></tr></table></figure></p>\n<p><code>TestQuartz.main()</code>依次创建了<code>scheduler</code>（调度器）、<code>job</code>（任务）、<code>trigger</code>（触发器），其中，<code>job</code>指定了<code>JobImpl</code>，<code>trigger</code>保存<code>job</code>的触发执行策略（每隔2s执行一次），<code>scheduler</code>将<code>job</code>和<code>trigger</code>绑定在一起，最后<code>scheduler.start()</code>启动调度，每隔2s触发执行<code>JobImpl.execute()</code>，打印出job impl running。</p>\n<p>对于<code>quartz.properties</code>，简单场景下，开发者不用自定义配置，使用<code>quartz</code>默认配置即可，但在要求较高的使用场景中还是要自定义配置，比如通过<code>org.quartz.threadPool.threadCount</code>设置足够的线程数可提高多job场景下的运行性能。更详尽的配置见<a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.1.x/configuration/\" target=\"_blank\" rel=\"noopener\">官网配置说明页</a>。</p>\n<h3 id=\"job（任务）\"><a href=\"#job（任务）\" class=\"headerlink\" title=\"job（任务）\"></a>job（任务）</h3><p>job由若干个<code>class</code>和<code>interface</code>实现。</p>\n<h4 id=\"Job接口\"><a href=\"#Job接口\" class=\"headerlink\" title=\"Job接口\"></a>Job接口</h4><p>开发者想要<code>job</code>完成什么样的功能，必须且只能由开发者自己动手来编写实现，比如demo中的<code>JobImpl</code>，这点无容置疑。但要想让自己的<code>job</code>被<code>quartz</code>识别，就必须按照<code>quartz</code>的规则来办事，这个规则就是<code>job</code>实现类必须实现Job接口，比如<code>JobImpl</code>就实现了Job。</p>\n<p>Job只有一个<code>execute(JobExecutionContext)</code>，<code>JobExecutionContext</code>保存了<code>job</code>的上下文信息，比如绑定的是哪个<code>trigger</code>。<code>job</code>实现类必须重写<code>execute()</code>，执行job实际上就是运行<code>execute()</code>。</p>\n<h4 id=\"JobDetailImpl类-JobDetail接口\"><a href=\"#JobDetailImpl类-JobDetail接口\" class=\"headerlink\" title=\"JobDetailImpl类 / JobDetail接口\"></a>JobDetailImpl类 / JobDetail接口</h4><p><code>JobDetailImpl</code>类实现了<code>JobDetail</code>接口，用来描述一个job，定义了job所有属性及其get/set方法。了解job拥有哪些属性，就能知道quartz能提供什么样的能力，下面笔者用表格列出job若干核心属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>class</td>\n<td>必须是job实现类（比如<code>JobImpl</code>），用来绑定一个具体job</td>\n</tr>\n<tr>\n<td>name</td>\n<td>job名称。如果未指定，会自动分配一个唯一名称。所有job都必须拥有一个唯一name，如果两个job的name重复，则只有最前面的job能被调度</td>\n</tr>\n<tr>\n<td>group</td>\n<td>job所属的组名</td>\n</tr>\n<tr>\n<td>description</td>\n<td>job描述</td>\n</tr>\n<tr>\n<td>durability</td>\n<td>是否持久化。如果job设置为非持久，当没有活跃的trigger与之关联的时候，job会自动从scheduler中删除。也就是说，非持久job的生命期是由trigger的存在与否决定的</td>\n</tr>\n<tr>\n<td>shouldRecover</td>\n<td>是否可恢复。如果job设置为可恢复，一旦job执行时scheduler发生hard shutdown（比如进程崩溃或关机），当scheduler重启后，该job会被重新执行</td>\n</tr>\n<tr>\n<td>jobDataMap</td>\n<td>除了上面常规属性外，用户可以把任意kv数据存入jobDataMap，实现job属性的无限制扩展，执行job时可以使用这些属性数据。此属性的类型是<code>JobDataMap</code>，实现了<code>Serializable</code>接口，可做跨平台的序列化传输</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"JobBuilder类\"><a href=\"#JobBuilder类\" class=\"headerlink\" title=\"JobBuilder类\"></a>JobBuilder类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务</span></span><br><span class=\"line\">JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(<span class=\"string\">\"myJob\"</span>, <span class=\"string\">\"jobGroup\"</span>).build();</span><br></pre></td></tr></table></figure>\n<p>上面代码是demo一个片段，可以看出<code>JobBuilder</code>类的作用：接收job实现类<code>JobImpl</code>，生成<code>JobDetail</code>实例，默认生成<code>JobDetailImpl</code>实例。</p>\n<p>这里运用了建造者模式：<code>JobImpl</code>相当于Product；<code>JobDetail</code>相当于Builder，拥有job的各种属性及其get/set方法；<code>JobBuilder</code>相当于Director，可为一个job组装各种属性。</p>\n<h3 id=\"trigger（触发器）\"><a href=\"#trigger（触发器）\" class=\"headerlink\" title=\"trigger（触发器）\"></a>trigger（触发器）</h3><p>trigger由若干个class和interface实现。</p>\n<h4 id=\"SimpleTriggerImpl类-SimpleTrigger接口-Trigger接口\"><a href=\"#SimpleTriggerImpl类-SimpleTrigger接口-Trigger接口\" class=\"headerlink\" title=\"SimpleTriggerImpl类 / SimpleTrigger接口 / Trigger接口\"></a>SimpleTriggerImpl类 / SimpleTrigger接口 / Trigger接口</h4><p><code>SimpleTriggerImpl</code>类实现了<code>SimpleTrigger</code>接口，<code>SimpleTrigger</code>接口继承了<code>Trigger</code>接口，它们表示触发器，用来保存触发job的策略，比如每隔几秒触发job。实际上，quartz有两大触发器：<code>SimpleTrigger</code>和<code>CronTrigger</code></p>\n<p>Trigger诸类保存了trigger所有属性，同job属性一样，了解trigger属性有助于我们了解quartz能提供什么样的能力，下面笔者用表格列出trigger若干核心属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>属性类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>所有trigger通用</td>\n<td>trigger名称</td>\n</tr>\n<tr>\n<td>group</td>\n<td>所有trigger通用</td>\n<td>trigger所属的组名</td>\n</tr>\n<tr>\n<td>description</td>\n<td>所有trigger通用</td>\n<td>trigger描述</td>\n</tr>\n<tr>\n<td>calendarName</td>\n<td>所有trigger通用</td>\n<td>日历名称，指定使用哪个Calendar类，经常用来从trigger的调度计划中排除某些时间段</td>\n</tr>\n<tr>\n<td>misfireInstruction</td>\n<td>所有trigger通用</td>\n<td>错过job（未在指定时间执行的job）的处理策略，默认为<code>MISFIRE_INSTRUCTION_SMART_POLICY</code>。</td>\n</tr>\n<tr>\n<td>priority</td>\n<td>所有trigger通用</td>\n<td>优先级，默认为5。当多个trigger同时触发job时，线程池可能不够用，此时根据优先级来决定谁先触发</td>\n</tr>\n<tr>\n<td>jobDataMap</td>\n<td>所有trigger通用</td>\n<td>同job的jobDataMap。假如job和trigger的jobDataMap有同名key，通过<code>getMergedJobDataMap()</code>获取的jobDataMap，将以trigger的为准</td>\n</tr>\n<tr>\n<td>startTime</td>\n<td>所有trigger通用</td>\n<td>触发开始时间，默认为当前时间。决定什么时间开始触发job</td>\n</tr>\n<tr>\n<td>endTime</td>\n<td>所有trigger通用</td>\n<td>触发结束时间。决定什么时间停止触发job</td>\n</tr>\n<tr>\n<td>nextFireTime</td>\n<td>SimpleTrigger私有</td>\n<td>下一次触发job的时间</td>\n</tr>\n<tr>\n<td>previousFireTime</td>\n<td>SimpleTrigger私有</td>\n<td>上一次触发job的时间</td>\n</tr>\n<tr>\n<td>repeatCount</td>\n<td>SimpleTrigger私有</td>\n<td>需触发的总次数</td>\n</tr>\n<tr>\n<td>timesTriggered</td>\n<td>SimpleTrigger私有</td>\n<td>已经触发过的次数</td>\n</tr>\n<tr>\n<td>repeatInterval</td>\n<td>SimpleTrigger私有</td>\n<td>触发间隔时间</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"TriggerBuilder类\"><a href=\"#TriggerBuilder类\" class=\"headerlink\" title=\"TriggerBuilder类\"></a>TriggerBuilder类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建触发器</span></span><br><span class=\"line\"><span class=\"comment\">// withIntervalInSeconds(2)表示每隔2s执行任务</span></span><br><span class=\"line\">  Date triggerDate = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">  SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class=\"number\">2</span>).repeatForever();</span><br><span class=\"line\">  TriggerBuilder&lt;Trigger&gt; triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(<span class=\"string\">\"myTrigger\"</span>, <span class=\"string\">\"triggerGroup\"</span>);</span><br><span class=\"line\">  Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();</span><br></pre></td></tr></table></figure>\n<p>上面代码是demo一个片段，可以看出<code>TriggerBuilder</code>类的作用：生成Trigger实例，默认生成<code>SimpleTriggerImpl</code>实例。同<code>JobBuilder</code>一样，这里也运用了建造者模式。</p>\n<h3 id=\"scheduler（调度器）\"><a href=\"#scheduler（调度器）\" class=\"headerlink\" title=\"scheduler（调度器）\"></a>scheduler（调度器）</h3><p>scheduler主要由<code>StdScheduler类</code>、<code>Scheduler接口</code>、<code>StdSchedulerFactory类</code>、<code>SchedulerFactory接口</code>、<code>QuartzScheduler类</code>实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建调度器</span></span><br><span class=\"line\">  SchedulerFactory schedulerFactory = <span class=\"keyword\">new</span> StdSchedulerFactory();</span><br><span class=\"line\">  Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">// 将任务及其触发器放入调度器</span></span><br><span class=\"line\">  scheduler.scheduleJob(jobDetail, trigger);</span><br><span class=\"line\"><span class=\"comment\">// 调度器开始调度任务</span></span><br><span class=\"line\">  scheduler.start();</span><br></pre></td></tr></table></figure>\n<p>上面代码是demo一个片段，可以看出这里运用了工厂模式，通过factory类（<code>StdSchedulerFactory</code>）生产出scheduler实例（<code>StdScheduler</code>）。scheduler是整个quartz的关键，为此，笔者把demo中用到的scheduler接口的源码加上中文注释做个讲解。</p>\n<ul>\n<li><code>StdSchedulerFactory.getScheduler()</code>源码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Scheduler <span class=\"title\">getScheduler</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件</span></span><br><span class=\"line\">        <span class=\"comment\">// 解析出quartz配置内容和环境变量，存入PropertiesParser对象</span></span><br><span class=\"line\">        <span class=\"comment\">// PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cfg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            initialize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 获取调度器池，采用了单例模式</span></span><br><span class=\"line\">        <span class=\"comment\">// 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例</span></span><br><span class=\"line\">        <span class=\"comment\">// getInstance()用synchronized防止并发创建</span></span><br><span class=\"line\">        SchedulerRepository schedRep = SchedulerRepository.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从调度器池中取出当前配置所用的调度器</span></span><br><span class=\"line\">        Scheduler sched = schedRep.lookup(getSchedulerName());</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；</span></span><br><span class=\"line\">        <span class=\"comment\">// 2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；</span></span><br><span class=\"line\">        <span class=\"comment\">// 3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；</span></span><br><span class=\"line\">        <span class=\"comment\">// 4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；</span></span><br><span class=\"line\">        <span class=\"comment\">// 5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；</span></span><br><span class=\"line\">        <span class=\"comment\">// 6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；</span></span><br><span class=\"line\">        <span class=\"comment\">// 7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；</span></span><br><span class=\"line\">        <span class=\"comment\">// 8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中</span></span><br><span class=\"line\">        sched = instantiate();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sched;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面有个过程是初始化jobStore，表示使用哪种方式存储scheduler相关数据。quartz有两大jobStore：<code>RAMJobStore和JDBCJobStore</code>。<code>RAMJobStore</code>把数据存入内存，性能最高，配置也简单，但缺点是系统挂了难以恢复数据。<code>JDBCJobStore</code>保存数据到数据库，保证数据的可恢复性，但性能较差且配置复杂。</p>\n<ul>\n<li><p><code>QuartzScheduler.scheduleJob(JobDetail, Trigger)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">scheduleJob</span><span class=\"params\">(JobDetail jobDetail,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Trigger trigger)</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查调度器是否开启，如果关闭则throw异常到上层</span></span><br><span class=\"line\">        validateState();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 获取trigger首次触发job的时间，以此时间为起点，每隔一段指定的时间触发job</span></span><br><span class=\"line\">        Date ft = trig.computeFirstFireTime(cal);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ft == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SchedulerException(</span><br><span class=\"line\">                    <span class=\"string\">\"Based on configured schedule, the given trigger '\"</span> + trigger.getKey() + <span class=\"string\">\"' will never fire.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把job和trigger注册进调度器的jobStore</span></span><br><span class=\"line\">        resources.getJobStore().storeJobAndTrigger(jobDetail, trig);</span><br><span class=\"line\">        <span class=\"comment\">// 通知job监听者</span></span><br><span class=\"line\">        notifySchedulerListenersJobAdded(jobDetail);                </span><br><span class=\"line\">        <span class=\"comment\">// 通知调度器线程</span></span><br><span class=\"line\">        notifySchedulerThread(trigger.getNextFireTime().getTime());</span><br><span class=\"line\">        <span class=\"comment\">// 通知trigger监听者</span></span><br><span class=\"line\">        notifySchedulerListenersSchduled(trigger);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ft;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>QuartzScheduler.start()</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这句最关键，作用是使调度器线程跳出一个无限循环，开始轮询所有trigger触发job</span></span><br><span class=\"line\">        <span class=\"comment\">// 原理详见“如何采用多线程进行任务调度”</span></span><br><span class=\"line\">        schedThread.togglePause(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"先看一个简单的Demo\"><a href=\"#先看一个简单的Demo\" class=\"headerlink\" title=\"先看一个简单的Demo\"></a>先看一个简单的Demo</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JobImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Job</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(JobExecutionContext context)</span> <span class=\"keyword\">throws</span> JobExecutionException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"job impl running\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestQuartz</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> SchedulerException, InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建调度器</span></span><br><span class=\"line\">        SchedulerFactory schedulerFactory = <span class=\"keyword\">new</span> StdSchedulerFactory();</span><br><span class=\"line\">        Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建任务</span></span><br><span class=\"line\">        JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(<span class=\"string\">\"myJob\"</span>, <span class=\"string\">\"jobGroup\"</span>).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建触发器</span></span><br><span class=\"line\">        <span class=\"comment\">// withIntervalInSeconds(2)表示每隔2s执行任务</span></span><br><span class=\"line\">        Date triggerDate = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class=\"number\">2</span>).repeatForever();</span><br><span class=\"line\">        TriggerBuilder&lt;Trigger&gt; triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(<span class=\"string\">\"myTrigger\"</span>, <span class=\"string\">\"triggerGroup\"</span>);</span><br><span class=\"line\">        Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将任务及其触发器放入调度器</span></span><br><span class=\"line\">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class=\"line\">        <span class=\"comment\">// 调度器开始调度任务</span></span><br><span class=\"line\">        scheduler.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>quartz.properties</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#调度器名，默认名是QuartzScheduler</span><br><span class=\"line\">org.quartz.scheduler.instanceName= TestQuartzScheduler</span><br><span class=\"line\"></span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure ThreadPool   配置线程池</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">org.quartz.threadPool.class= org.quartz.simpl.SimpleThreadPool</span><br><span class=\"line\">org.quartz.threadPool.threadCount= 10</span><br><span class=\"line\">org.quartz.threadPool.threadPriority= 5</span><br><span class=\"line\"></span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\"># Configure JobStore  配置任务存储方式</span><br><span class=\"line\">#============================================================================</span><br><span class=\"line\">#相当于扫描频率</span><br><span class=\"line\">org.quartz.jobStore.misfireThreshold= 60000</span><br><span class=\"line\">org.quartz.jobStore.class= org.quartz.simpl.RAMJobStore</span><br></pre></td></tr></table></figure></p>\n<p><code>TestQuartz.main()</code>依次创建了<code>scheduler</code>（调度器）、<code>job</code>（任务）、<code>trigger</code>（触发器），其中，<code>job</code>指定了<code>JobImpl</code>，<code>trigger</code>保存<code>job</code>的触发执行策略（每隔2s执行一次），<code>scheduler</code>将<code>job</code>和<code>trigger</code>绑定在一起，最后<code>scheduler.start()</code>启动调度，每隔2s触发执行<code>JobImpl.execute()</code>，打印出job impl running。</p>\n<p>对于<code>quartz.properties</code>，简单场景下，开发者不用自定义配置，使用<code>quartz</code>默认配置即可，但在要求较高的使用场景中还是要自定义配置，比如通过<code>org.quartz.threadPool.threadCount</code>设置足够的线程数可提高多job场景下的运行性能。更详尽的配置见<a href=\"http://www.quartz-scheduler.org/documentation/quartz-2.1.x/configuration/\" target=\"_blank\" rel=\"noopener\">官网配置说明页</a>。</p>\n<h3 id=\"job（任务）\"><a href=\"#job（任务）\" class=\"headerlink\" title=\"job（任务）\"></a>job（任务）</h3><p>job由若干个<code>class</code>和<code>interface</code>实现。</p>\n<h4 id=\"Job接口\"><a href=\"#Job接口\" class=\"headerlink\" title=\"Job接口\"></a>Job接口</h4><p>开发者想要<code>job</code>完成什么样的功能，必须且只能由开发者自己动手来编写实现，比如demo中的<code>JobImpl</code>，这点无容置疑。但要想让自己的<code>job</code>被<code>quartz</code>识别，就必须按照<code>quartz</code>的规则来办事，这个规则就是<code>job</code>实现类必须实现Job接口，比如<code>JobImpl</code>就实现了Job。</p>\n<p>Job只有一个<code>execute(JobExecutionContext)</code>，<code>JobExecutionContext</code>保存了<code>job</code>的上下文信息，比如绑定的是哪个<code>trigger</code>。<code>job</code>实现类必须重写<code>execute()</code>，执行job实际上就是运行<code>execute()</code>。</p>\n<h4 id=\"JobDetailImpl类-JobDetail接口\"><a href=\"#JobDetailImpl类-JobDetail接口\" class=\"headerlink\" title=\"JobDetailImpl类 / JobDetail接口\"></a>JobDetailImpl类 / JobDetail接口</h4><p><code>JobDetailImpl</code>类实现了<code>JobDetail</code>接口，用来描述一个job，定义了job所有属性及其get/set方法。了解job拥有哪些属性，就能知道quartz能提供什么样的能力，下面笔者用表格列出job若干核心属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>class</td>\n<td>必须是job实现类（比如<code>JobImpl</code>），用来绑定一个具体job</td>\n</tr>\n<tr>\n<td>name</td>\n<td>job名称。如果未指定，会自动分配一个唯一名称。所有job都必须拥有一个唯一name，如果两个job的name重复，则只有最前面的job能被调度</td>\n</tr>\n<tr>\n<td>group</td>\n<td>job所属的组名</td>\n</tr>\n<tr>\n<td>description</td>\n<td>job描述</td>\n</tr>\n<tr>\n<td>durability</td>\n<td>是否持久化。如果job设置为非持久，当没有活跃的trigger与之关联的时候，job会自动从scheduler中删除。也就是说，非持久job的生命期是由trigger的存在与否决定的</td>\n</tr>\n<tr>\n<td>shouldRecover</td>\n<td>是否可恢复。如果job设置为可恢复，一旦job执行时scheduler发生hard shutdown（比如进程崩溃或关机），当scheduler重启后，该job会被重新执行</td>\n</tr>\n<tr>\n<td>jobDataMap</td>\n<td>除了上面常规属性外，用户可以把任意kv数据存入jobDataMap，实现job属性的无限制扩展，执行job时可以使用这些属性数据。此属性的类型是<code>JobDataMap</code>，实现了<code>Serializable</code>接口，可做跨平台的序列化传输</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"JobBuilder类\"><a href=\"#JobBuilder类\" class=\"headerlink\" title=\"JobBuilder类\"></a>JobBuilder类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务</span></span><br><span class=\"line\">JobDetail jobDetail = JobBuilder.newJob(JobImpl.class).withIdentity(<span class=\"string\">\"myJob\"</span>, <span class=\"string\">\"jobGroup\"</span>).build();</span><br></pre></td></tr></table></figure>\n<p>上面代码是demo一个片段，可以看出<code>JobBuilder</code>类的作用：接收job实现类<code>JobImpl</code>，生成<code>JobDetail</code>实例，默认生成<code>JobDetailImpl</code>实例。</p>\n<p>这里运用了建造者模式：<code>JobImpl</code>相当于Product；<code>JobDetail</code>相当于Builder，拥有job的各种属性及其get/set方法；<code>JobBuilder</code>相当于Director，可为一个job组装各种属性。</p>\n<h3 id=\"trigger（触发器）\"><a href=\"#trigger（触发器）\" class=\"headerlink\" title=\"trigger（触发器）\"></a>trigger（触发器）</h3><p>trigger由若干个class和interface实现。</p>\n<h4 id=\"SimpleTriggerImpl类-SimpleTrigger接口-Trigger接口\"><a href=\"#SimpleTriggerImpl类-SimpleTrigger接口-Trigger接口\" class=\"headerlink\" title=\"SimpleTriggerImpl类 / SimpleTrigger接口 / Trigger接口\"></a>SimpleTriggerImpl类 / SimpleTrigger接口 / Trigger接口</h4><p><code>SimpleTriggerImpl</code>类实现了<code>SimpleTrigger</code>接口，<code>SimpleTrigger</code>接口继承了<code>Trigger</code>接口，它们表示触发器，用来保存触发job的策略，比如每隔几秒触发job。实际上，quartz有两大触发器：<code>SimpleTrigger</code>和<code>CronTrigger</code></p>\n<p>Trigger诸类保存了trigger所有属性，同job属性一样，了解trigger属性有助于我们了解quartz能提供什么样的能力，下面笔者用表格列出trigger若干核心属性。</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>属性类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>所有trigger通用</td>\n<td>trigger名称</td>\n</tr>\n<tr>\n<td>group</td>\n<td>所有trigger通用</td>\n<td>trigger所属的组名</td>\n</tr>\n<tr>\n<td>description</td>\n<td>所有trigger通用</td>\n<td>trigger描述</td>\n</tr>\n<tr>\n<td>calendarName</td>\n<td>所有trigger通用</td>\n<td>日历名称，指定使用哪个Calendar类，经常用来从trigger的调度计划中排除某些时间段</td>\n</tr>\n<tr>\n<td>misfireInstruction</td>\n<td>所有trigger通用</td>\n<td>错过job（未在指定时间执行的job）的处理策略，默认为<code>MISFIRE_INSTRUCTION_SMART_POLICY</code>。</td>\n</tr>\n<tr>\n<td>priority</td>\n<td>所有trigger通用</td>\n<td>优先级，默认为5。当多个trigger同时触发job时，线程池可能不够用，此时根据优先级来决定谁先触发</td>\n</tr>\n<tr>\n<td>jobDataMap</td>\n<td>所有trigger通用</td>\n<td>同job的jobDataMap。假如job和trigger的jobDataMap有同名key，通过<code>getMergedJobDataMap()</code>获取的jobDataMap，将以trigger的为准</td>\n</tr>\n<tr>\n<td>startTime</td>\n<td>所有trigger通用</td>\n<td>触发开始时间，默认为当前时间。决定什么时间开始触发job</td>\n</tr>\n<tr>\n<td>endTime</td>\n<td>所有trigger通用</td>\n<td>触发结束时间。决定什么时间停止触发job</td>\n</tr>\n<tr>\n<td>nextFireTime</td>\n<td>SimpleTrigger私有</td>\n<td>下一次触发job的时间</td>\n</tr>\n<tr>\n<td>previousFireTime</td>\n<td>SimpleTrigger私有</td>\n<td>上一次触发job的时间</td>\n</tr>\n<tr>\n<td>repeatCount</td>\n<td>SimpleTrigger私有</td>\n<td>需触发的总次数</td>\n</tr>\n<tr>\n<td>timesTriggered</td>\n<td>SimpleTrigger私有</td>\n<td>已经触发过的次数</td>\n</tr>\n<tr>\n<td>repeatInterval</td>\n<td>SimpleTrigger私有</td>\n<td>触发间隔时间</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"TriggerBuilder类\"><a href=\"#TriggerBuilder类\" class=\"headerlink\" title=\"TriggerBuilder类\"></a>TriggerBuilder类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建触发器</span></span><br><span class=\"line\"><span class=\"comment\">// withIntervalInSeconds(2)表示每隔2s执行任务</span></span><br><span class=\"line\">  Date triggerDate = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">  SimpleScheduleBuilder schedBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class=\"number\">2</span>).repeatForever();</span><br><span class=\"line\">  TriggerBuilder&lt;Trigger&gt; triggerBuilder  = TriggerBuilder.newTrigger().withIdentity(<span class=\"string\">\"myTrigger\"</span>, <span class=\"string\">\"triggerGroup\"</span>);</span><br><span class=\"line\">  Trigger trigger = triggerBuilder.startAt(triggerDate).withSchedule(schedBuilder).build();</span><br></pre></td></tr></table></figure>\n<p>上面代码是demo一个片段，可以看出<code>TriggerBuilder</code>类的作用：生成Trigger实例，默认生成<code>SimpleTriggerImpl</code>实例。同<code>JobBuilder</code>一样，这里也运用了建造者模式。</p>\n<h3 id=\"scheduler（调度器）\"><a href=\"#scheduler（调度器）\" class=\"headerlink\" title=\"scheduler（调度器）\"></a>scheduler（调度器）</h3><p>scheduler主要由<code>StdScheduler类</code>、<code>Scheduler接口</code>、<code>StdSchedulerFactory类</code>、<code>SchedulerFactory接口</code>、<code>QuartzScheduler类</code>实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建调度器</span></span><br><span class=\"line\">  SchedulerFactory schedulerFactory = <span class=\"keyword\">new</span> StdSchedulerFactory();</span><br><span class=\"line\">  Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"comment\">// 将任务及其触发器放入调度器</span></span><br><span class=\"line\">  scheduler.scheduleJob(jobDetail, trigger);</span><br><span class=\"line\"><span class=\"comment\">// 调度器开始调度任务</span></span><br><span class=\"line\">  scheduler.start();</span><br></pre></td></tr></table></figure>\n<p>上面代码是demo一个片段，可以看出这里运用了工厂模式，通过factory类（<code>StdSchedulerFactory</code>）生产出scheduler实例（<code>StdScheduler</code>）。scheduler是整个quartz的关键，为此，笔者把demo中用到的scheduler接口的源码加上中文注释做个讲解。</p>\n<ul>\n<li><code>StdSchedulerFactory.getScheduler()</code>源码<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Scheduler <span class=\"title\">getScheduler</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取quartz配置文件，未指定则顺序遍历各个path下的quartz.properties文件</span></span><br><span class=\"line\">        <span class=\"comment\">// 解析出quartz配置内容和环境变量，存入PropertiesParser对象</span></span><br><span class=\"line\">        <span class=\"comment\">// PropertiesParser组合了Properties（继承Hashtable），定义了一系列对Properties的操作方法，比如getPropertyGroup()批量获取相同前缀的配置。配置内容和环境变量存放在Properties成员变量中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cfg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            initialize();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 获取调度器池，采用了单例模式</span></span><br><span class=\"line\">        <span class=\"comment\">// 其实，调度器池的核心变量就是一个hashmap，每个元素key是scheduler名，value是scheduler实例</span></span><br><span class=\"line\">        <span class=\"comment\">// getInstance()用synchronized防止并发创建</span></span><br><span class=\"line\">        SchedulerRepository schedRep = SchedulerRepository.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从调度器池中取出当前配置所用的调度器</span></span><br><span class=\"line\">        Scheduler sched = schedRep.lookup(getSchedulerName());</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果调度器池中没有当前配置的调度器，则实例化一个调度器，主要动作包括：</span></span><br><span class=\"line\">        <span class=\"comment\">// 1）初始化threadPool(线程池)：开发者可以通过org.quartz.threadPool.class配置指定使用哪个线程池类，比如SimpleThreadPool。先class load线程池类，接着动态生成线程池实例bean，然后通过反射，使用setXXX()方法将以org.quartz.threadPool开头的配置内容赋值给bean成员变量；</span></span><br><span class=\"line\">        <span class=\"comment\">// 2）初始化jobStore(任务存储方式)：开发者可以通过org.quartz.jobStore.class配置指定使用哪个任务存储类，比如RAMJobStore。先class load任务存储类，接着动态生成实例bean，然后通过反射，使用setXXX()方法将以org.quartz.jobStore开头的配置内容赋值给bean成员变量；</span></span><br><span class=\"line\">        <span class=\"comment\">// 3）初始化dataSource(数据源)：开发者可以通过org.quartz.dataSource配置指定数据源详情，比如哪个数据库、账号、密码等。jobStore要指定为JDBCJobStore，dataSource才会有效；</span></span><br><span class=\"line\">        <span class=\"comment\">// 4）初始化其他配置：包括SchedulerPlugins、JobListeners、TriggerListeners等；</span></span><br><span class=\"line\">        <span class=\"comment\">// 5）初始化threadExecutor(线程执行器)：默认为DefaultThreadExecutor；</span></span><br><span class=\"line\">        <span class=\"comment\">// 6）创建工作线程：根据配置创建N个工作thread，执行start()启动thread，并将N个thread顺序add进threadPool实例的空闲线程列表availWorkers中；</span></span><br><span class=\"line\">        <span class=\"comment\">// 7）创建调度器线程：创建QuartzSchedulerThread实例，并通过threadExecutor.execute(实例)启动调度器线程；</span></span><br><span class=\"line\">        <span class=\"comment\">// 8）创建调度器：创建StdScheduler实例，将上面所有配置和引用组合进实例中，并将实例存入调度器池中</span></span><br><span class=\"line\">        sched = instantiate();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sched;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面有个过程是初始化jobStore，表示使用哪种方式存储scheduler相关数据。quartz有两大jobStore：<code>RAMJobStore和JDBCJobStore</code>。<code>RAMJobStore</code>把数据存入内存，性能最高，配置也简单，但缺点是系统挂了难以恢复数据。<code>JDBCJobStore</code>保存数据到数据库，保证数据的可恢复性，但性能较差且配置复杂。</p>\n<ul>\n<li><p><code>QuartzScheduler.scheduleJob(JobDetail, Trigger)</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">scheduleJob</span><span class=\"params\">(JobDetail jobDetail,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Trigger trigger)</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查调度器是否开启，如果关闭则throw异常到上层</span></span><br><span class=\"line\">        validateState();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 获取trigger首次触发job的时间，以此时间为起点，每隔一段指定的时间触发job</span></span><br><span class=\"line\">        Date ft = trig.computeFirstFireTime(cal);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ft == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SchedulerException(</span><br><span class=\"line\">                    <span class=\"string\">\"Based on configured schedule, the given trigger '\"</span> + trigger.getKey() + <span class=\"string\">\"' will never fire.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 把job和trigger注册进调度器的jobStore</span></span><br><span class=\"line\">        resources.getJobStore().storeJobAndTrigger(jobDetail, trig);</span><br><span class=\"line\">        <span class=\"comment\">// 通知job监听者</span></span><br><span class=\"line\">        notifySchedulerListenersJobAdded(jobDetail);                </span><br><span class=\"line\">        <span class=\"comment\">// 通知调度器线程</span></span><br><span class=\"line\">        notifySchedulerThread(trigger.getNextFireTime().getTime());</span><br><span class=\"line\">        <span class=\"comment\">// 通知trigger监听者</span></span><br><span class=\"line\">        notifySchedulerListenersSchduled(trigger);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ft;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>QuartzScheduler.start()</code>源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这句最关键，作用是使调度器线程跳出一个无限循环，开始轮询所有trigger触发job</span></span><br><span class=\"line\">        <span class=\"comment\">// 原理详见“如何采用多线程进行任务调度”</span></span><br><span class=\"line\">        schedThread.togglePause(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"Scheduler","date":"2017-11-27T02:33:22.000Z","description":"目前的 Web 应用，多数应用都具备任务调度的功能。本系列大致介绍了几种任务调度的 Java 实现方法，包括 Timer,Scheduler, Quartz 以及 JCron Tab，并对其优缺点进行比较","_content":"\n## ScheduledExecutor\n### jdk 所实现的 taskScheduler\nScheduledExecutor。设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。需 要注意的是，只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。\n\n```java\npublic class ScheduledExecutorTest implements Runnable{\n    private String jobName = \"\";\n\n    public ScheduledExecutorTest(String jobName) {\n        super();\n        this.jobName = jobName;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"execute \" + jobName);\n    }\n}\n```\n```java\npublic class MainExecute {\n    public static void main(String[] args) {\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(10);\n\n        long initialDelay1 = 1;\n        long period1 = 1;\n        // 从现在开始1秒钟之后，每隔1秒钟执行一次job1\n        service.scheduleAtFixedRate(\n                new ScheduledExecutorTest(\"job1\"), initialDelay1,\n                period1, TimeUnit.SECONDS);\n\n        long initialDelay2 = 1;\n        long delay2 = 1;\n        // 从现在开始2秒钟之后，每隔2秒钟执行一次job2\n        service.scheduleWithFixedDelay(\n                new ScheduledExecutorTest(\"job2\"), initialDelay2,\n                delay2, TimeUnit.SECONDS);\n    }\n}\n```\n### Spring 所实现的 taskScheduler\n#### 核心类\n* `ScheduledAnnotationBeanPostProcessor`\n* `ScheduledTaskRegistrar`\n* `TaskScheduler`\n* `ReschedulingRunnable`\n\n#### 主要方法\nScheduledAnnotationBeanPostProcessor核心方法：\n* `postProcessAfterInitialization`负责@Schedule注解的扫描，构建ScheduleTask\n* `onApplicationEvent`spring容器加载完毕之后调用，ScheduleTask向ScheduledTaskRegistrar中注册, 调用ScheduledTaskRegistrar.afterPropertiesSet() \n\nScheduledTaskRegistrar核心方法：\n* `afterPropertiesSet`初始化所有定时器，启动定时器\n\nTaskScheduler作用及核心方法：\n\n* 主要的实现类有三个ThreadPoolTaskScheduler,ConcurrentTaskScheduler,TimerManagerTaskScheduler\n* 作用：这些类的作用主要是将`task`和`executor`用`ReschedulingRunnable`包装起来进行生命周期管理。 \n* 核心方法：`ScheduledFuture schedule`\n\nReschedulingRunnable核心方法：\n* `schedule()`\n* `run()`\n\n使用demo\n```java\n@Configuration\npublic class TaskConf {\n    @Bean\n    public ThreadPoolTaskScheduler initThreadPool() {\n        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();\n        taskScheduler.setPoolSize(20);\n        taskScheduler.initialize();\n        return taskScheduler;\n    }\n}\n```\n```java\npublic class TaskService implements Runnable {\n\n    protected Logger log = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private LockRegistry lockRegistry;\n\n    @Autowired()\n    private ThreadPoolTaskScheduler threadPoolTaskScheduler;\n\n    private String jobName;\n\n    public void setJobName(String jobName) {\n        this.jobName = jobName;\n    }\n\n    public String getLockKey(String key) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(TaskService.class.getName())\n           .append(\"/\").append(key).append(\"111\");\n        return buf.toString();\n    }\n\n\n    public void start(Date date) {\n        threadPoolTaskScheduler.schedule(this, date);\n    }\n\n\n    @Override\n    public void run() {\n        String lockKey = getLockKey(jobName);\n        long waitLockTime = 1000;\n        Lock lock = lockRegistry.obtain(lockKey);\n        try {\n            if (!lock.tryLock(waitLockTime, TimeUnit.MILLISECONDS)) {\n                log.info(\"加锁失败，任务中止\");\n                return;\n            }\n        } catch (InterruptedException e) {\n            log.warn(\"在等待加锁时被中止\", e);\n            return;\n        }\n        try {\n            System.out.println(\"execute \" + jobName);\n        } catch (Exception e) {\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n```java\n    taskService.setJobName(\"111\");\n    Date runTime = new Date(order.getDateCreated().getTime() + 30 * 60 * 1000);\n    taskService.start(runTime);\n```\n其实这里用的还是`java.util.concurrent`的`ScheduledExecutorService`看下面的源码就明白了\n```java\n@Override\n\tpublic ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {\n\t\tScheduledExecutorService executor = getScheduledExecutor();\n\t\ttry {\n\t\t\tErrorHandler errorHandler =\n\t\t\t\t\t(this.errorHandler != null ? this.errorHandler : TaskUtils.getDefaultErrorHandler(true));\n\t\t\treturn new ReschedulingRunnable(task, trigger, executor, errorHandler).schedule();\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(\"Executor [\" + executor + \"] did not accept task: \" + task, ex);\n\t\t}\n\t}\n```\n","source":"_posts/Java/taskScheduler/Scheduler.md","raw":"---\ntitle: Scheduler\ndate: 2017-11-27 10:33:22\ncategories: TaskScheduler\ntags: [Java,Task]\ndescription: 目前的 Web 应用，多数应用都具备任务调度的功能。本系列大致介绍了几种任务调度的 Java 实现方法，包括 Timer,Scheduler, Quartz 以及 JCron Tab，并对其优缺点进行比较\n---\n\n## ScheduledExecutor\n### jdk 所实现的 taskScheduler\nScheduledExecutor。设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。需 要注意的是，只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。\n\n```java\npublic class ScheduledExecutorTest implements Runnable{\n    private String jobName = \"\";\n\n    public ScheduledExecutorTest(String jobName) {\n        super();\n        this.jobName = jobName;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"execute \" + jobName);\n    }\n}\n```\n```java\npublic class MainExecute {\n    public static void main(String[] args) {\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(10);\n\n        long initialDelay1 = 1;\n        long period1 = 1;\n        // 从现在开始1秒钟之后，每隔1秒钟执行一次job1\n        service.scheduleAtFixedRate(\n                new ScheduledExecutorTest(\"job1\"), initialDelay1,\n                period1, TimeUnit.SECONDS);\n\n        long initialDelay2 = 1;\n        long delay2 = 1;\n        // 从现在开始2秒钟之后，每隔2秒钟执行一次job2\n        service.scheduleWithFixedDelay(\n                new ScheduledExecutorTest(\"job2\"), initialDelay2,\n                delay2, TimeUnit.SECONDS);\n    }\n}\n```\n### Spring 所实现的 taskScheduler\n#### 核心类\n* `ScheduledAnnotationBeanPostProcessor`\n* `ScheduledTaskRegistrar`\n* `TaskScheduler`\n* `ReschedulingRunnable`\n\n#### 主要方法\nScheduledAnnotationBeanPostProcessor核心方法：\n* `postProcessAfterInitialization`负责@Schedule注解的扫描，构建ScheduleTask\n* `onApplicationEvent`spring容器加载完毕之后调用，ScheduleTask向ScheduledTaskRegistrar中注册, 调用ScheduledTaskRegistrar.afterPropertiesSet() \n\nScheduledTaskRegistrar核心方法：\n* `afterPropertiesSet`初始化所有定时器，启动定时器\n\nTaskScheduler作用及核心方法：\n\n* 主要的实现类有三个ThreadPoolTaskScheduler,ConcurrentTaskScheduler,TimerManagerTaskScheduler\n* 作用：这些类的作用主要是将`task`和`executor`用`ReschedulingRunnable`包装起来进行生命周期管理。 \n* 核心方法：`ScheduledFuture schedule`\n\nReschedulingRunnable核心方法：\n* `schedule()`\n* `run()`\n\n使用demo\n```java\n@Configuration\npublic class TaskConf {\n    @Bean\n    public ThreadPoolTaskScheduler initThreadPool() {\n        ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();\n        taskScheduler.setPoolSize(20);\n        taskScheduler.initialize();\n        return taskScheduler;\n    }\n}\n```\n```java\npublic class TaskService implements Runnable {\n\n    protected Logger log = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private LockRegistry lockRegistry;\n\n    @Autowired()\n    private ThreadPoolTaskScheduler threadPoolTaskScheduler;\n\n    private String jobName;\n\n    public void setJobName(String jobName) {\n        this.jobName = jobName;\n    }\n\n    public String getLockKey(String key) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(TaskService.class.getName())\n           .append(\"/\").append(key).append(\"111\");\n        return buf.toString();\n    }\n\n\n    public void start(Date date) {\n        threadPoolTaskScheduler.schedule(this, date);\n    }\n\n\n    @Override\n    public void run() {\n        String lockKey = getLockKey(jobName);\n        long waitLockTime = 1000;\n        Lock lock = lockRegistry.obtain(lockKey);\n        try {\n            if (!lock.tryLock(waitLockTime, TimeUnit.MILLISECONDS)) {\n                log.info(\"加锁失败，任务中止\");\n                return;\n            }\n        } catch (InterruptedException e) {\n            log.warn(\"在等待加锁时被中止\", e);\n            return;\n        }\n        try {\n            System.out.println(\"execute \" + jobName);\n        } catch (Exception e) {\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n```java\n    taskService.setJobName(\"111\");\n    Date runTime = new Date(order.getDateCreated().getTime() + 30 * 60 * 1000);\n    taskService.start(runTime);\n```\n其实这里用的还是`java.util.concurrent`的`ScheduledExecutorService`看下面的源码就明白了\n```java\n@Override\n\tpublic ScheduledFuture<?> schedule(Runnable task, Trigger trigger) {\n\t\tScheduledExecutorService executor = getScheduledExecutor();\n\t\ttry {\n\t\t\tErrorHandler errorHandler =\n\t\t\t\t\t(this.errorHandler != null ? this.errorHandler : TaskUtils.getDefaultErrorHandler(true));\n\t\t\treturn new ReschedulingRunnable(task, trigger, executor, errorHandler).schedule();\n\t\t}\n\t\tcatch (RejectedExecutionException ex) {\n\t\t\tthrow new TaskRejectedException(\"Executor [\" + executor + \"] did not accept task: \" + task, ex);\n\t\t}\n\t}\n```\n","slug":"Java/taskScheduler/Scheduler","published":1,"updated":"2017-12-15T08:12:58.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqi001g6dofyqiv2cpj","content":"<h2 id=\"ScheduledExecutor\"><a href=\"#ScheduledExecutor\" class=\"headerlink\" title=\"ScheduledExecutor\"></a>ScheduledExecutor</h2><h3 id=\"jdk-所实现的-taskScheduler\"><a href=\"#jdk-所实现的-taskScheduler\" class=\"headerlink\" title=\"jdk 所实现的 taskScheduler\"></a>jdk 所实现的 taskScheduler</h3><p>ScheduledExecutor。设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。需 要注意的是，只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduledExecutorTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jobName = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledExecutorTest</span><span class=\"params\">(String jobName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jobName = jobName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"execute \"</span> + jobName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainExecute</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> initialDelay1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始1秒钟之后，每隔1秒钟执行一次job1</span></span><br><span class=\"line\">        service.scheduleAtFixedRate(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ScheduledExecutorTest(<span class=\"string\">\"job1\"</span>), initialDelay1,</span><br><span class=\"line\">                period1, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> initialDelay2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始2秒钟之后，每隔2秒钟执行一次job2</span></span><br><span class=\"line\">        service.scheduleWithFixedDelay(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ScheduledExecutorTest(<span class=\"string\">\"job2\"</span>), initialDelay2,</span><br><span class=\"line\">                delay2, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Spring-所实现的-taskScheduler\"><a href=\"#Spring-所实现的-taskScheduler\" class=\"headerlink\" title=\"Spring 所实现的 taskScheduler\"></a>Spring 所实现的 taskScheduler</h3><h4 id=\"核心类\"><a href=\"#核心类\" class=\"headerlink\" title=\"核心类\"></a>核心类</h4><ul>\n<li><code>ScheduledAnnotationBeanPostProcessor</code></li>\n<li><code>ScheduledTaskRegistrar</code></li>\n<li><code>TaskScheduler</code></li>\n<li><code>ReschedulingRunnable</code></li>\n</ul>\n<h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><p>ScheduledAnnotationBeanPostProcessor核心方法：</p>\n<ul>\n<li><code>postProcessAfterInitialization</code>负责@Schedule注解的扫描，构建ScheduleTask</li>\n<li><code>onApplicationEvent</code>spring容器加载完毕之后调用，ScheduleTask向ScheduledTaskRegistrar中注册, 调用ScheduledTaskRegistrar.afterPropertiesSet() </li>\n</ul>\n<p>ScheduledTaskRegistrar核心方法：</p>\n<ul>\n<li><code>afterPropertiesSet</code>初始化所有定时器，启动定时器</li>\n</ul>\n<p>TaskScheduler作用及核心方法：</p>\n<ul>\n<li>主要的实现类有三个ThreadPoolTaskScheduler,ConcurrentTaskScheduler,TimerManagerTaskScheduler</li>\n<li>作用：这些类的作用主要是将<code>task</code>和<code>executor</code>用<code>ReschedulingRunnable</code>包装起来进行生命周期管理。 </li>\n<li>核心方法：<code>ScheduledFuture schedule</code></li>\n</ul>\n<p>ReschedulingRunnable核心方法：</p>\n<ul>\n<li><code>schedule()</code></li>\n<li><code>run()</code></li>\n</ul>\n<p>使用demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskConf</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ThreadPoolTaskScheduler <span class=\"title\">initThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ThreadPoolTaskScheduler taskScheduler = <span class=\"keyword\">new</span> ThreadPoolTaskScheduler();</span><br><span class=\"line\">        taskScheduler.setPoolSize(<span class=\"number\">20</span>);</span><br><span class=\"line\">        taskScheduler.initialize();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> taskScheduler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskService</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LockRegistry lockRegistry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadPoolTaskScheduler threadPoolTaskScheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jobName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setJobName</span><span class=\"params\">(String jobName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jobName = jobName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLockKey</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder buf = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        buf.append(TaskService.class.getName())</span><br><span class=\"line\">           .append(<span class=\"string\">\"/\"</span>).append(key).append(<span class=\"string\">\"111\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Date date)</span> </span>&#123;</span><br><span class=\"line\">        threadPoolTaskScheduler.schedule(<span class=\"keyword\">this</span>, date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String lockKey = getLockKey(jobName);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waitLockTime = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        Lock lock = lockRegistry.obtain(lockKey);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!lock.tryLock(waitLockTime, TimeUnit.MILLISECONDS)) &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">\"加锁失败，任务中止\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">\"在等待加锁时被中止\"</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"execute \"</span> + jobName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskService.setJobName(<span class=\"string\">\"111\"</span>);</span><br><span class=\"line\">Date runTime = <span class=\"keyword\">new</span> Date(order.getDateCreated().getTime() + <span class=\"number\">30</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">taskService.start(runTime);</span><br></pre></td></tr></table></figure>\n<p>其实这里用的还是<code>java.util.concurrent</code>的<code>ScheduledExecutorService</code>看下面的源码就明白了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger) &#123;</span><br><span class=\"line\">\t\tScheduledExecutorService executor = getScheduledExecutor();</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tErrorHandler errorHandler =</span><br><span class=\"line\">\t\t\t\t\t(<span class=\"keyword\">this</span>.errorHandler != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.errorHandler : TaskUtils.getDefaultErrorHandler(<span class=\"keyword\">true</span>));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReschedulingRunnable(task, trigger, executor, errorHandler).schedule();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TaskRejectedException(<span class=\"string\">\"Executor [\"</span> + executor + <span class=\"string\">\"] did not accept task: \"</span> + task, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ScheduledExecutor\"><a href=\"#ScheduledExecutor\" class=\"headerlink\" title=\"ScheduledExecutor\"></a>ScheduledExecutor</h2><h3 id=\"jdk-所实现的-taskScheduler\"><a href=\"#jdk-所实现的-taskScheduler\" class=\"headerlink\" title=\"jdk 所实现的 taskScheduler\"></a>jdk 所实现的 taskScheduler</h3><p>ScheduledExecutor。设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。需 要注意的是，只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduledExecutorTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jobName = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledExecutorTest</span><span class=\"params\">(String jobName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jobName = jobName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"execute \"</span> + jobName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainExecute</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> initialDelay1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> period1 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始1秒钟之后，每隔1秒钟执行一次job1</span></span><br><span class=\"line\">        service.scheduleAtFixedRate(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ScheduledExecutorTest(<span class=\"string\">\"job1\"</span>), initialDelay1,</span><br><span class=\"line\">                period1, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> initialDelay2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从现在开始2秒钟之后，每隔2秒钟执行一次job2</span></span><br><span class=\"line\">        service.scheduleWithFixedDelay(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ScheduledExecutorTest(<span class=\"string\">\"job2\"</span>), initialDelay2,</span><br><span class=\"line\">                delay2, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Spring-所实现的-taskScheduler\"><a href=\"#Spring-所实现的-taskScheduler\" class=\"headerlink\" title=\"Spring 所实现的 taskScheduler\"></a>Spring 所实现的 taskScheduler</h3><h4 id=\"核心类\"><a href=\"#核心类\" class=\"headerlink\" title=\"核心类\"></a>核心类</h4><ul>\n<li><code>ScheduledAnnotationBeanPostProcessor</code></li>\n<li><code>ScheduledTaskRegistrar</code></li>\n<li><code>TaskScheduler</code></li>\n<li><code>ReschedulingRunnable</code></li>\n</ul>\n<h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><p>ScheduledAnnotationBeanPostProcessor核心方法：</p>\n<ul>\n<li><code>postProcessAfterInitialization</code>负责@Schedule注解的扫描，构建ScheduleTask</li>\n<li><code>onApplicationEvent</code>spring容器加载完毕之后调用，ScheduleTask向ScheduledTaskRegistrar中注册, 调用ScheduledTaskRegistrar.afterPropertiesSet() </li>\n</ul>\n<p>ScheduledTaskRegistrar核心方法：</p>\n<ul>\n<li><code>afterPropertiesSet</code>初始化所有定时器，启动定时器</li>\n</ul>\n<p>TaskScheduler作用及核心方法：</p>\n<ul>\n<li>主要的实现类有三个ThreadPoolTaskScheduler,ConcurrentTaskScheduler,TimerManagerTaskScheduler</li>\n<li>作用：这些类的作用主要是将<code>task</code>和<code>executor</code>用<code>ReschedulingRunnable</code>包装起来进行生命周期管理。 </li>\n<li>核心方法：<code>ScheduledFuture schedule</code></li>\n</ul>\n<p>ReschedulingRunnable核心方法：</p>\n<ul>\n<li><code>schedule()</code></li>\n<li><code>run()</code></li>\n</ul>\n<p>使用demo<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskConf</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ThreadPoolTaskScheduler <span class=\"title\">initThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ThreadPoolTaskScheduler taskScheduler = <span class=\"keyword\">new</span> ThreadPoolTaskScheduler();</span><br><span class=\"line\">        taskScheduler.setPoolSize(<span class=\"number\">20</span>);</span><br><span class=\"line\">        taskScheduler.initialize();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> taskScheduler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskService</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LockRegistry lockRegistry;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ThreadPoolTaskScheduler threadPoolTaskScheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String jobName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setJobName</span><span class=\"params\">(String jobName)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jobName = jobName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLockKey</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder buf = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        buf.append(TaskService.class.getName())</span><br><span class=\"line\">           .append(<span class=\"string\">\"/\"</span>).append(key).append(<span class=\"string\">\"111\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Date date)</span> </span>&#123;</span><br><span class=\"line\">        threadPoolTaskScheduler.schedule(<span class=\"keyword\">this</span>, date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String lockKey = getLockKey(jobName);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waitLockTime = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        Lock lock = lockRegistry.obtain(lockKey);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!lock.tryLock(waitLockTime, TimeUnit.MILLISECONDS)) &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">\"加锁失败，任务中止\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">\"在等待加锁时被中止\"</span>, e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"execute \"</span> + jobName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskService.setJobName(<span class=\"string\">\"111\"</span>);</span><br><span class=\"line\">Date runTime = <span class=\"keyword\">new</span> Date(order.getDateCreated().getTime() + <span class=\"number\">30</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">taskService.start(runTime);</span><br></pre></td></tr></table></figure>\n<p>其实这里用的还是<code>java.util.concurrent</code>的<code>ScheduledExecutorService</code>看下面的源码就明白了<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger) &#123;</span><br><span class=\"line\">\t\tScheduledExecutorService executor = getScheduledExecutor();</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tErrorHandler errorHandler =</span><br><span class=\"line\">\t\t\t\t\t(<span class=\"keyword\">this</span>.errorHandler != <span class=\"keyword\">null</span> ? <span class=\"keyword\">this</span>.errorHandler : TaskUtils.getDefaultErrorHandler(<span class=\"keyword\">true</span>));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReschedulingRunnable(task, trigger, executor, errorHandler).schedule();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TaskRejectedException(<span class=\"string\">\"Executor [\"</span> + executor + <span class=\"string\">\"] did not accept task: \"</span> + task, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Mac对NTFS进行读写操作","date":"2017-12-20T02:34:22.000Z","description":"Mac对NTFS进行读写操作","_content":"\n```bash\nsudo -s #切换root用户\n```\n\n```bash\ncd /sbin #进入/sbin文件夹\n```\n```bash\nmv mount_ntfs mount_ntfs_orig #重命名mount_ntfs为mount_ntfs_orig\n```\n【这一步会出现问题：mv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. google了一下，找到解决方法，见后面】\n```bash\nvim mount_ntfs #（新建）编辑mount_ntfs脚本文件，内容为：\n\n#!/bin/sh\n\n/sbin/mount_ntfs_orig -o rw,nobrowse \"$@\"\n\n```\n```bash\nchmod a+x mount_ntfs #修改权限增加可执行\n```\nmv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. 问题的解决，参照：[osx - Operation Not Permitted when on root El capitan (rootless disabled)\n](https://stackoverflow.com/questions/32659348/operation-not-permitted-when-on-root-el-capitan-rootless-disabled)\n\n具体如下：\n\n1）重启mac，cmd+R进入恢复（recovery）模式\n2）找到terminal(在“XX工具”里面）\n3）输入：\n```bash\ncsrutil disable\n```\n重启。\n\n当然，改好后建议重新进入恢复（recovery）模式\n```bash\n$csrutil enable\n```\n要恢复对NTFS的不进行写功能\n```bash\nmv mount_ntfs_orig mount_ntfs #重命名mount_ntfs_orig为mount_ntfs\n```\n即可\n","source":"_posts/OS/Mac/Mac-NTFS.md","raw":"---\ntitle: Mac对NTFS进行读写操作\ndate: 2017-12-20 10:34:22\ncategories: PC\ntags: [OS,Mac]\ndescription: Mac对NTFS进行读写操作\n---\n\n```bash\nsudo -s #切换root用户\n```\n\n```bash\ncd /sbin #进入/sbin文件夹\n```\n```bash\nmv mount_ntfs mount_ntfs_orig #重命名mount_ntfs为mount_ntfs_orig\n```\n【这一步会出现问题：mv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. google了一下，找到解决方法，见后面】\n```bash\nvim mount_ntfs #（新建）编辑mount_ntfs脚本文件，内容为：\n\n#!/bin/sh\n\n/sbin/mount_ntfs_orig -o rw,nobrowse \"$@\"\n\n```\n```bash\nchmod a+x mount_ntfs #修改权限增加可执行\n```\nmv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. 问题的解决，参照：[osx - Operation Not Permitted when on root El capitan (rootless disabled)\n](https://stackoverflow.com/questions/32659348/operation-not-permitted-when-on-root-el-capitan-rootless-disabled)\n\n具体如下：\n\n1）重启mac，cmd+R进入恢复（recovery）模式\n2）找到terminal(在“XX工具”里面）\n3）输入：\n```bash\ncsrutil disable\n```\n重启。\n\n当然，改好后建议重新进入恢复（recovery）模式\n```bash\n$csrutil enable\n```\n要恢复对NTFS的不进行写功能\n```bash\nmv mount_ntfs_orig mount_ntfs #重命名mount_ntfs_orig为mount_ntfs\n```\n即可\n","slug":"OS/Mac/Mac-NTFS","published":1,"updated":"2018-01-04T01:15:59.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqk001h6dofycan9sus","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -s <span class=\"comment\">#切换root用户</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /sbin <span class=\"comment\">#进入/sbin文件夹</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv mount_ntfs mount_ntfs_orig <span class=\"comment\">#重命名mount_ntfs为mount_ntfs_orig</span></span><br></pre></td></tr></table></figure>\n<p>【这一步会出现问题：mv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. google了一下，找到解决方法，见后面】<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim mount_ntfs <span class=\"comment\">#（新建）编辑mount_ntfs脚本文件，内容为：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">/sbin/mount_ntfs_orig -o rw,nobrowse <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod a+x mount_ntfs <span class=\"comment\">#修改权限增加可执行</span></span><br></pre></td></tr></table></figure>\n<p>mv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. 问题的解决，参照：<a href=\"https://stackoverflow.com/questions/32659348/operation-not-permitted-when-on-root-el-capitan-rootless-disabled\" target=\"_blank\" rel=\"noopener\">osx - Operation Not Permitted when on root El capitan (rootless disabled)\n</a></p>\n<p>具体如下：</p>\n<p>1）重启mac，cmd+R进入恢复（recovery）模式<br>2）找到terminal(在“XX工具”里面）<br>3）输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">csrutil <span class=\"built_in\">disable</span></span><br></pre></td></tr></table></figure></p>\n<p>重启。</p>\n<p>当然，改好后建议重新进入恢复（recovery）模式<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$csrutil</span> <span class=\"built_in\">enable</span></span><br></pre></td></tr></table></figure></p>\n<p>要恢复对NTFS的不进行写功能<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv mount_ntfs_orig mount_ntfs <span class=\"comment\">#重命名mount_ntfs_orig为mount_ntfs</span></span><br></pre></td></tr></table></figure></p>\n<p>即可</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -s <span class=\"comment\">#切换root用户</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /sbin <span class=\"comment\">#进入/sbin文件夹</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv mount_ntfs mount_ntfs_orig <span class=\"comment\">#重命名mount_ntfs为mount_ntfs_orig</span></span><br></pre></td></tr></table></figure>\n<p>【这一步会出现问题：mv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. google了一下，找到解决方法，见后面】<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim mount_ntfs <span class=\"comment\">#（新建）编辑mount_ntfs脚本文件，内容为：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">/sbin/mount_ntfs_orig -o rw,nobrowse <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod a+x mount_ntfs <span class=\"comment\">#修改权限增加可执行</span></span><br></pre></td></tr></table></figure>\n<p>mv: rename mount_ntfs to mount_ntfs_orig: Operation not permitted. 问题的解决，参照：<a href=\"https://stackoverflow.com/questions/32659348/operation-not-permitted-when-on-root-el-capitan-rootless-disabled\" target=\"_blank\" rel=\"noopener\">osx - Operation Not Permitted when on root El capitan (rootless disabled)\n</a></p>\n<p>具体如下：</p>\n<p>1）重启mac，cmd+R进入恢复（recovery）模式<br>2）找到terminal(在“XX工具”里面）<br>3）输入：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">csrutil <span class=\"built_in\">disable</span></span><br></pre></td></tr></table></figure></p>\n<p>重启。</p>\n<p>当然，改好后建议重新进入恢复（recovery）模式<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$csrutil</span> <span class=\"built_in\">enable</span></span><br></pre></td></tr></table></figure></p>\n<p>要恢复对NTFS的不进行写功能<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv mount_ntfs_orig mount_ntfs <span class=\"comment\">#重命名mount_ntfs_orig为mount_ntfs</span></span><br></pre></td></tr></table></figure></p>\n<p>即可</p>\n"},{"title":"Scrapy踩过的那些坑","date":"2017-12-18T02:34:22.000Z","description":"Mac下 Scrapy踩过的那些坑","_content":"\n```bash\n-bash: Scrapy: command not found\n```\n因为按照时安装在了用户目录下`pip install Scrapy --user` ，不知道为什么pip没有自动导入环境变量导致的\n```bash\nsudo pip install Scrapy\n```\n即可\n\n```bash\nlit@litdeMacBook-Pro github$ scrapy startproject fang_scrapy\nTraceback (most recent call last):\n  File \"/usr/local/bin/scrapy\", line 7, in <module>\n    from scrapy.cmdline import execute\n  File \"/Library/Python/2.7/site-packages/scrapy/cmdline.py\", line 9, in <module>\n    from scrapy.crawler import CrawlerProcess\n  File \"/Library/Python/2.7/site-packages/scrapy/crawler.py\", line 7, in <module>\n    from twisted.internet import reactor, defer\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/reactor.py\", line 38, in <module>\n    from twisted.internet import default\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\", line 56, in <module>\n    install = _getInstallFunction(platform)\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\", line 50, in _getInstallFunction\n    from twisted.internet.selectreactor import install\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/selectreactor.py\", line 18, in <module>\n    from twisted.internet import posixbase\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/posixbase.py\", line 18, in <module>\n    from twisted.internet import error, udp, tcp\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/tcp.py\", line 28, in <module>\n    from twisted.internet._newtls import (\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_newtls.py\", line 21, in <module>\n    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/protocols/tls.py\", line 63, in <module>\n    from twisted.internet._sslverify import _setAcceptableProtocols\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_sslverify.py\", line 38, in <module>\n    TLSVersion.TLSv1_1: SSL.OP_NO_TLSv1_1,\nAttributeError: 'module' object has no attribute 'OP_NO_TLSv1_1'\n```\n该错误的原因是twisted的版本和scrapy要求的版本不匹配\n```bash\npip uninstall twisted\nsudo pip install twisted==13.1.0\n```\n即可","source":"_posts/Python/scrapy/scrapy-error.md","raw":"---\ntitle: Scrapy踩过的那些坑\ndate: 2017-12-18 10:34:22\ncategories: Python\ntags: [Python,Scrapy]\ndescription: Mac下 Scrapy踩过的那些坑\n---\n\n```bash\n-bash: Scrapy: command not found\n```\n因为按照时安装在了用户目录下`pip install Scrapy --user` ，不知道为什么pip没有自动导入环境变量导致的\n```bash\nsudo pip install Scrapy\n```\n即可\n\n```bash\nlit@litdeMacBook-Pro github$ scrapy startproject fang_scrapy\nTraceback (most recent call last):\n  File \"/usr/local/bin/scrapy\", line 7, in <module>\n    from scrapy.cmdline import execute\n  File \"/Library/Python/2.7/site-packages/scrapy/cmdline.py\", line 9, in <module>\n    from scrapy.crawler import CrawlerProcess\n  File \"/Library/Python/2.7/site-packages/scrapy/crawler.py\", line 7, in <module>\n    from twisted.internet import reactor, defer\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/reactor.py\", line 38, in <module>\n    from twisted.internet import default\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\", line 56, in <module>\n    install = _getInstallFunction(platform)\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\", line 50, in _getInstallFunction\n    from twisted.internet.selectreactor import install\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/selectreactor.py\", line 18, in <module>\n    from twisted.internet import posixbase\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/posixbase.py\", line 18, in <module>\n    from twisted.internet import error, udp, tcp\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/tcp.py\", line 28, in <module>\n    from twisted.internet._newtls import (\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_newtls.py\", line 21, in <module>\n    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/protocols/tls.py\", line 63, in <module>\n    from twisted.internet._sslverify import _setAcceptableProtocols\n  File \"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_sslverify.py\", line 38, in <module>\n    TLSVersion.TLSv1_1: SSL.OP_NO_TLSv1_1,\nAttributeError: 'module' object has no attribute 'OP_NO_TLSv1_1'\n```\n该错误的原因是twisted的版本和scrapy要求的版本不匹配\n```bash\npip uninstall twisted\nsudo pip install twisted==13.1.0\n```\n即可","slug":"Python/scrapy/scrapy-error","published":1,"updated":"2017-12-28T04:44:25.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqn001m6dofv7dw18f1","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-bash: Scrapy: <span class=\"built_in\">command</span> not found</span><br></pre></td></tr></table></figure>\n<p>因为按照时安装在了用户目录下<code>pip install Scrapy --user</code> ，不知道为什么pip没有自动导入环境变量导致的<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install Scrapy</span><br></pre></td></tr></table></figure></p>\n<p>即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lit@litdeMacBook-Pro github$ scrapy startproject fang_scrapy</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"/usr/local/bin/scrapy\"</span>, line 7, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from scrapy.cmdline import execute</span><br><span class=\"line\">  File <span class=\"string\">\"/Library/Python/2.7/site-packages/scrapy/cmdline.py\"</span>, line 9, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from scrapy.crawler import CrawlerProcess</span><br><span class=\"line\">  File <span class=\"string\">\"/Library/Python/2.7/site-packages/scrapy/crawler.py\"</span>, line 7, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import reactor, defer</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/reactor.py\"</span>, line 38, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import default</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\"</span>, line 56, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    install = _getInstallFunction(platform)</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\"</span>, line 50, <span class=\"keyword\">in</span> _getInstallFunction</span><br><span class=\"line\">    from twisted.internet.selectreactor import install</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/selectreactor.py\"</span>, line 18, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import posixbase</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/posixbase.py\"</span>, line 18, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import error, udp, tcp</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/tcp.py\"</span>, line 28, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet._newtls import (</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_newtls.py\"</span>, line 21, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/protocols/tls.py\"</span>, line 63, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet._sslverify import _setAcceptableProtocols</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_sslverify.py\"</span>, line 38, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    TLSVersion.TLSv1_1: SSL.OP_NO_TLSv1_1,</span><br><span class=\"line\">AttributeError: <span class=\"string\">'module'</span> object has no attribute <span class=\"string\">'OP_NO_TLSv1_1'</span></span><br></pre></td></tr></table></figure>\n<p>该错误的原因是twisted的版本和scrapy要求的版本不匹配<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip uninstall twisted</span><br><span class=\"line\">sudo pip install twisted==13.1.0</span><br></pre></td></tr></table></figure></p>\n<p>即可</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-bash: Scrapy: <span class=\"built_in\">command</span> not found</span><br></pre></td></tr></table></figure>\n<p>因为按照时安装在了用户目录下<code>pip install Scrapy --user</code> ，不知道为什么pip没有自动导入环境变量导致的<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pip install Scrapy</span><br></pre></td></tr></table></figure></p>\n<p>即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lit@litdeMacBook-Pro github$ scrapy startproject fang_scrapy</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"/usr/local/bin/scrapy\"</span>, line 7, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from scrapy.cmdline import execute</span><br><span class=\"line\">  File <span class=\"string\">\"/Library/Python/2.7/site-packages/scrapy/cmdline.py\"</span>, line 9, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from scrapy.crawler import CrawlerProcess</span><br><span class=\"line\">  File <span class=\"string\">\"/Library/Python/2.7/site-packages/scrapy/crawler.py\"</span>, line 7, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import reactor, defer</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/reactor.py\"</span>, line 38, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import default</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\"</span>, line 56, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    install = _getInstallFunction(platform)</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/default.py\"</span>, line 50, <span class=\"keyword\">in</span> _getInstallFunction</span><br><span class=\"line\">    from twisted.internet.selectreactor import install</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/selectreactor.py\"</span>, line 18, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import posixbase</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/posixbase.py\"</span>, line 18, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet import error, udp, tcp</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/tcp.py\"</span>, line 28, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet._newtls import (</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_newtls.py\"</span>, line 21, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.protocols.tls import TLSMemoryBIOFactory, TLSMemoryBIOProtocol</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/protocols/tls.py\"</span>, line 63, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    from twisted.internet._sslverify import _setAcceptableProtocols</span><br><span class=\"line\">  File <span class=\"string\">\"/Users/lit/Library/Python/2.7/lib/python/site-packages/twisted/internet/_sslverify.py\"</span>, line 38, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">    TLSVersion.TLSv1_1: SSL.OP_NO_TLSv1_1,</span><br><span class=\"line\">AttributeError: <span class=\"string\">'module'</span> object has no attribute <span class=\"string\">'OP_NO_TLSv1_1'</span></span><br></pre></td></tr></table></figure>\n<p>该错误的原因是twisted的版本和scrapy要求的版本不匹配<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip uninstall twisted</span><br><span class=\"line\">sudo pip install twisted==13.1.0</span><br></pre></td></tr></table></figure></p>\n<p>即可</p>\n"},{"title":"nvm-install","date":"2017-12-18T02:34:22.000Z","description":"Mac下 Pyenv 的安装使用","_content":"\nMac自带的python2.7不能删除，因为很多系统模块依赖，所以使用pyenv来安装python3.5版本，这样就可以并存。\n\n通过homebrew安装:\n```bash\nbrew install pyenv\n```\n但是在安装openssl依赖时提示一下信息：\n```bash\nA CA file has been bootstrapped using certificates from the SystemRoots\nkeychain. To add additional certificates (e.g. the certificates added in\nthe System keychain), place .pem files in\n  /usr/local/etc/openssl/certs\n\nand run\n  /usr/local/opt/openssl/bin/c_rehash\n\nThis formula is keg-only, which means it was not symlinked into /usr/local,\nbecause Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries.\n\nIf you need to have this software first in your PATH run:\n  echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' >> ~/.bash_profile\n\nFor compilers to find this software you may need to set:\n    LDFLAGS:  -L/usr/local/opt/openssl/lib\n    CPPFLAGS: -I/usr/local/opt/openssl/include\nFor pkg-config to find this software you may need to set:\n    PKG_CONFIG_PATH: /usr/local/opt/openssl/lib/pkgconfig\n```\n上面提示，如果编译器需要这些依赖文件，那么你需要在在编译之前执行lib和include的设置。所以需要导入下面配置\n```bash\necho 'export LDFLAGS=\"-L/usr/local/opt/openssl/lib\"' >> ~/.bash_profile\necho 'export CPPFLAGS=\"-I/usr/local/opt/openssl/include\"' >> ~/.bash_profile\necho 'export PKG_CONFIG_PATH=\"/usr/local/opt/openssl/lib/pkgconfig\"' >> ~/.bash_profile\n```\n\n下面是一些常用的命令\n```bash\npyenv install --list //查看可安装的python版本\npyenv install 3.5.0 安装python3.5.0\npyenv rehash\npyenv versions //查看已经安装好的版本，带*号的为当前使用的版本\npyenv global 3.5.0 //设置全局版本，即系统使用的将是此版本\npyenv local 3.5.0 //当前目录下的使用版本，有点类似virtualenv\n```\n### 网络问题\n如anaconda之类大容量的版本，由于网络的问题，总是连接中断，安装失败。此时可以先从官方网站下载安装包，然后放在~/.pyenv/cache文件夹中，然后在pyenv install 此版本，pyenv会自动先从此文件夹中搜索","source":"_posts/Python/basic/pyenv.md","raw":"---\ntitle: nvm-install\ndate: 2017-12-18 10:34:22\ncategories: Python\ntags: [Python]\ndescription: Mac下 Pyenv 的安装使用\n---\n\nMac自带的python2.7不能删除，因为很多系统模块依赖，所以使用pyenv来安装python3.5版本，这样就可以并存。\n\n通过homebrew安装:\n```bash\nbrew install pyenv\n```\n但是在安装openssl依赖时提示一下信息：\n```bash\nA CA file has been bootstrapped using certificates from the SystemRoots\nkeychain. To add additional certificates (e.g. the certificates added in\nthe System keychain), place .pem files in\n  /usr/local/etc/openssl/certs\n\nand run\n  /usr/local/opt/openssl/bin/c_rehash\n\nThis formula is keg-only, which means it was not symlinked into /usr/local,\nbecause Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries.\n\nIf you need to have this software first in your PATH run:\n  echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' >> ~/.bash_profile\n\nFor compilers to find this software you may need to set:\n    LDFLAGS:  -L/usr/local/opt/openssl/lib\n    CPPFLAGS: -I/usr/local/opt/openssl/include\nFor pkg-config to find this software you may need to set:\n    PKG_CONFIG_PATH: /usr/local/opt/openssl/lib/pkgconfig\n```\n上面提示，如果编译器需要这些依赖文件，那么你需要在在编译之前执行lib和include的设置。所以需要导入下面配置\n```bash\necho 'export LDFLAGS=\"-L/usr/local/opt/openssl/lib\"' >> ~/.bash_profile\necho 'export CPPFLAGS=\"-I/usr/local/opt/openssl/include\"' >> ~/.bash_profile\necho 'export PKG_CONFIG_PATH=\"/usr/local/opt/openssl/lib/pkgconfig\"' >> ~/.bash_profile\n```\n\n下面是一些常用的命令\n```bash\npyenv install --list //查看可安装的python版本\npyenv install 3.5.0 安装python3.5.0\npyenv rehash\npyenv versions //查看已经安装好的版本，带*号的为当前使用的版本\npyenv global 3.5.0 //设置全局版本，即系统使用的将是此版本\npyenv local 3.5.0 //当前目录下的使用版本，有点类似virtualenv\n```\n### 网络问题\n如anaconda之类大容量的版本，由于网络的问题，总是连接中断，安装失败。此时可以先从官方网站下载安装包，然后放在~/.pyenv/cache文件夹中，然后在pyenv install 此版本，pyenv会自动先从此文件夹中搜索","slug":"Python/basic/pyenv","published":1,"updated":"2017-12-21T15:03:25.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqp001n6dofe92ldf35","content":"<p>Mac自带的python2.7不能删除，因为很多系统模块依赖，所以使用pyenv来安装python3.5版本，这样就可以并存。</p>\n<p>通过homebrew安装:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install pyenv</span><br></pre></td></tr></table></figure></p>\n<p>但是在安装openssl依赖时提示一下信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A CA file has been bootstrapped using certificates from the SystemRoots</span><br><span class=\"line\">keychain. To add additional certificates (e.g. the certificates added <span class=\"keyword\">in</span></span><br><span class=\"line\">the System keychain), place .pem files <span class=\"keyword\">in</span></span><br><span class=\"line\">  /usr/<span class=\"built_in\">local</span>/etc/openssl/certs</span><br><span class=\"line\"></span><br><span class=\"line\">and run</span><br><span class=\"line\">  /usr/<span class=\"built_in\">local</span>/opt/openssl/bin/c_rehash</span><br><span class=\"line\"></span><br><span class=\"line\">This formula is keg-only, <span class=\"built_in\">which</span> means it was not symlinked into /usr/<span class=\"built_in\">local</span>,</span><br><span class=\"line\">because Apple has deprecated use of OpenSSL <span class=\"keyword\">in</span> favor of its own TLS and crypto libraries.</span><br><span class=\"line\"></span><br><span class=\"line\">If you need to have this software first <span class=\"keyword\">in</span> your PATH run:</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"'</span> &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\">For compilers to find this software you may need to <span class=\"built_in\">set</span>:</span><br><span class=\"line\">    LDFLAGS:  -L/usr/<span class=\"built_in\">local</span>/opt/openssl/lib</span><br><span class=\"line\">    CPPFLAGS: -I/usr/<span class=\"built_in\">local</span>/opt/openssl/include</span><br><span class=\"line\">For pkg-config to find this software you may need to <span class=\"built_in\">set</span>:</span><br><span class=\"line\">    PKG_CONFIG_PATH: /usr/<span class=\"built_in\">local</span>/opt/openssl/lib/pkgconfig</span><br></pre></td></tr></table></figure></p>\n<p>上面提示，如果编译器需要这些依赖文件，那么你需要在在编译之前执行lib和include的设置。所以需要导入下面配置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export LDFLAGS=\"-L/usr/local/opt/openssl/lib\"'</span> &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export CPPFLAGS=\"-I/usr/local/opt/openssl/include\"'</span> &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export PKG_CONFIG_PATH=\"/usr/local/opt/openssl/lib/pkgconfig\"'</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>下面是一些常用的命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pyenv install --list //查看可安装的python版本</span><br><span class=\"line\">pyenv install 3.5.0 安装python3.5.0</span><br><span class=\"line\">pyenv <span class=\"built_in\">rehash</span></span><br><span class=\"line\">pyenv versions //查看已经安装好的版本，带*号的为当前使用的版本</span><br><span class=\"line\">pyenv global 3.5.0 //设置全局版本，即系统使用的将是此版本</span><br><span class=\"line\">pyenv <span class=\"built_in\">local</span> 3.5.0 //当前目录下的使用版本，有点类似virtualenv</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"网络问题\"><a href=\"#网络问题\" class=\"headerlink\" title=\"网络问题\"></a>网络问题</h3><p>如anaconda之类大容量的版本，由于网络的问题，总是连接中断，安装失败。此时可以先从官方网站下载安装包，然后放在~/.pyenv/cache文件夹中，然后在pyenv install 此版本，pyenv会自动先从此文件夹中搜索</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mac自带的python2.7不能删除，因为很多系统模块依赖，所以使用pyenv来安装python3.5版本，这样就可以并存。</p>\n<p>通过homebrew安装:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install pyenv</span><br></pre></td></tr></table></figure></p>\n<p>但是在安装openssl依赖时提示一下信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A CA file has been bootstrapped using certificates from the SystemRoots</span><br><span class=\"line\">keychain. To add additional certificates (e.g. the certificates added <span class=\"keyword\">in</span></span><br><span class=\"line\">the System keychain), place .pem files <span class=\"keyword\">in</span></span><br><span class=\"line\">  /usr/<span class=\"built_in\">local</span>/etc/openssl/certs</span><br><span class=\"line\"></span><br><span class=\"line\">and run</span><br><span class=\"line\">  /usr/<span class=\"built_in\">local</span>/opt/openssl/bin/c_rehash</span><br><span class=\"line\"></span><br><span class=\"line\">This formula is keg-only, <span class=\"built_in\">which</span> means it was not symlinked into /usr/<span class=\"built_in\">local</span>,</span><br><span class=\"line\">because Apple has deprecated use of OpenSSL <span class=\"keyword\">in</span> favor of its own TLS and crypto libraries.</span><br><span class=\"line\"></span><br><span class=\"line\">If you need to have this software first <span class=\"keyword\">in</span> your PATH run:</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"'</span> &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\">For compilers to find this software you may need to <span class=\"built_in\">set</span>:</span><br><span class=\"line\">    LDFLAGS:  -L/usr/<span class=\"built_in\">local</span>/opt/openssl/lib</span><br><span class=\"line\">    CPPFLAGS: -I/usr/<span class=\"built_in\">local</span>/opt/openssl/include</span><br><span class=\"line\">For pkg-config to find this software you may need to <span class=\"built_in\">set</span>:</span><br><span class=\"line\">    PKG_CONFIG_PATH: /usr/<span class=\"built_in\">local</span>/opt/openssl/lib/pkgconfig</span><br></pre></td></tr></table></figure></p>\n<p>上面提示，如果编译器需要这些依赖文件，那么你需要在在编译之前执行lib和include的设置。所以需要导入下面配置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export LDFLAGS=\"-L/usr/local/opt/openssl/lib\"'</span> &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export CPPFLAGS=\"-I/usr/local/opt/openssl/include\"'</span> &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'export PKG_CONFIG_PATH=\"/usr/local/opt/openssl/lib/pkgconfig\"'</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>下面是一些常用的命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pyenv install --list //查看可安装的python版本</span><br><span class=\"line\">pyenv install 3.5.0 安装python3.5.0</span><br><span class=\"line\">pyenv <span class=\"built_in\">rehash</span></span><br><span class=\"line\">pyenv versions //查看已经安装好的版本，带*号的为当前使用的版本</span><br><span class=\"line\">pyenv global 3.5.0 //设置全局版本，即系统使用的将是此版本</span><br><span class=\"line\">pyenv <span class=\"built_in\">local</span> 3.5.0 //当前目录下的使用版本，有点类似virtualenv</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"网络问题\"><a href=\"#网络问题\" class=\"headerlink\" title=\"网络问题\"></a>网络问题</h3><p>如anaconda之类大容量的版本，由于网络的问题，总是连接中断，安装失败。此时可以先从官方网站下载安装包，然后放在~/.pyenv/cache文件夹中，然后在pyenv install 此版本，pyenv会自动先从此文件夹中搜索</p>\n"},{"title":"Java Stream API 细究","date":"2017-11-23T02:33:22.000Z","description":"昨天突然看到一篇关于JDK1.8 Stream 讲解的文章，之前一直是简单的使用，并没有仔细分析过其中的细节。仅仅做到了知其然，看了那位大牛的博客后，打算花一些时间，尽力做到知其所以然。","_content":"\n## Lambda表达式和匿名内部类\n昨天突然看到一篇关于JDK1.8 Stream 讲解的文章，之前一直是简单的使用，并没有仔细分析过其中的细节。仅仅做到了知其然，看了那位大牛的博客后，打算花一些时间，尽力做到知其所以然。本文是对[《深入理解Java函数式编程》](http://www.cnblogs.com/CarpenterLee/p/6729368.html)系列文章的合并整理\n### 取代某些匿名内部类\nJava Lambda表达式的一个重要用法是简化某些匿名内部类（`Anonymous Classes`）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的。\n#### demo1: 无参函数的简写\n如果需要新建一个线程，一种常见的写法是这样：\n```java\n// JDK7 匿名内部类写法\nnew Thread(new Runnable(){// 接口名\n    @Override\n    public void run(){// 方法名\n        System.out.println(\"Thread run()\");\n    }\n}).start();\n```\n上述代码给`Tread`类传递了一个匿名的`Runnable`对象，重载`Runnable`接口的`run()`方法来实现相应逻辑。这是JDK7以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在Java 8中可以简化为如下形式：\n```java\n// JDK8 Lambda表达式代码块写法\nnew Thread(\n        () -> {\n            System.out.print(\"Hello\");\n            System.out.println(\" Hoolee\");\n        }\n).start();\n```\n#### demo2: 带参函数的简写\n如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下：\n```java\n// JDK7 匿名内部类写法\nList<String> list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");\nCollections.sort(list, new Comparator<String>(){// 接口名\n    @Override\n    public int compare(String s1, String s2){// 方法名\n        if(s1 == null)\n            return -1;\n        if(s2 == null)\n            return 1;\n        return s1.length()-s2.length();\n    }\n});\n```\n上述代码通过内部类重载了`Comparator`接口的`compare()`方法，实现比较逻辑。采用Lambda表达式可简写如下：\n```java\n// JDK8 Lambda表达式写法\nList<String> list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");\nCollections.sort(list, (s1, s2) ->{// 省略参数表的类型\n    if(s1 == null)\n        return -1;\n    if(s2 == null)\n        return 1;\n    return s1.length()-s2.length();\n});\n```\n上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于javac的**类型推断机制**，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java是强类型语言，每个变量和对象都必需有明确的类型。\n\n### 简写的依据\n也许你已经想到了，能够使用**Lambda**的依据是必须有相应的函数接口（函数接口，是指内部只有一个抽象方法的接口）。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上**Lambda**的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。**Lambda**表达更多合法的书写形式如下：\n```java\n// Lambda表达式的书写形式\nRunnable run = () -> System.out.println(\"Hello World\");// 1\nActionListener listener = event -> System.out.println(\"button clicked\");// 2\nRunnable multiLine = () -> {// 3 代码块\n    System.out.print(\"Hello\");\n    System.out.println(\" Hoolee\");\n};\nBinaryOperator<Long> add = (Long x, Long y) -> x + y;// 4\nBinaryOperator<Long> addImplicit = (x, y) -> x + y;// 5 类型推断\n```\n上述代码中，1展示了无参函数的简写；2处展示了有参函数的简写，以及类型推断机制；3是代码块的写法；4和5再次展示了类型推断机制。\n\n### 自定义函数接口\n自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。\n```java\n// 自定义函数接口\n@FunctionalInterface\npublic interface ConsumerInterface<T>{\n    void accept(T t);\n}\n```\n上面代码中的**@FunctionalInterface**是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。**就像加入@Override标注会检查是否重载了函数一样。**\n有了上述接口定义，就可以写出类似如下的代码：\n\n`ConsumerInterface<String> consumer = str -> System.out.println(str);`\n\n进一步的，还可以这样使用：\n```java\nclass MyStream<T>{\n    private List<T> list;\n    ...\n    public void myForEach(ConsumerInterface<T> consumer){// 1\n        for(T t : list){\n            consumer.accept(t);\n        }\n    }\n}\nMyStream<String> stream = new MyStream<String>();\nstream.myForEach(str -> System.out.println(str));// 使用自定义函数接口书写Lambda表达式\n```\n### 不是匿名内部类的简写\n经过上面的介绍，我们看到Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。\n#### 匿名内部类实现\n匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名。因此如果有如下形式的代码，编译之后将会产生两个class文件：\n```java\npublic class MainAnonymousClass {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\t\t\t\tSystem.out.println(\"Anonymous Class Thread run()\");\n\t\t\t}\n\t\t}).start();;\n\t}\n}\n```\n进一步分析主类MainAnonymousClass.class的字节码，可发现其创建了匿名内部类的对象：\n```java\n// javap -c MainAnonymousClass.class\npublic class MainAnonymousClass {\n  ...\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/Thread\n       3: dup\n       4: new           #3                  // class MainAnonymousClass$1 /*创建内部类对象*/\n       7: dup\n       8: invokespecial #4                  // Method MainAnonymousClass$1.\"<init>\":()V\n      11: invokespecial #5                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n      14: invokevirtual #6                  // Method java/lang/Thread.start:()V\n      17: return\n}\n```\n#### Lambda表达式实现\n**Lambda**表达式通过**invokedynamic**指令实现，书写**Lambda**表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件：\n```java\npublic class MainLambda {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(\n\t\t\t\t() -> System.out.println(\"Lambda Thread run()\")\n\t\t\t).start();;\n\t}\n}\n```\n通过javap反编译命名，我们更能看出Lambda表达式内部表示的不同：\n```java\n// javap -c -p MainLambda.class\npublic class MainLambda {\n  ...\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/Thread\n       3: dup\n       4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/\n       9: invokespecial #4                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n      12: invokevirtual #5                  // Method java/lang/Thread.start:()V\n      15: return\n\n  private static void lambda$main$0();  /*Lambda表达式被封装成主类的私有方法*/\n    Code:\n       0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #7                  // String Lambda Thread run()\n       5: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n```\n反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法，并通过**invokedynamic**指令进行调用。\n#### 推论，this引用的意义\n既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。因此下列代码将输出两遍Hello Hoolee，而不是两个引用地址。\n```java\npublic class Hello {\n\tRunnable r1 = () -> { System.out.println(this); };\n\tRunnable r2 = () -> { System.out.println(toString()); };\n\tpublic static void main(String[] args) {\n\t\tnew Hello().r1.run();\n\t\tnew Hello().r2.run();\n\t}\n\tpublic String toString() { return \"Hello Hoolee\"; }\n}\n```\n## Lambda表达式和Java集合框架\nJava8为容器新增一些有用的方法，这些方法有些是为完善原有功能，有些是为引入函数式编程（Lambda表达式），学习和使用这些方法有助于我们写出更加简洁有效的代码．本文分别以ArrayList和HashMap为例，讲解Java8集合框架（Java Collections Framework）中新加入方法的使用．\n### Collection中的新方法\n#### forEach()\n该方法的签名为`void forEach(Consumer<? super E> action)`，作用是对容器中的每个元素执行`action`指定的动作，其中`Consumer`是个函数接口，里面只有一个待实现方法`void accept(T t)`（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。\n\n需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.\n\nJava7及以前我们可以用增强的for循环实现：\n```java\n// 使用曾强for循环迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor(String str : list){\n    if(str.length()>3)\n        System.out.println(str);\n}\n```\n现在使用`forEach()`方法结合匿名内部类，可以这样实现：\n```java\n// 使用forEach()结合匿名内部类迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach(new Consumer<String>(){\n    @Override\n    public void accept(String str){\n        if(str.length()>3)\n            System.out.println(str);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`Comsumer`接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：\n```java\n// 使用forEach()结合Lambda表达式迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach( str -> {\n        if(str.length()>3)\n            System.out.println(str);\n    });\n```\n上述代码给`forEach()`方法传入一个Lambda表达式，我们不需要知道`accept()`方法，也不需要知道`Consumer`接口，类型推导帮我们做了一切。\n\n#### removeIf()\n该方法签名为`boolean removeIf(Predicate<? super E> filter)`，作用是删除容器中所有满足`filter`指定条件的元素，其中`Predicate`是一个函数接口，里面只有一个待实现方法`boolean test(T t)`，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。\n\n需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。\n\n我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出`ConcurrentModificationException`，所以上述任务传统的写法是：\n```java\n// 使用迭代器删除列表元素\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    if(it.next().length()>3) // 删除长度大于3的元素\n        it.remove();\n}\n```\n现在使用`removeIf()`方法结合匿名内部类，我们可是这样实现：\n```java\n// 使用removeIf()结合匿名名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(new Predicate<String>(){ // 删除长度大于3的元素\n    @Override\n    public boolean test(String str){\n        return str.length()>3;\n    }\n});\n```\n上述代码使用`removeIf()`方法，并使用匿名内部类实现`Precicate`接口。相信你已经想到用Lambda表达式该怎么写了：\n```java\n// 使用removeIf()结合Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(str -> str.length()>3); // 删除长度大于3的元素\n```\n使用Lambda表达式不需要记忆`Predicate`接口名，也不需要记忆`test()`方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。\n#### replaceAll()\n该方法签名为`void replaceAll(UnaryOperator<E> operator)`，作用是对每个元素执行`operator`指定的操作，并用操作结果来替换原来的元素。其中`UnaryOperator`是一个函数接口，里面只有一个待实现函数`T apply(T t)`。\n\n需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。\n\nJava7及之前似乎没有优雅的办法：\n```java\n// 使用下标实现元素替换\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor(int i=0; i<list.size(); i++){\n    String str = list.get(i);\n    if(str.length()>3)\n        list.set(i, str.toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类可以实现如下：\n```java\n// 使用匿名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(new UnaryOperator<String>(){\n    @Override\n    public String apply(String str){\n        if(str.length()>3)\n            return str.toUpperCase();\n        return str;\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`UnaryOperator`接口。我们知道可以用更为简洁的Lambda表达式实现：\n```java\n// 使用Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(str -> {\n    if(str.length()>3)\n        return str.toUpperCase();\n    return str;\n});\n```\n#### sort()\n该方法定义在List接口中，方法签名为`void sort(Comparator<? super E> c)`，该方法根据c指定的比较规则对容器元素进行排序。`Comparator`接口我们并不陌生，其中有一个方法`int compare(T o1, T o2)`需要实现，显然该接口是个函数接口。\n\n需求：假设有一个字符串列表，按照字符串长度增序对元素排序。\n\n由于Java7以及之前sort()方法在Collections工具类中，所以代码要这样写：\n```java\n// Collections.sort()方法\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nCollections.sort(list, new Comparator<String>(){\n    @Override\n    public int compare(String str1, String str2){\n        return str1.length()-str2.length();\n    }\n});\n```\n现在可以直接使用`List.sort()`方法，结合Lambda表达式，可以这样写：\n```java\n// List.sort()方法结合Lambda表达式\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.sort((str1, str2) -> str1.length()-str2.length());\n```\n#### spliterator()\n方法签名为`Spliterator<E> spliterator()`，该方法返回容器的可拆分迭代器。从名字来看该方法跟`iterator()`方法有点像，我们知道`Iterator`是用来迭代容器的，`Spliterator`也有类似作用，但二者有如下不同：\n\n* `Spliterator`既可以像`Iterator`那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。\n* `Spliterator`是可拆分的，一个`Spliterator`可以通过调用`Spliterator<T> trySplit()`方法来尝试分成两个。一个是this，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。\n\n可通过（多次）调用`Spliterator.trySplit()`方法来分解负载，以便多线程处理。\n\n#### stream()和parallelStream()\n`stream()`和`parallelStream()`分别返回该容器的`Stream`视图表示，不同之处在于`parallelStream()`返回并行的`Stream`。\n### Map中的新方法\n#### forEach()\n该方法签名为`void forEach(BiConsumer<? super K,? super V> action)`，作用是对Map中的每个映射执行`action`指定的操作，其中`BiConsumer`是一个函数接口，里面有一个待实现方法`void accept(T t, U u)`。`BinConsumer`接口名字和`accept()`方法名字都不重要，请不要记忆他们。\n\n需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．\n\nJava7以及之前经典的代码如下：\n```java\n// Java7以及之前迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()){\n    System.out.println(entry.getKey() + \"=\" + entry.getValue());\n}\n```\n使用`Map.forEach()`方法，结合匿名内部类，代码如下：\n```java\n// 使用forEach()结合匿名内部类迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach(new BiConsumer<Integer, String>(){\n    @Override\n    public void accept(Integer k, String v){\n        System.out.println(k + \"=\" + v);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`BiConsumer`接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：\n```java\n// 使用forEach()结合Lambda表达式迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach((k, v) -> System.out.println(k + \"=\" + v));\n}\n```\n#### getOrDefault()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V getOrDefault(Object key, V defaultValue)`，作用是按照给定的`key`查询Map中对应的`value`，如果没有找到则返回`defaultValue`。使用该方法程序员可以省去查询指定键值是否存在的麻烦．\n\n需求；假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出`NoValue`\n```java\n// 查询Map中指定的值，不存在时使用默认值\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\n// Java7以及之前做法\nif(map.containsKey(4)){ // 1\n    System.out.println(map.get(4));\n}else{\n    System.out.println(\"NoValue\");\n}\n// Java8使用Map.getOrDefault()\nSystem.out.println(map.getOrDefault(4, \"NoValue\")); // 2\n```\n#### putIfAbsent()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V putIfAbsent(K key, V value)`，作用是只有在不存在key值的映射或映射值为`null`时，才将`value`指定的值放入到Map中，否则不对Map做更改．该方法将条件判断和赋值合二为一，使用起来更加方便\n#### remove()\n我们都知道Map中有一个`remove(Object key)`方法，来根据指定`key`值删除Map中的映射关系；Java8新增了`remove(Object key, Object value)`方法，只有在当前Map中`key`正好映射到`value`时才删除该映射，否则什么也不做．\n#### replace()\n在Java7及以前，要想替换Map中的映射关系可通过`put(K key, V value)`方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在Map中加入了两个`replace()`方法，分别如下：\n\n* `replace(K key, V value)`，只有在当前Map中`key`的映射存在时才用`value`去替换原来的值，否则什么也不做．\n* `replace(K key, V oldValue, V newValue)`，只有在当前Map中key的映射存在且等于`oldValue`时才用`newValue`去替换原来的值，否则什么也不做．\n#### replaceAll()\n该方法签名为`replaceAll(BiFunction<? super K,? super V,? extends V> function)`，作用是对Map中的每个映射执行`function`指定的操作，并用`function`的执行结果替换原来的`value`，其中`BiFunction`是一个函数接口，里面有一个待实现方法`R apply(T t, U u)`．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．\n\n需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．\n\nJava7以及之前经典的代码如下：\n```java\n// Java7以及之前替换所有Map中所有映射关系\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()){\n    entry.setValue(entry.getValue().toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类，实现如下：\n```java\n// 使用replaceAll()结合匿名内部类实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll(new BiFunction<Integer, String, String>(){\n    @Override\n    public String apply(Integer k, String v){\n        return v.toUpperCase();\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`BiFunction`接口。更进一步的，使用Lambda表达式实现如下：\n```java\n// 使用replaceAll()结合Lambda表达式实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll((k, v) -> v.toUpperCase());\n```\n#### merge()\n该方法签名为`merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)`，作用是：\n\n* 如果Map中`key`对应的映射不存在或者为`null`，则将`value`（不能是null）关联到`key`上；\n* 否则执行`remappingFunction`，如果执行结果非`null`则用该结果跟`key`关联，否则在Map中删除`key`的映射．\n\n参数中`BiFunction`函数接口前面已经介绍过，里面有一个待实现方法`R apply(T t, U u)`．\n\n`merge()`方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：\n\n`map.merge(key, newMsg, (v1, v2) -> v1+v2);`\n\n#### compute()\n该方法签名为`compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)`，作用是把`remappingFunction`的计算结果关联到`key`上，如果计算结果为`null`，则在Map中删除`key`的映射．\n\n要实现上述`merge()`方法中错误信息拼接的例子，使用`compute()`代码如下：\n\n`map.compute(key, (k,v) -> v==null ? newMsg : v.concat(newMsg));`\n\n#### computeIfAbsent()\n该方法签名为`V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)`，作用是：只有在当前Map中不存在`key`值的映射或映射值为`null`时，才调用`mappingFunction`，并在`mappingFunction`执行结果非`null`时，将结果跟`key`关联．\n\nFunction是一个函数接口，里面有一个待实现方法`R apply(T t)`．\n\n`computeIfAbsent()`常用来对Map的某个`key`值建立初始化映射．比如我们要实现一个多值映射，Map的定义可能是`Map<K,Set<V>>`，要向Map中放入新值，可通过如下代码实现：\n```java\nMap<Integer, Set<String>> map = new HashMap<>();\n// Java7及以前的实现方式\nif(map.containsKey(1)){\n    map.get(1).add(\"one\");\n}else{\n    Set<String> valueSet = new HashSet<String>();\n    valueSet.add(\"one\");\n    map.put(1, valueSet);\n}\n// Java8的实现方式\nmap.computeIfAbsent(1, v -> new HashSet<String>()).add(\"yi\");\n```\n使用`computeIfAbsent()`将条件判断和添加操作合二为一，使代码更加简洁．\n#### computeIfPresent()\n该方法签名为`V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)`，作用跟`computeIfAbsent()`相反，即，只有在当前Map中存在`key`值的映射且非`null`时，才调用`remappingFunction`，如果`remappingFunction`执行结果为`null`，则删除`key`的映射，否则使用该结果替换`key`原来的映射．\n\n这个函数的功能跟如下代码是等效的：\n```java\n// Java7及以前跟computeIfPresent()等效的代码\nif (map.get(key) != null) {\n    V oldValue = map.get(key);\n    V newValue = remappingFunction.apply(key, oldValue);\n    if (newValue != null)\n        map.put(key, newValue);\n    else\n        map.remove(key);\n    return newValue;\n}\nreturn null;\n```\n## Java Stream API入门\nJava 8之所以费这么大功夫引入函数式编程，原因有二：\n\n* 代码简洁，函数式编程写出的代码简洁且意图明确，使用`stream`接口让你从此告别for循环。\n* 多核友好，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下`parallel()`方法。\n\n`stream`，也就是Java函数式编程的主角。对于Java 7来说stream完全是个陌生东西，stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如：\n\n* 调用`Collection.stream()`或者`Collection.parallelStream()`方法\n* 调用`Arrays.stream(T[] array)`方法\n\n常见的stream接口继承关系如图：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/Java_stream_Interfaces.png)\n\n图中4种stream接口继承自`BaseStream`，其中`IntStream`, `LongStream`, `DoubleStream`对应三种基本类型（`int`, `long`, `double`，注意不是包装类型），Stream对应所有剩余类型的`stream`视图。为不同数据类型设置不同`stream`接口，可以 1.提高性能，2.增加特定接口函数。\n\n你可能会奇怪为什么不把`IntStream`等设计成`Stream`的子接口？毕竟这接口中的方法名大部分是一样的。答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。\n\n虽然大部分情况下`stream`是容器调用`Collection.stream()`方法得到的，但`stream`和`collections`有以下不同：\n\n* 无存储。`stream`不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。\n* 为函数式编程而生。对`stream`的任何修改都不会修改背后的数据源，比如对`stream`执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新`stream`。\n* 惰式执行。`stream`上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。\n* 可消费性。`stream`只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。\n\n对`stream`的操作分为为两类，中间操作(`intermediate operations`)和结束操作(`terminal operations`)，二者特点是：\n\n* 中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新`stream`，仅此而已。\n* 结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以`pipeline`的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。\n\n下表汇总了Stream接口的部分常见方法：\n\n| 操作类型       | 接口方法       |\n| ------------- |:-------------:|\n| 中间操作       | concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()|\n| 结束操作       | allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()|\n\n区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。\n### stream方法使用\n`stream`跟函数接口关系非常紧密，没有函数接口`stream`就无法工作。回顾一下：函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。\n\n#### forEach()\n我们对`forEach()`方法并不陌生，在`Collection`中我们已经见过。方法签名为`void forEach(Consumer<? super E> action)`，作用是对容器中的每个元素执行`action`指定的动作，也就是对元素进行遍历。\n```java\n// 使用Stream.forEach()迭代\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.forEach(str -> System.out.println(str));\n```\n由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。\n#### filter()\n函数原型为`Stream<T> filter(Predicate<? super T> predicate)`，作用是返回一个只包含满足`predicate`条件元素的Stream。\n```java\n// 保留长度等于3的字符串\nStream<String> stream= Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.filter(str -> str.length()==3)\n    .forEach(str -> System.out.println(str));\n```\n上述代码将输出为长度等于3的字符串`you`和`too`。注意，由于`filter()`是个中间操作，如果只调用`filter()`不会有实际计算，因此也不会输出任何信息。\n#### distinct()\n函数原型为`Stream<T> distinct()`，作用是返回一个去除重复元素之后的`Stream`\n```java\nStream<String> stream= Stream.of(\"I\", \"love\", \"you\", \"too\", \"too\");\nstream.distinct()\n    .forEach(str -> System.out.println(str));\n```\n上述代码会输出去掉一个too之后的其余字符串。\n#### sorted()\n排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为`Stream<T>　sorted()和Stream<T>　sorted(Comparator<? super T> comparator)`。\n```java\nStream<String> stream= Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.sorted((str1, str2) -> str1.length()-str2.length())\n    .forEach(str -> System.out.println(str));\n```\n上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。\n#### map()\n函数原型为`<R> Stream<R> map(Function<? super T,? extends R> mapper)`，作用是返回一个对当前所有元素执行执行`mapper`之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。\n```java\nStream<String> stream　= Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.map(str -> str.toUpperCase())\n    .forEach(str -> System.out.println(str));\n```\n上述代码将输出原字符串的大写形式。\n#### flatMap()\n函数原型为`<R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper)`，作用是对每个元素执行`mapper`指定的操作，并用所有`mapper`返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲`flatMap()`的作用就相当于把原`stream`中的所有元素都\"摊平\"之后组成的Stream，转换前后元素的个数和类型都可能会改变。\n```java\nStream<List<Integer>> stream = Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5));\nstream.flatMap(list -> list.stream())\n    .forEach(i -> System.out.println(i));\n```\n上述代码中，原来的stream中有两个元素，分别是两个`List<Integer>`，执行`flatMap()`之后，将每个List都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的Stream。所以最终将输出1~5这5个数字。\n\n## Java Stream API进阶\n\n规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作`reduce()`和`collect()`，也有一些为简化书写而设计的专用规约操作，比如`sum()`、`max()`、`min()`、`count()`等。\n\n最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍`reduce()`和`collect()`，这是比较有魔法的地方。\n\n### reduce()\n`reduce`操作可以实现从一组元素中生成一个值，`sum()`、`max()`、`min()`、`count()`等都是`reduce`操作，将他们单独设为函数只是因为常用。`reduce()`的方法定义有三种重写形式：\n* `Optional<T> reduce(BinaryOperator<T> accumulator)`\n* `T reduce(T identity, BinaryOperator<T> accumulator)`\n* `<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)`\n\n虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和\"有时会有不同的语义。\n\n需求：从一组单词中找出最长的单词。这里“大”的含义就是“长”。\n```java\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nOptional<String> longest = stream.reduce((s1, s2) -> s1.length()>=s2.length() ? s1 : s2);\n//Optional<String> longest = stream.max((s1, s2) -> s1.length()-s2.length());\nSystem.out.println(longest.get());\n```\n上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用`Stream.max(Comparator<? super T> comparator)`方法来达到同等效果，但`reduce()`自有其存在的理由。\n\n需求：求出一组单词的长度之和。这是个“求和”操作，操作对象输入类型是String，而结果类型是Integer。\n\n```java\n// 求单词长度之和\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nInteger lengthSum = stream.reduce(0,　// 初始值　// (1)\n        (sum, str) -> sum+str.length(), // 累加器 // (2)\n        (a, b) -> a+b);　// 部分和拼接器，并行执行时才会用到 // (3)\n// int lengthSum = stream.mapToInt(str -> str.length()).sum();\nSystem.out.println(lengthSum);\n```\n上述代码标号(2)处将i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用`reduce()`函数将这两步合二为一，更有助于提升性能。如果想要使用`map()`和`sum()`组合来达到上述目的，也是可以的。\n\n`reduce()`擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？终极武器`collect()`横空出世！\n\n### collect()\n不夸张的讲，如果你发现某个功能在Stream接口中没找到，十有八九可以通过`collect()`方法实现。`collect()`是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。先看几个热身的小例子：\n```java\n// 将Stream转换成容器或Map\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nList<String> list = stream.collect(Collectors.toList()); // (1)\n// Set<String> set = stream.collect(Collectors.toSet()); // (2)\n// Map<String, Integer> map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)\n```\n上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问：\n\n* `Function.identity()`是干什么的？\n* `String::length`是什么意思？\n* `Collectors`是个什么东西？\n\n#### 接口的静态方法和默认方法\nFunction是一个接口，那么`Function.identity()`是什么意思呢？这要从两方面解释：\n\n* Java 8允许在接口中加入具体方法。接口中的具体方法有两种，`default`方法和`static`方法，`identity()`就是Function接口的一个静态方法。\n* `Function.identity()`返回一个输出跟输入一样的Lambda表达式对象，等价于形如`t -> t`形式的Lambda表达式。\n\n上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得`t -> t`比`identity()`方法更直观。我会告诉你接口中的`default`方法是一个无奈之举，在Java 7及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在Collection接口中加入一个stream()抽象方法会怎样？`default`方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了`default`方法，为何不再加入`static`方法来避免专门的工具类呢！\n\n#### 方法引用\n诸如`String::length`的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：\n\n| 方法引用类别\t   | 举例             |\n| -----------------|:---------------:|\n| 引用静态方法       | `Integer::sum`  |\n| 引用某个对象的方法\t | `list::add`     |\n| 引用某个类的方法    | `String::length`|\n| 引用构造方法\t   | `HashMap::new`  |\n\n#### 收集器\n收集器（Collector）是为`Stream.collect()`方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：\n\n* 目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。\n* 新元素如何添加到容器中？是List.add()还是Map.put()。如果并行的进行规约，还需要告诉`collect()` \n* 多个部分结果如何合并成一个。\n\n结合以上分析，`collect()`方法定义为`<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)`，三个参数依次对应上述三条分析。不过每次调用`collect()`都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以`collect()`的另一定义为`<R,A> R collect(Collector<? super T,A,R> collector)`。Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：\n```java\n//　将Stream规约成List\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nList<String> list = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);// 方式１\n//List<String> list = stream.collect(Collectors.toList());// 方式2\nSystem.out.println(list);\n```\n通常情况下我们不需要手动指定`collect()`的三个参数，而是调用`collect(Collector<? super T,A,R> collector)`方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了`collect()`的行为。\n\n#### 使用collect()生成Collection\n前面已经提到通过`collect()`方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：\n\n```java\n// 将Stream转换成List或Set\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nList<String> list = stream.collect(Collectors.toList()); // (1)\nSet<String> set = stream.collect(Collectors.toSet()); // (2)\n```\n上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过`Collectors.toCollection(Supplier<C> collectionFactory)`方法完成。\n```java\n// 使用toCollection()指定规约容器的类型\nArrayList<String> arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)\nHashSet<String> hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4)\n```\n#### 使用collect()生成Map\n前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的`key`和`value`分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下`collect()`的结果会是Map：\n* 使用`Collectors.toMap()`生成的收集器，用户需要指定如何生成Map的`key`和`value`。\n* 使用`Collectors.partitioningBy()`生成的收集器，对元素进行二分区操作时用到。\n* 使用`Collectors.groupingBy()`生成的收集器，对元素做`group`操作时用到。\n情况1：使用`toMap()`生成的收集器，这种情况是最直接的，前面例子中已提到，这是和`Collectors.toCollection()`并列的方法。如下代码展示将学生列表转换成由<学生，GPA>组成的Map。非常直观，无需多言。\n```java\n// 使用toMap()统计学生GPA\nMap<Student, Double> studentToGPA =\n     students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key\n                                     student -> computeGPA(student)));// 如何生成value\n```\n情况2：使用`partitioningBy()`生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。\n```java\n// Partition students into passing and failing\nMap<Boolean, List<Student>> passingFailing = students.stream()\n         .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));\n```\n情况3：使用`groupingBy()`生成的收集器，这是比较灵活的一种情况。跟SQL中的`group by`语句类似，这里的`groupingBy()`也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个`key`上。下列代码展示将员工按照部门进行分组：\n```java\n// Group employees by department\nMap<Department, List<Employee>> byDept = employees.stream()\n            .collect(Collectors.groupingBy(Employee::getDepartment));\n```\n以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的`groupingBy()`能够满足这种需求。增强版的`groupingBy()`允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做**上游收集器**，之后执行其他运算的收集器叫做**下游收集器(downstream Collector)**。\n```java\n// 使用下游收集器统计每个部门的人数\nMap<Department, Integer> totalByDept = employees.stream()\n                    .collect(Collectors.groupingBy(Employee::getDepartment,\n                                                   Collectors.counting()));// 下游收集器\n```\n上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：\n```java\n// 按照部门对员工分布组，并只保留员工的名字\nMap<Department, List<String>> byDept = employees.stream()\n                .collect(Collectors.groupingBy(Employee::getDepartment,\n                        Collectors.mapping(Employee::getName,// 下游收集器\n                                Collectors.toList())));// 更下游的收集器\n```\n#### 使用collect()做字符串join\n这个肯定是大家喜闻乐见的功能，字符串拼接时使用`Collectors.joining()`生成的收集器，从此告别`for`循环。`Collectors.joining()`方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。\n```java\n// 使用Collectors.joining()拼接字符串\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\");\n//String joined = stream.collect(Collectors.joining());// \"Iloveyou\"\n//String joined = stream.collect(Collectors.joining(\",\"));// \"I,love,you\"\nString joined = stream.collect(Collectors.joining(\",\", \"{\", \"}\"));// \"{I,love,you}\"\n```\n#### collect()还可以做更多\n除了可以使用Collectors工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用`collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)`方法，收集任何形式你想要的信息。不过Collectors工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。\n\n## Java Stream流水线\nStream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线的原理，这是Stream实现的关键所在。\n\n容器执行Lambda表达式的方式，以`ArrayList.forEach()`方法为例，具体代码如下：\n```java\n// ArrayList.forEach()\npublic void forEach(Consumer<? super E> action) {\n    ...\n    for (int i=0; modCount == expectedModCount && i < size; i++) {\n        action.accept(elementData[i]);// 回调方法\n    }\n    ...\n}\n```\n我们看到`ArrayList.forEach()`方法的主要逻辑就是一个for循环，在该for循环里不断调用`action.accept()`回调方法完成对元素的遍历。这完全没有什么新奇之处，回调方法在Java GUI的监听器中广泛使用。Lambda表达式的作用就是相当于一个回调方法，这很好理解。\n\nStream API中大量使用Lambda表达式作为回调方法，但这并不是关键。理解Stream我们更关心的是另外两个问题：流水线和自动并行。使用Stream或许很容易写入如下形式的代码：\n\n```java\nint longestStringLengthStartingWithA\n        = strings.stream()\n              .filter(s -> s.startsWith(\"A\"))\n              .mapToInt(String::length)\n              .max();\n```\n上述代码求出以字母A开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。类库的实现着使用流水线（Pipeline）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了Stream的所有操作。\n|Stream操作分类|||\n|--------:|---------:|---------:|\n|中间操作(Intermediate operations)|无状态(Stateless)|unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()|\n||有状态(Stateful)|distinct() sorted() sorted() limit() skip()|\n|结束操作(Terminal operations)|非短路操作|forEach() forEachOrdered() toArray() reduce() collect() max() min() count()|\n||短路操作(short-circuiting)|anyMatch() allMatch() noneMatch() findFirst() findAny()|\n\nStream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。\n\n### 一种直白的实现方式\n仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。具体说来，就是调用`filter()`方法后立即执行，选出所有以A开头的字符串并放到一个列表`list1`中，之后让`list1`传递给`mapToInt()`方法并立即执行，生成的结果放到`list2`中，最后遍历`list2`找出最大的数字作为最终结果。程序的执行流程如如所示：\n![一种直白的实现方式](http://ozqzyzixv.bkt.clouddn.com/1.png)\n\n这样做实现起来非常简单直观，但有两个明显的弊端：\n* 迭代次数多。迭代次数跟函数调用的次数相等。\n* 频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。\n\n这些弊端使得效率底下，根本无法接受。如果不使用Stream API我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：\n```java\nint longest = 0;\nfor(String str : strings){\n    if(str.startsWith(\"A\")){// 1. filter(), 保留以A开头的字符串\n        int len = str.length();// 2. mapToInt(), 转换成长度\n        longest = Math.max(len, longest);// 3. max(), 保留最长的长度\n    }\n}\n```\n采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟Stream API等价的功能，但问题是Stream类库的设计者并不知道用户的意图是什么。如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。\n### Stream流水线解决方案\n我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：\n\n* 用户的操作如何记录？\n* 操作如何叠加？\n* 叠加之后的操作如何执行？\n* 执行后的结果（如果有）在哪里？\n\n#### 操作如何记录\n注意这里使用的是“操作(operation)”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是<数据来源，操作，回调函数>构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。\n![Stream相关类和接口的继承关系图](http://ozqzyzixv.bkt.clouddn.com/Stream%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n还有IntPipeline, LongPipeline, DoublePipeline没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟ReferencePipeline是并列关系。图中Head用于表示第一个Stage，即调用调用诸如Collection.stream()方法产生的Stage，很显然这个Stage里不包含任何操作；StatelessOp和StatefulOp分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。\n\nStream流水线组织结构示意图如下：\n![Stream流水线组织结构示意图](http://ozqzyzixv.bkt.clouddn.com/Stream%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n图中通过`Collection.stream()`方法得到Head也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作。这就是Stream记录操作的方式。\n\n#### 操作如何叠加\n以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。\n\n|方法名|作用|\n|---:|---:|\n|`void begin(long size)`|开始遍历元素之前调用该方法，通知Sink做好准备。|\n|`void end()`|所有元素遍历完成之后调用，通知Sink没有更多的元素了。|\n|`boolean cancellationRequested()`|是否可以结束操作，可以让短路操作尽早结束。|\n|`void accept(T t)`|遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前`Stage.accept(T t)`方法就行了。|\n\n有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的`accept()`方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink的`begin()`和`end()`方法也是必须实现的。比如`Stream.sorted()`是一个有状态的中间操作，其对应的`Sink.begin()`方法可能创建一个乘放结果的容器，而`accept()`方法负责将元素添加到该容器，最后`end()`负责对容器进行排序。对于短路操作，`Sink.cancellationRequested()`也是必须实现的，比如`Stream.findFirst()`是短路操作，只要找到一个元素，`cancellationRequested()`就应该返回true，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。实际上Stream API内部实现的的本质，就是如何重载Sink的这四个接口方法。\n\n有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的`Sink.{begin(), accept(), cancellationRequested(), end()}`方法就可以了。一种可能的`Sink.accept()`方法流程是这样的：\n```java\nvoid accept(U u){\n    1. 使用当前Sink包装的回调函数处理u\n    2. 将处理结果传递给流水线下游的Sink\n}\n```\nSink接口的其他几个方法也是按照这种[处理->转发]的模型实现。下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看`Stream.map()`方法：\n\n```java\n// Stream.map()，调用该方法将产生一个新的Stream\npublic final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) {\n    ...\n    return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,\n                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {\n        @Override /*opWripSink()方法返回由回调函数包装而成Sink*/\n        Sink<P_OUT> opWrapSink(int flags, Sink<R> downstream) {\n            return new Sink.ChainedReference<P_OUT, R>(downstream) {\n                @Override\n                public void accept(P_OUT u) {\n                    R r = mapper.apply(u);// 1. 使用当前Sink包装的回调函数mapper处理u\n                    downstream.accept(r);// 2. 将处理结果传递给流水线下游的Sink\n                }\n            };\n        }\n    };\n}\n```\n上述代码看似复杂，其实逻辑很简单，就是将回调函数`mapper`包装到一个Sink当中。由于`Stream.map()`是一个无状态的中间操作，所以`map()`方法返回了一个`StatelessOp`内部类对象（一个新的Stream），调用这个新Stream的`opWripSink()`方法将得到一个包装了当前回调函数的Sink。\n\n再来看一个复杂一点的例子。`Stream.sorted()`方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，`sorted()`方法是如何将操作封装成Sink的呢？`sorted()`一种可能封装的Sink代码如下：\n```java\n// Stream.sort()方法用到的Sink实现\nclass RefSortingSink<T> extends AbstractRefSortingSink<T> {\n    private ArrayList<T> list;// 存放用于排序的元素\n    RefSortingSink(Sink<? super T> downstream, Comparator<? super T> comparator) {\n        super(downstream, comparator);\n    }\n    @Override\n    public void begin(long size) {\n        ...\n        // 创建一个存放排序元素的列表\n        list = (size >= 0) ? new ArrayList<T>((int) size) : new ArrayList<T>();\n    }\n    @Override\n    public void end() {\n        list.sort(comparator);// 只有元素全部接收之后才能开始排序\n        downstream.begin(list.size());\n        if (!cancellationWasRequested) {// 下游Sink不包含短路操作\n            list.forEach(downstream::accept);// 2. 将处理结果传递给流水线下游的Sink\n        }\n        else {// 下游Sink包含短路操作\n            for (T t : list) {// 每次都调用cancellationRequested()询问是否可以结束处理。\n                if (downstream.cancellationRequested()) break;\n                downstream.accept(t);// 2. 将处理结果传递给流水线下游的Sink\n            }\n        }\n        downstream.end();\n        list = null;\n    }\n    @Override\n    public void accept(T t) {\n        list.add(t);// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中\n    }\n}\n```\n上述代码完美的展现了Sink的四个接口方法是如何协同工作的：\n\n* 首先`beging()`方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；\n* 之后通过`accept()`方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；\n* 最后`end()`方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；\n* 如果下游的Sink是短路操作，将结果传递给下游时不断询问下游`cancellationRequested()`是否可以结束处理。\n#### 叠加之后的操作如何执行\nSink完美封装了Stream每一步操作，并给出了[处理->转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。\n\n结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理->转发]模型，结束操作的Sink就是调用链的出口。\n\n![流水线的执行](http://ozqzyzixv.bkt.clouddn.com/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%89%A7%E8%A1%8C.png)\n\n我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在PipelineHelper中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个`Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)`方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：\n```java\n// AbstractPipeline.wrapSink()\n// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，\n// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。\nfinal <P_IN> Sink<P_IN> wrapSink(Sink<E_OUT> sink) {\n    ...\n    for (AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) {\n        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);\n    }\n    return (Sink<P_IN>) sink;\n}\n```\n现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下：\n```java\n// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。\nfinal <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {\n    ...\n    if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {\n        wrappedSink.begin(spliterator.getExactSizeIfKnown());// 通知开始遍历\n        spliterator.forEachRemaining(wrappedSink);// 迭代\n        wrappedSink.end();// 通知遍历结束\n    }\n    ...\n}\n```\n上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器，参阅），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。\n\n#### 执行后的结果在哪里\n最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(Side-effects)，比如使用`Stream.forEach()`方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？\n\n**特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。**\n\n```java\n// 错误的收集方式\nArrayList<String> results = new ArrayList<>();\nstream.filter(s -> pattern.matcher(s).matches())\n      .forEach(s -> results.add(s));  // Unnecessary use of side-effects!\n// 正确的收集方式\nList<String>results =\n     stream.filter(s -> pattern.matcher(s).matches())\n             .collect(Collectors.toList());  // No side-effects!\n```\n回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。\n|返回类型\t|对应的结束操作\t|\n|----------:|----------:|\n|boolean|anyMatch() allMatch() noneMatch()|\n|Optional|findFirst() findAny()|\n|归约结果\t|reduce() collect()|\n|数组|toArray()|\n\n* 对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。\n* 对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用reduce()方法实现的。\n* 对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做Node的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。\n\n参考资料：\n\n[《深入理解Java函数式编程》系列文章](http://www.cnblogs.com/CarpenterLee/p/6729368.html)\n\n[《深入理解Java 8 Lambda》系列文章](http://lucida.me/)\n","source":"_posts/Java/basic/Java-Stream-API-Research.md","raw":"---\ntitle: Java Stream API 细究\ndate: 2017-11-23 10:33:22\ncategories: Java\ntags: [Java,Lambda,Stream]\ndescription: 昨天突然看到一篇关于JDK1.8 Stream 讲解的文章，之前一直是简单的使用，并没有仔细分析过其中的细节。仅仅做到了知其然，看了那位大牛的博客后，打算花一些时间，尽力做到知其所以然。\n---\n\n## Lambda表达式和匿名内部类\n昨天突然看到一篇关于JDK1.8 Stream 讲解的文章，之前一直是简单的使用，并没有仔细分析过其中的细节。仅仅做到了知其然，看了那位大牛的博客后，打算花一些时间，尽力做到知其所以然。本文是对[《深入理解Java函数式编程》](http://www.cnblogs.com/CarpenterLee/p/6729368.html)系列文章的合并整理\n### 取代某些匿名内部类\nJava Lambda表达式的一个重要用法是简化某些匿名内部类（`Anonymous Classes`）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的。\n#### demo1: 无参函数的简写\n如果需要新建一个线程，一种常见的写法是这样：\n```java\n// JDK7 匿名内部类写法\nnew Thread(new Runnable(){// 接口名\n    @Override\n    public void run(){// 方法名\n        System.out.println(\"Thread run()\");\n    }\n}).start();\n```\n上述代码给`Tread`类传递了一个匿名的`Runnable`对象，重载`Runnable`接口的`run()`方法来实现相应逻辑。这是JDK7以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在Java 8中可以简化为如下形式：\n```java\n// JDK8 Lambda表达式代码块写法\nnew Thread(\n        () -> {\n            System.out.print(\"Hello\");\n            System.out.println(\" Hoolee\");\n        }\n).start();\n```\n#### demo2: 带参函数的简写\n如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下：\n```java\n// JDK7 匿名内部类写法\nList<String> list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");\nCollections.sort(list, new Comparator<String>(){// 接口名\n    @Override\n    public int compare(String s1, String s2){// 方法名\n        if(s1 == null)\n            return -1;\n        if(s2 == null)\n            return 1;\n        return s1.length()-s2.length();\n    }\n});\n```\n上述代码通过内部类重载了`Comparator`接口的`compare()`方法，实现比较逻辑。采用Lambda表达式可简写如下：\n```java\n// JDK8 Lambda表达式写法\nList<String> list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");\nCollections.sort(list, (s1, s2) ->{// 省略参数表的类型\n    if(s1 == null)\n        return -1;\n    if(s2 == null)\n        return 1;\n    return s1.length()-s2.length();\n});\n```\n上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于javac的**类型推断机制**，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java是强类型语言，每个变量和对象都必需有明确的类型。\n\n### 简写的依据\n也许你已经想到了，能够使用**Lambda**的依据是必须有相应的函数接口（函数接口，是指内部只有一个抽象方法的接口）。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上**Lambda**的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。**Lambda**表达更多合法的书写形式如下：\n```java\n// Lambda表达式的书写形式\nRunnable run = () -> System.out.println(\"Hello World\");// 1\nActionListener listener = event -> System.out.println(\"button clicked\");// 2\nRunnable multiLine = () -> {// 3 代码块\n    System.out.print(\"Hello\");\n    System.out.println(\" Hoolee\");\n};\nBinaryOperator<Long> add = (Long x, Long y) -> x + y;// 4\nBinaryOperator<Long> addImplicit = (x, y) -> x + y;// 5 类型推断\n```\n上述代码中，1展示了无参函数的简写；2处展示了有参函数的简写，以及类型推断机制；3是代码块的写法；4和5再次展示了类型推断机制。\n\n### 自定义函数接口\n自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。\n```java\n// 自定义函数接口\n@FunctionalInterface\npublic interface ConsumerInterface<T>{\n    void accept(T t);\n}\n```\n上面代码中的**@FunctionalInterface**是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。**就像加入@Override标注会检查是否重载了函数一样。**\n有了上述接口定义，就可以写出类似如下的代码：\n\n`ConsumerInterface<String> consumer = str -> System.out.println(str);`\n\n进一步的，还可以这样使用：\n```java\nclass MyStream<T>{\n    private List<T> list;\n    ...\n    public void myForEach(ConsumerInterface<T> consumer){// 1\n        for(T t : list){\n            consumer.accept(t);\n        }\n    }\n}\nMyStream<String> stream = new MyStream<String>();\nstream.myForEach(str -> System.out.println(str));// 使用自定义函数接口书写Lambda表达式\n```\n### 不是匿名内部类的简写\n经过上面的介绍，我们看到Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。\n#### 匿名内部类实现\n匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名。因此如果有如下形式的代码，编译之后将会产生两个class文件：\n```java\npublic class MainAnonymousClass {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run(){\n\t\t\t\tSystem.out.println(\"Anonymous Class Thread run()\");\n\t\t\t}\n\t\t}).start();;\n\t}\n}\n```\n进一步分析主类MainAnonymousClass.class的字节码，可发现其创建了匿名内部类的对象：\n```java\n// javap -c MainAnonymousClass.class\npublic class MainAnonymousClass {\n  ...\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/Thread\n       3: dup\n       4: new           #3                  // class MainAnonymousClass$1 /*创建内部类对象*/\n       7: dup\n       8: invokespecial #4                  // Method MainAnonymousClass$1.\"<init>\":()V\n      11: invokespecial #5                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n      14: invokevirtual #6                  // Method java/lang/Thread.start:()V\n      17: return\n}\n```\n#### Lambda表达式实现\n**Lambda**表达式通过**invokedynamic**指令实现，书写**Lambda**表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件：\n```java\npublic class MainLambda {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(\n\t\t\t\t() -> System.out.println(\"Lambda Thread run()\")\n\t\t\t).start();;\n\t}\n}\n```\n通过javap反编译命名，我们更能看出Lambda表达式内部表示的不同：\n```java\n// javap -c -p MainLambda.class\npublic class MainLambda {\n  ...\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/Thread\n       3: dup\n       4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/\n       9: invokespecial #4                  // Method java/lang/Thread.\"<init>\":(Ljava/lang/Runnable;)V\n      12: invokevirtual #5                  // Method java/lang/Thread.start:()V\n      15: return\n\n  private static void lambda$main$0();  /*Lambda表达式被封装成主类的私有方法*/\n    Code:\n       0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #7                  // String Lambda Thread run()\n       5: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n```\n反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法，并通过**invokedynamic**指令进行调用。\n#### 推论，this引用的意义\n既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。因此下列代码将输出两遍Hello Hoolee，而不是两个引用地址。\n```java\npublic class Hello {\n\tRunnable r1 = () -> { System.out.println(this); };\n\tRunnable r2 = () -> { System.out.println(toString()); };\n\tpublic static void main(String[] args) {\n\t\tnew Hello().r1.run();\n\t\tnew Hello().r2.run();\n\t}\n\tpublic String toString() { return \"Hello Hoolee\"; }\n}\n```\n## Lambda表达式和Java集合框架\nJava8为容器新增一些有用的方法，这些方法有些是为完善原有功能，有些是为引入函数式编程（Lambda表达式），学习和使用这些方法有助于我们写出更加简洁有效的代码．本文分别以ArrayList和HashMap为例，讲解Java8集合框架（Java Collections Framework）中新加入方法的使用．\n### Collection中的新方法\n#### forEach()\n该方法的签名为`void forEach(Consumer<? super E> action)`，作用是对容器中的每个元素执行`action`指定的动作，其中`Consumer`是个函数接口，里面只有一个待实现方法`void accept(T t)`（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。\n\n需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.\n\nJava7及以前我们可以用增强的for循环实现：\n```java\n// 使用曾强for循环迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor(String str : list){\n    if(str.length()>3)\n        System.out.println(str);\n}\n```\n现在使用`forEach()`方法结合匿名内部类，可以这样实现：\n```java\n// 使用forEach()结合匿名内部类迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach(new Consumer<String>(){\n    @Override\n    public void accept(String str){\n        if(str.length()>3)\n            System.out.println(str);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`Comsumer`接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：\n```java\n// 使用forEach()结合Lambda表达式迭代\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.forEach( str -> {\n        if(str.length()>3)\n            System.out.println(str);\n    });\n```\n上述代码给`forEach()`方法传入一个Lambda表达式，我们不需要知道`accept()`方法，也不需要知道`Consumer`接口，类型推导帮我们做了一切。\n\n#### removeIf()\n该方法签名为`boolean removeIf(Predicate<? super E> filter)`，作用是删除容器中所有满足`filter`指定条件的元素，其中`Predicate`是一个函数接口，里面只有一个待实现方法`boolean test(T t)`，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。\n\n需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。\n\n我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出`ConcurrentModificationException`，所以上述任务传统的写法是：\n```java\n// 使用迭代器删除列表元素\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    if(it.next().length()>3) // 删除长度大于3的元素\n        it.remove();\n}\n```\n现在使用`removeIf()`方法结合匿名内部类，我们可是这样实现：\n```java\n// 使用removeIf()结合匿名名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(new Predicate<String>(){ // 删除长度大于3的元素\n    @Override\n    public boolean test(String str){\n        return str.length()>3;\n    }\n});\n```\n上述代码使用`removeIf()`方法，并使用匿名内部类实现`Precicate`接口。相信你已经想到用Lambda表达式该怎么写了：\n```java\n// 使用removeIf()结合Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.removeIf(str -> str.length()>3); // 删除长度大于3的元素\n```\n使用Lambda表达式不需要记忆`Predicate`接口名，也不需要记忆`test()`方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。\n#### replaceAll()\n该方法签名为`void replaceAll(UnaryOperator<E> operator)`，作用是对每个元素执行`operator`指定的操作，并用操作结果来替换原来的元素。其中`UnaryOperator`是一个函数接口，里面只有一个待实现函数`T apply(T t)`。\n\n需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。\n\nJava7及之前似乎没有优雅的办法：\n```java\n// 使用下标实现元素替换\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nfor(int i=0; i<list.size(); i++){\n    String str = list.get(i);\n    if(str.length()>3)\n        list.set(i, str.toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类可以实现如下：\n```java\n// 使用匿名内部类实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(new UnaryOperator<String>(){\n    @Override\n    public String apply(String str){\n        if(str.length()>3)\n            return str.toUpperCase();\n        return str;\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`UnaryOperator`接口。我们知道可以用更为简洁的Lambda表达式实现：\n```java\n// 使用Lambda表达式实现\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.replaceAll(str -> {\n    if(str.length()>3)\n        return str.toUpperCase();\n    return str;\n});\n```\n#### sort()\n该方法定义在List接口中，方法签名为`void sort(Comparator<? super E> c)`，该方法根据c指定的比较规则对容器元素进行排序。`Comparator`接口我们并不陌生，其中有一个方法`int compare(T o1, T o2)`需要实现，显然该接口是个函数接口。\n\n需求：假设有一个字符串列表，按照字符串长度增序对元素排序。\n\n由于Java7以及之前sort()方法在Collections工具类中，所以代码要这样写：\n```java\n// Collections.sort()方法\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nCollections.sort(list, new Comparator<String>(){\n    @Override\n    public int compare(String str1, String str2){\n        return str1.length()-str2.length();\n    }\n});\n```\n现在可以直接使用`List.sort()`方法，结合Lambda表达式，可以这样写：\n```java\n// List.sort()方法结合Lambda表达式\nArrayList<String> list = new ArrayList<>(Arrays.asList(\"I\", \"love\", \"you\", \"too\"));\nlist.sort((str1, str2) -> str1.length()-str2.length());\n```\n#### spliterator()\n方法签名为`Spliterator<E> spliterator()`，该方法返回容器的可拆分迭代器。从名字来看该方法跟`iterator()`方法有点像，我们知道`Iterator`是用来迭代容器的，`Spliterator`也有类似作用，但二者有如下不同：\n\n* `Spliterator`既可以像`Iterator`那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。\n* `Spliterator`是可拆分的，一个`Spliterator`可以通过调用`Spliterator<T> trySplit()`方法来尝试分成两个。一个是this，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。\n\n可通过（多次）调用`Spliterator.trySplit()`方法来分解负载，以便多线程处理。\n\n#### stream()和parallelStream()\n`stream()`和`parallelStream()`分别返回该容器的`Stream`视图表示，不同之处在于`parallelStream()`返回并行的`Stream`。\n### Map中的新方法\n#### forEach()\n该方法签名为`void forEach(BiConsumer<? super K,? super V> action)`，作用是对Map中的每个映射执行`action`指定的操作，其中`BiConsumer`是一个函数接口，里面有一个待实现方法`void accept(T t, U u)`。`BinConsumer`接口名字和`accept()`方法名字都不重要，请不要记忆他们。\n\n需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．\n\nJava7以及之前经典的代码如下：\n```java\n// Java7以及之前迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()){\n    System.out.println(entry.getKey() + \"=\" + entry.getValue());\n}\n```\n使用`Map.forEach()`方法，结合匿名内部类，代码如下：\n```java\n// 使用forEach()结合匿名内部类迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach(new BiConsumer<Integer, String>(){\n    @Override\n    public void accept(Integer k, String v){\n        System.out.println(k + \"=\" + v);\n    }\n});\n```\n上述代码调用`forEach()`方法，并使用匿名内部类实现`BiConsumer`接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：\n```java\n// 使用forEach()结合Lambda表达式迭代Map\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.forEach((k, v) -> System.out.println(k + \"=\" + v));\n}\n```\n#### getOrDefault()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V getOrDefault(Object key, V defaultValue)`，作用是按照给定的`key`查询Map中对应的`value`，如果没有找到则返回`defaultValue`。使用该方法程序员可以省去查询指定键值是否存在的麻烦．\n\n需求；假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出`NoValue`\n```java\n// 查询Map中指定的值，不存在时使用默认值\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\n// Java7以及之前做法\nif(map.containsKey(4)){ // 1\n    System.out.println(map.get(4));\n}else{\n    System.out.println(\"NoValue\");\n}\n// Java8使用Map.getOrDefault()\nSystem.out.println(map.getOrDefault(4, \"NoValue\")); // 2\n```\n#### putIfAbsent()\n该方法跟Lambda表达式没关系，但是很有用。方法签名为`V putIfAbsent(K key, V value)`，作用是只有在不存在key值的映射或映射值为`null`时，才将`value`指定的值放入到Map中，否则不对Map做更改．该方法将条件判断和赋值合二为一，使用起来更加方便\n#### remove()\n我们都知道Map中有一个`remove(Object key)`方法，来根据指定`key`值删除Map中的映射关系；Java8新增了`remove(Object key, Object value)`方法，只有在当前Map中`key`正好映射到`value`时才删除该映射，否则什么也不做．\n#### replace()\n在Java7及以前，要想替换Map中的映射关系可通过`put(K key, V value)`方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在Map中加入了两个`replace()`方法，分别如下：\n\n* `replace(K key, V value)`，只有在当前Map中`key`的映射存在时才用`value`去替换原来的值，否则什么也不做．\n* `replace(K key, V oldValue, V newValue)`，只有在当前Map中key的映射存在且等于`oldValue`时才用`newValue`去替换原来的值，否则什么也不做．\n#### replaceAll()\n该方法签名为`replaceAll(BiFunction<? super K,? super V,? extends V> function)`，作用是对Map中的每个映射执行`function`指定的操作，并用`function`的执行结果替换原来的`value`，其中`BiFunction`是一个函数接口，里面有一个待实现方法`R apply(T t, U u)`．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．\n\n需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．\n\nJava7以及之前经典的代码如下：\n```java\n// Java7以及之前替换所有Map中所有映射关系\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nfor(Map.Entry<Integer, String> entry : map.entrySet()){\n    entry.setValue(entry.getValue().toUpperCase());\n}\n```\n使用`replaceAll()`方法结合匿名内部类，实现如下：\n```java\n// 使用replaceAll()结合匿名内部类实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll(new BiFunction<Integer, String, String>(){\n    @Override\n    public String apply(Integer k, String v){\n        return v.toUpperCase();\n    }\n});\n```\n上述代码调用`replaceAll()`方法，并使用匿名内部类实现`BiFunction`接口。更进一步的，使用Lambda表达式实现如下：\n```java\n// 使用replaceAll()结合Lambda表达式实现\nHashMap<Integer, String> map = new HashMap<>();\nmap.put(1, \"one\");\nmap.put(2, \"two\");\nmap.put(3, \"three\");\nmap.replaceAll((k, v) -> v.toUpperCase());\n```\n#### merge()\n该方法签名为`merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)`，作用是：\n\n* 如果Map中`key`对应的映射不存在或者为`null`，则将`value`（不能是null）关联到`key`上；\n* 否则执行`remappingFunction`，如果执行结果非`null`则用该结果跟`key`关联，否则在Map中删除`key`的映射．\n\n参数中`BiFunction`函数接口前面已经介绍过，里面有一个待实现方法`R apply(T t, U u)`．\n\n`merge()`方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：\n\n`map.merge(key, newMsg, (v1, v2) -> v1+v2);`\n\n#### compute()\n该方法签名为`compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)`，作用是把`remappingFunction`的计算结果关联到`key`上，如果计算结果为`null`，则在Map中删除`key`的映射．\n\n要实现上述`merge()`方法中错误信息拼接的例子，使用`compute()`代码如下：\n\n`map.compute(key, (k,v) -> v==null ? newMsg : v.concat(newMsg));`\n\n#### computeIfAbsent()\n该方法签名为`V computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)`，作用是：只有在当前Map中不存在`key`值的映射或映射值为`null`时，才调用`mappingFunction`，并在`mappingFunction`执行结果非`null`时，将结果跟`key`关联．\n\nFunction是一个函数接口，里面有一个待实现方法`R apply(T t)`．\n\n`computeIfAbsent()`常用来对Map的某个`key`值建立初始化映射．比如我们要实现一个多值映射，Map的定义可能是`Map<K,Set<V>>`，要向Map中放入新值，可通过如下代码实现：\n```java\nMap<Integer, Set<String>> map = new HashMap<>();\n// Java7及以前的实现方式\nif(map.containsKey(1)){\n    map.get(1).add(\"one\");\n}else{\n    Set<String> valueSet = new HashSet<String>();\n    valueSet.add(\"one\");\n    map.put(1, valueSet);\n}\n// Java8的实现方式\nmap.computeIfAbsent(1, v -> new HashSet<String>()).add(\"yi\");\n```\n使用`computeIfAbsent()`将条件判断和添加操作合二为一，使代码更加简洁．\n#### computeIfPresent()\n该方法签名为`V computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)`，作用跟`computeIfAbsent()`相反，即，只有在当前Map中存在`key`值的映射且非`null`时，才调用`remappingFunction`，如果`remappingFunction`执行结果为`null`，则删除`key`的映射，否则使用该结果替换`key`原来的映射．\n\n这个函数的功能跟如下代码是等效的：\n```java\n// Java7及以前跟computeIfPresent()等效的代码\nif (map.get(key) != null) {\n    V oldValue = map.get(key);\n    V newValue = remappingFunction.apply(key, oldValue);\n    if (newValue != null)\n        map.put(key, newValue);\n    else\n        map.remove(key);\n    return newValue;\n}\nreturn null;\n```\n## Java Stream API入门\nJava 8之所以费这么大功夫引入函数式编程，原因有二：\n\n* 代码简洁，函数式编程写出的代码简洁且意图明确，使用`stream`接口让你从此告别for循环。\n* 多核友好，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下`parallel()`方法。\n\n`stream`，也就是Java函数式编程的主角。对于Java 7来说stream完全是个陌生东西，stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如：\n\n* 调用`Collection.stream()`或者`Collection.parallelStream()`方法\n* 调用`Arrays.stream(T[] array)`方法\n\n常见的stream接口继承关系如图：\n![avatar](http://ozqzyzixv.bkt.clouddn.com/Java_stream_Interfaces.png)\n\n图中4种stream接口继承自`BaseStream`，其中`IntStream`, `LongStream`, `DoubleStream`对应三种基本类型（`int`, `long`, `double`，注意不是包装类型），Stream对应所有剩余类型的`stream`视图。为不同数据类型设置不同`stream`接口，可以 1.提高性能，2.增加特定接口函数。\n\n你可能会奇怪为什么不把`IntStream`等设计成`Stream`的子接口？毕竟这接口中的方法名大部分是一样的。答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。\n\n虽然大部分情况下`stream`是容器调用`Collection.stream()`方法得到的，但`stream`和`collections`有以下不同：\n\n* 无存储。`stream`不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。\n* 为函数式编程而生。对`stream`的任何修改都不会修改背后的数据源，比如对`stream`执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新`stream`。\n* 惰式执行。`stream`上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。\n* 可消费性。`stream`只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。\n\n对`stream`的操作分为为两类，中间操作(`intermediate operations`)和结束操作(`terminal operations`)，二者特点是：\n\n* 中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新`stream`，仅此而已。\n* 结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以`pipeline`的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。\n\n下表汇总了Stream接口的部分常见方法：\n\n| 操作类型       | 接口方法       |\n| ------------- |:-------------:|\n| 中间操作       | concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()|\n| 结束操作       | allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()|\n\n区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。\n### stream方法使用\n`stream`跟函数接口关系非常紧密，没有函数接口`stream`就无法工作。回顾一下：函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。\n\n#### forEach()\n我们对`forEach()`方法并不陌生，在`Collection`中我们已经见过。方法签名为`void forEach(Consumer<? super E> action)`，作用是对容器中的每个元素执行`action`指定的动作，也就是对元素进行遍历。\n```java\n// 使用Stream.forEach()迭代\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.forEach(str -> System.out.println(str));\n```\n由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。\n#### filter()\n函数原型为`Stream<T> filter(Predicate<? super T> predicate)`，作用是返回一个只包含满足`predicate`条件元素的Stream。\n```java\n// 保留长度等于3的字符串\nStream<String> stream= Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.filter(str -> str.length()==3)\n    .forEach(str -> System.out.println(str));\n```\n上述代码将输出为长度等于3的字符串`you`和`too`。注意，由于`filter()`是个中间操作，如果只调用`filter()`不会有实际计算，因此也不会输出任何信息。\n#### distinct()\n函数原型为`Stream<T> distinct()`，作用是返回一个去除重复元素之后的`Stream`\n```java\nStream<String> stream= Stream.of(\"I\", \"love\", \"you\", \"too\", \"too\");\nstream.distinct()\n    .forEach(str -> System.out.println(str));\n```\n上述代码会输出去掉一个too之后的其余字符串。\n#### sorted()\n排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为`Stream<T>　sorted()和Stream<T>　sorted(Comparator<? super T> comparator)`。\n```java\nStream<String> stream= Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.sorted((str1, str2) -> str1.length()-str2.length())\n    .forEach(str -> System.out.println(str));\n```\n上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。\n#### map()\n函数原型为`<R> Stream<R> map(Function<? super T,? extends R> mapper)`，作用是返回一个对当前所有元素执行执行`mapper`之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。\n```java\nStream<String> stream　= Stream.of(\"I\", \"love\", \"you\", \"too\");\nstream.map(str -> str.toUpperCase())\n    .forEach(str -> System.out.println(str));\n```\n上述代码将输出原字符串的大写形式。\n#### flatMap()\n函数原型为`<R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper)`，作用是对每个元素执行`mapper`指定的操作，并用所有`mapper`返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲`flatMap()`的作用就相当于把原`stream`中的所有元素都\"摊平\"之后组成的Stream，转换前后元素的个数和类型都可能会改变。\n```java\nStream<List<Integer>> stream = Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5));\nstream.flatMap(list -> list.stream())\n    .forEach(i -> System.out.println(i));\n```\n上述代码中，原来的stream中有两个元素，分别是两个`List<Integer>`，执行`flatMap()`之后，将每个List都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的Stream。所以最终将输出1~5这5个数字。\n\n## Java Stream API进阶\n\n规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作`reduce()`和`collect()`，也有一些为简化书写而设计的专用规约操作，比如`sum()`、`max()`、`min()`、`count()`等。\n\n最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍`reduce()`和`collect()`，这是比较有魔法的地方。\n\n### reduce()\n`reduce`操作可以实现从一组元素中生成一个值，`sum()`、`max()`、`min()`、`count()`等都是`reduce`操作，将他们单独设为函数只是因为常用。`reduce()`的方法定义有三种重写形式：\n* `Optional<T> reduce(BinaryOperator<T> accumulator)`\n* `T reduce(T identity, BinaryOperator<T> accumulator)`\n* `<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)`\n\n虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和\"有时会有不同的语义。\n\n需求：从一组单词中找出最长的单词。这里“大”的含义就是“长”。\n```java\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nOptional<String> longest = stream.reduce((s1, s2) -> s1.length()>=s2.length() ? s1 : s2);\n//Optional<String> longest = stream.max((s1, s2) -> s1.length()-s2.length());\nSystem.out.println(longest.get());\n```\n上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用`Stream.max(Comparator<? super T> comparator)`方法来达到同等效果，但`reduce()`自有其存在的理由。\n\n需求：求出一组单词的长度之和。这是个“求和”操作，操作对象输入类型是String，而结果类型是Integer。\n\n```java\n// 求单词长度之和\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nInteger lengthSum = stream.reduce(0,　// 初始值　// (1)\n        (sum, str) -> sum+str.length(), // 累加器 // (2)\n        (a, b) -> a+b);　// 部分和拼接器，并行执行时才会用到 // (3)\n// int lengthSum = stream.mapToInt(str -> str.length()).sum();\nSystem.out.println(lengthSum);\n```\n上述代码标号(2)处将i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用`reduce()`函数将这两步合二为一，更有助于提升性能。如果想要使用`map()`和`sum()`组合来达到上述目的，也是可以的。\n\n`reduce()`擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？终极武器`collect()`横空出世！\n\n### collect()\n不夸张的讲，如果你发现某个功能在Stream接口中没找到，十有八九可以通过`collect()`方法实现。`collect()`是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。先看几个热身的小例子：\n```java\n// 将Stream转换成容器或Map\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nList<String> list = stream.collect(Collectors.toList()); // (1)\n// Set<String> set = stream.collect(Collectors.toSet()); // (2)\n// Map<String, Integer> map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)\n```\n上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问：\n\n* `Function.identity()`是干什么的？\n* `String::length`是什么意思？\n* `Collectors`是个什么东西？\n\n#### 接口的静态方法和默认方法\nFunction是一个接口，那么`Function.identity()`是什么意思呢？这要从两方面解释：\n\n* Java 8允许在接口中加入具体方法。接口中的具体方法有两种，`default`方法和`static`方法，`identity()`就是Function接口的一个静态方法。\n* `Function.identity()`返回一个输出跟输入一样的Lambda表达式对象，等价于形如`t -> t`形式的Lambda表达式。\n\n上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得`t -> t`比`identity()`方法更直观。我会告诉你接口中的`default`方法是一个无奈之举，在Java 7及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在Collection接口中加入一个stream()抽象方法会怎样？`default`方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了`default`方法，为何不再加入`static`方法来避免专门的工具类呢！\n\n#### 方法引用\n诸如`String::length`的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：\n\n| 方法引用类别\t   | 举例             |\n| -----------------|:---------------:|\n| 引用静态方法       | `Integer::sum`  |\n| 引用某个对象的方法\t | `list::add`     |\n| 引用某个类的方法    | `String::length`|\n| 引用构造方法\t   | `HashMap::new`  |\n\n#### 收集器\n收集器（Collector）是为`Stream.collect()`方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：\n\n* 目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。\n* 新元素如何添加到容器中？是List.add()还是Map.put()。如果并行的进行规约，还需要告诉`collect()` \n* 多个部分结果如何合并成一个。\n\n结合以上分析，`collect()`方法定义为`<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)`，三个参数依次对应上述三条分析。不过每次调用`collect()`都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以`collect()`的另一定义为`<R,A> R collect(Collector<? super T,A,R> collector)`。Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：\n```java\n//　将Stream规约成List\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nList<String> list = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);// 方式１\n//List<String> list = stream.collect(Collectors.toList());// 方式2\nSystem.out.println(list);\n```\n通常情况下我们不需要手动指定`collect()`的三个参数，而是调用`collect(Collector<? super T,A,R> collector)`方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了`collect()`的行为。\n\n#### 使用collect()生成Collection\n前面已经提到通过`collect()`方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：\n\n```java\n// 将Stream转换成List或Set\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nList<String> list = stream.collect(Collectors.toList()); // (1)\nSet<String> set = stream.collect(Collectors.toSet()); // (2)\n```\n上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过`Collectors.toCollection(Supplier<C> collectionFactory)`方法完成。\n```java\n// 使用toCollection()指定规约容器的类型\nArrayList<String> arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)\nHashSet<String> hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4)\n```\n#### 使用collect()生成Map\n前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的`key`和`value`分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下`collect()`的结果会是Map：\n* 使用`Collectors.toMap()`生成的收集器，用户需要指定如何生成Map的`key`和`value`。\n* 使用`Collectors.partitioningBy()`生成的收集器，对元素进行二分区操作时用到。\n* 使用`Collectors.groupingBy()`生成的收集器，对元素做`group`操作时用到。\n情况1：使用`toMap()`生成的收集器，这种情况是最直接的，前面例子中已提到，这是和`Collectors.toCollection()`并列的方法。如下代码展示将学生列表转换成由<学生，GPA>组成的Map。非常直观，无需多言。\n```java\n// 使用toMap()统计学生GPA\nMap<Student, Double> studentToGPA =\n     students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key\n                                     student -> computeGPA(student)));// 如何生成value\n```\n情况2：使用`partitioningBy()`生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。\n```java\n// Partition students into passing and failing\nMap<Boolean, List<Student>> passingFailing = students.stream()\n         .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));\n```\n情况3：使用`groupingBy()`生成的收集器，这是比较灵活的一种情况。跟SQL中的`group by`语句类似，这里的`groupingBy()`也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个`key`上。下列代码展示将员工按照部门进行分组：\n```java\n// Group employees by department\nMap<Department, List<Employee>> byDept = employees.stream()\n            .collect(Collectors.groupingBy(Employee::getDepartment));\n```\n以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的`groupingBy()`能够满足这种需求。增强版的`groupingBy()`允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做**上游收集器**，之后执行其他运算的收集器叫做**下游收集器(downstream Collector)**。\n```java\n// 使用下游收集器统计每个部门的人数\nMap<Department, Integer> totalByDept = employees.stream()\n                    .collect(Collectors.groupingBy(Employee::getDepartment,\n                                                   Collectors.counting()));// 下游收集器\n```\n上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：\n```java\n// 按照部门对员工分布组，并只保留员工的名字\nMap<Department, List<String>> byDept = employees.stream()\n                .collect(Collectors.groupingBy(Employee::getDepartment,\n                        Collectors.mapping(Employee::getName,// 下游收集器\n                                Collectors.toList())));// 更下游的收集器\n```\n#### 使用collect()做字符串join\n这个肯定是大家喜闻乐见的功能，字符串拼接时使用`Collectors.joining()`生成的收集器，从此告别`for`循环。`Collectors.joining()`方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。\n```java\n// 使用Collectors.joining()拼接字符串\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\");\n//String joined = stream.collect(Collectors.joining());// \"Iloveyou\"\n//String joined = stream.collect(Collectors.joining(\",\"));// \"I,love,you\"\nString joined = stream.collect(Collectors.joining(\",\", \"{\", \"}\"));// \"{I,love,you}\"\n```\n#### collect()还可以做更多\n除了可以使用Collectors工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用`collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)`方法，收集任何形式你想要的信息。不过Collectors工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。\n\n## Java Stream流水线\nStream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线的原理，这是Stream实现的关键所在。\n\n容器执行Lambda表达式的方式，以`ArrayList.forEach()`方法为例，具体代码如下：\n```java\n// ArrayList.forEach()\npublic void forEach(Consumer<? super E> action) {\n    ...\n    for (int i=0; modCount == expectedModCount && i < size; i++) {\n        action.accept(elementData[i]);// 回调方法\n    }\n    ...\n}\n```\n我们看到`ArrayList.forEach()`方法的主要逻辑就是一个for循环，在该for循环里不断调用`action.accept()`回调方法完成对元素的遍历。这完全没有什么新奇之处，回调方法在Java GUI的监听器中广泛使用。Lambda表达式的作用就是相当于一个回调方法，这很好理解。\n\nStream API中大量使用Lambda表达式作为回调方法，但这并不是关键。理解Stream我们更关心的是另外两个问题：流水线和自动并行。使用Stream或许很容易写入如下形式的代码：\n\n```java\nint longestStringLengthStartingWithA\n        = strings.stream()\n              .filter(s -> s.startsWith(\"A\"))\n              .mapToInt(String::length)\n              .max();\n```\n上述代码求出以字母A开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。类库的实现着使用流水线（Pipeline）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了Stream的所有操作。\n|Stream操作分类|||\n|--------:|---------:|---------:|\n|中间操作(Intermediate operations)|无状态(Stateless)|unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()|\n||有状态(Stateful)|distinct() sorted() sorted() limit() skip()|\n|结束操作(Terminal operations)|非短路操作|forEach() forEachOrdered() toArray() reduce() collect() max() min() count()|\n||短路操作(short-circuiting)|anyMatch() allMatch() noneMatch() findFirst() findAny()|\n\nStream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。\n\n### 一种直白的实现方式\n仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。具体说来，就是调用`filter()`方法后立即执行，选出所有以A开头的字符串并放到一个列表`list1`中，之后让`list1`传递给`mapToInt()`方法并立即执行，生成的结果放到`list2`中，最后遍历`list2`找出最大的数字作为最终结果。程序的执行流程如如所示：\n![一种直白的实现方式](http://ozqzyzixv.bkt.clouddn.com/1.png)\n\n这样做实现起来非常简单直观，但有两个明显的弊端：\n* 迭代次数多。迭代次数跟函数调用的次数相等。\n* 频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。\n\n这些弊端使得效率底下，根本无法接受。如果不使用Stream API我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：\n```java\nint longest = 0;\nfor(String str : strings){\n    if(str.startsWith(\"A\")){// 1. filter(), 保留以A开头的字符串\n        int len = str.length();// 2. mapToInt(), 转换成长度\n        longest = Math.max(len, longest);// 3. max(), 保留最长的长度\n    }\n}\n```\n采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟Stream API等价的功能，但问题是Stream类库的设计者并不知道用户的意图是什么。如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。\n### Stream流水线解决方案\n我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：\n\n* 用户的操作如何记录？\n* 操作如何叠加？\n* 叠加之后的操作如何执行？\n* 执行后的结果（如果有）在哪里？\n\n#### 操作如何记录\n注意这里使用的是“操作(operation)”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是<数据来源，操作，回调函数>构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。\n![Stream相关类和接口的继承关系图](http://ozqzyzixv.bkt.clouddn.com/Stream%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png)\n\n还有IntPipeline, LongPipeline, DoublePipeline没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟ReferencePipeline是并列关系。图中Head用于表示第一个Stage，即调用调用诸如Collection.stream()方法产生的Stage，很显然这个Stage里不包含任何操作；StatelessOp和StatefulOp分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。\n\nStream流水线组织结构示意图如下：\n![Stream流水线组织结构示意图](http://ozqzyzixv.bkt.clouddn.com/Stream%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n图中通过`Collection.stream()`方法得到Head也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作。这就是Stream记录操作的方式。\n\n#### 操作如何叠加\n以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。\n\n|方法名|作用|\n|---:|---:|\n|`void begin(long size)`|开始遍历元素之前调用该方法，通知Sink做好准备。|\n|`void end()`|所有元素遍历完成之后调用，通知Sink没有更多的元素了。|\n|`boolean cancellationRequested()`|是否可以结束操作，可以让短路操作尽早结束。|\n|`void accept(T t)`|遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前`Stage.accept(T t)`方法就行了。|\n\n有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的`accept()`方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink的`begin()`和`end()`方法也是必须实现的。比如`Stream.sorted()`是一个有状态的中间操作，其对应的`Sink.begin()`方法可能创建一个乘放结果的容器，而`accept()`方法负责将元素添加到该容器，最后`end()`负责对容器进行排序。对于短路操作，`Sink.cancellationRequested()`也是必须实现的，比如`Stream.findFirst()`是短路操作，只要找到一个元素，`cancellationRequested()`就应该返回true，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。实际上Stream API内部实现的的本质，就是如何重载Sink的这四个接口方法。\n\n有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的`Sink.{begin(), accept(), cancellationRequested(), end()}`方法就可以了。一种可能的`Sink.accept()`方法流程是这样的：\n```java\nvoid accept(U u){\n    1. 使用当前Sink包装的回调函数处理u\n    2. 将处理结果传递给流水线下游的Sink\n}\n```\nSink接口的其他几个方法也是按照这种[处理->转发]的模型实现。下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看`Stream.map()`方法：\n\n```java\n// Stream.map()，调用该方法将产生一个新的Stream\npublic final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) {\n    ...\n    return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,\n                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {\n        @Override /*opWripSink()方法返回由回调函数包装而成Sink*/\n        Sink<P_OUT> opWrapSink(int flags, Sink<R> downstream) {\n            return new Sink.ChainedReference<P_OUT, R>(downstream) {\n                @Override\n                public void accept(P_OUT u) {\n                    R r = mapper.apply(u);// 1. 使用当前Sink包装的回调函数mapper处理u\n                    downstream.accept(r);// 2. 将处理结果传递给流水线下游的Sink\n                }\n            };\n        }\n    };\n}\n```\n上述代码看似复杂，其实逻辑很简单，就是将回调函数`mapper`包装到一个Sink当中。由于`Stream.map()`是一个无状态的中间操作，所以`map()`方法返回了一个`StatelessOp`内部类对象（一个新的Stream），调用这个新Stream的`opWripSink()`方法将得到一个包装了当前回调函数的Sink。\n\n再来看一个复杂一点的例子。`Stream.sorted()`方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，`sorted()`方法是如何将操作封装成Sink的呢？`sorted()`一种可能封装的Sink代码如下：\n```java\n// Stream.sort()方法用到的Sink实现\nclass RefSortingSink<T> extends AbstractRefSortingSink<T> {\n    private ArrayList<T> list;// 存放用于排序的元素\n    RefSortingSink(Sink<? super T> downstream, Comparator<? super T> comparator) {\n        super(downstream, comparator);\n    }\n    @Override\n    public void begin(long size) {\n        ...\n        // 创建一个存放排序元素的列表\n        list = (size >= 0) ? new ArrayList<T>((int) size) : new ArrayList<T>();\n    }\n    @Override\n    public void end() {\n        list.sort(comparator);// 只有元素全部接收之后才能开始排序\n        downstream.begin(list.size());\n        if (!cancellationWasRequested) {// 下游Sink不包含短路操作\n            list.forEach(downstream::accept);// 2. 将处理结果传递给流水线下游的Sink\n        }\n        else {// 下游Sink包含短路操作\n            for (T t : list) {// 每次都调用cancellationRequested()询问是否可以结束处理。\n                if (downstream.cancellationRequested()) break;\n                downstream.accept(t);// 2. 将处理结果传递给流水线下游的Sink\n            }\n        }\n        downstream.end();\n        list = null;\n    }\n    @Override\n    public void accept(T t) {\n        list.add(t);// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中\n    }\n}\n```\n上述代码完美的展现了Sink的四个接口方法是如何协同工作的：\n\n* 首先`beging()`方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；\n* 之后通过`accept()`方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；\n* 最后`end()`方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；\n* 如果下游的Sink是短路操作，将结果传递给下游时不断询问下游`cancellationRequested()`是否可以结束处理。\n#### 叠加之后的操作如何执行\nSink完美封装了Stream每一步操作，并给出了[处理->转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。\n\n结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理->转发]模型，结束操作的Sink就是调用链的出口。\n\n![流水线的执行](http://ozqzyzixv.bkt.clouddn.com/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%89%A7%E8%A1%8C.png)\n\n我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在PipelineHelper中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个`Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)`方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：\n```java\n// AbstractPipeline.wrapSink()\n// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，\n// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。\nfinal <P_IN> Sink<P_IN> wrapSink(Sink<E_OUT> sink) {\n    ...\n    for (AbstractPipeline p=AbstractPipeline.this; p.depth > 0; p=p.previousStage) {\n        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);\n    }\n    return (Sink<P_IN>) sink;\n}\n```\n现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下：\n```java\n// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。\nfinal <P_IN> void copyInto(Sink<P_IN> wrappedSink, Spliterator<P_IN> spliterator) {\n    ...\n    if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {\n        wrappedSink.begin(spliterator.getExactSizeIfKnown());// 通知开始遍历\n        spliterator.forEachRemaining(wrappedSink);// 迭代\n        wrappedSink.end();// 通知遍历结束\n    }\n    ...\n}\n```\n上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器，参阅），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。\n\n#### 执行后的结果在哪里\n最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(Side-effects)，比如使用`Stream.forEach()`方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？\n\n**特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。**\n\n```java\n// 错误的收集方式\nArrayList<String> results = new ArrayList<>();\nstream.filter(s -> pattern.matcher(s).matches())\n      .forEach(s -> results.add(s));  // Unnecessary use of side-effects!\n// 正确的收集方式\nList<String>results =\n     stream.filter(s -> pattern.matcher(s).matches())\n             .collect(Collectors.toList());  // No side-effects!\n```\n回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。\n|返回类型\t|对应的结束操作\t|\n|----------:|----------:|\n|boolean|anyMatch() allMatch() noneMatch()|\n|Optional|findFirst() findAny()|\n|归约结果\t|reduce() collect()|\n|数组|toArray()|\n\n* 对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。\n* 对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用reduce()方法实现的。\n* 对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做Node的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。\n\n参考资料：\n\n[《深入理解Java函数式编程》系列文章](http://www.cnblogs.com/CarpenterLee/p/6729368.html)\n\n[《深入理解Java 8 Lambda》系列文章](http://lucida.me/)\n","slug":"Java/basic/Java-Stream-API-Research","published":1,"updated":"2017-12-15T08:12:58.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqr001s6dofntrh7cc9","content":"<h2 id=\"Lambda表达式和匿名内部类\"><a href=\"#Lambda表达式和匿名内部类\" class=\"headerlink\" title=\"Lambda表达式和匿名内部类\"></a>Lambda表达式和匿名内部类</h2><p>昨天突然看到一篇关于JDK1.8 Stream 讲解的文章，之前一直是简单的使用，并没有仔细分析过其中的细节。仅仅做到了知其然，看了那位大牛的博客后，打算花一些时间，尽力做到知其所以然。本文是对<a href=\"http://www.cnblogs.com/CarpenterLee/p/6729368.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java函数式编程》</a>系列文章的合并整理</p>\n<h3 id=\"取代某些匿名内部类\"><a href=\"#取代某些匿名内部类\" class=\"headerlink\" title=\"取代某些匿名内部类\"></a>取代某些匿名内部类</h3><p>Java Lambda表达式的一个重要用法是简化某些匿名内部类（<code>Anonymous Classes</code>）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的。</p>\n<h4 id=\"demo1-无参函数的简写\"><a href=\"#demo1-无参函数的简写\" class=\"headerlink\" title=\"demo1: 无参函数的简写\"></a>demo1: 无参函数的简写</h4><p>如果需要新建一个线程，一种常见的写法是这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK7 匿名内部类写法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;<span class=\"comment\">// 接口名</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">// 方法名</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Thread run()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure></p>\n<p>上述代码给<code>Tread</code>类传递了一个匿名的<code>Runnable</code>对象，重载<code>Runnable</code>接口的<code>run()</code>方法来实现相应逻辑。这是JDK7以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在Java 8中可以简化为如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK8 Lambda表达式代码块写法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">        () -&gt; &#123;</span><br><span class=\"line\">            System.out.print(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\" Hoolee\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">).start();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"demo2-带参函数的简写\"><a href=\"#demo2-带参函数的简写\" class=\"headerlink\" title=\"demo2: 带参函数的简写\"></a>demo2: 带参函数的简写</h4><p>如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK7 匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;<span class=\"comment\">// 接口名</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;<span class=\"comment\">// 方法名</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s2 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码通过内部类重载了<code>Comparator</code>接口的<code>compare()</code>方法，实现比较逻辑。采用Lambda表达式可简写如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK8 Lambda表达式写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;<span class=\"comment\">// 省略参数表的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s1 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s2 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于javac的<strong>类型推断机制</strong>，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java是强类型语言，每个变量和对象都必需有明确的类型。</p>\n<h3 id=\"简写的依据\"><a href=\"#简写的依据\" class=\"headerlink\" title=\"简写的依据\"></a>简写的依据</h3><p>也许你已经想到了，能够使用<strong>Lambda</strong>的依据是必须有相应的函数接口（函数接口，是指内部只有一个抽象方法的接口）。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上<strong>Lambda</strong>的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。<strong>Lambda</strong>表达更多合法的书写形式如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lambda表达式的书写形式</span></span><br><span class=\"line\">Runnable run = () -&gt; System.out.println(<span class=\"string\">\"Hello World\"</span>);<span class=\"comment\">// 1</span></span><br><span class=\"line\">ActionListener listener = event -&gt; System.out.println(<span class=\"string\">\"button clicked\"</span>);<span class=\"comment\">// 2</span></span><br><span class=\"line\">Runnable multiLine = () -&gt; &#123;<span class=\"comment\">// 3 代码块</span></span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\" Hoolee\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;<span class=\"comment\">// 4</span></span><br><span class=\"line\">BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;<span class=\"comment\">// 5 类型推断</span></span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，1展示了无参函数的简写；2处展示了有参函数的简写，以及类型推断机制；3是代码块的写法；4和5再次展示了类型推断机制。</p>\n<h3 id=\"自定义函数接口\"><a href=\"#自定义函数接口\" class=\"headerlink\" title=\"自定义函数接口\"></a>自定义函数接口</h3><p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义函数接口</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConsumerInterface</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中的<strong>@FunctionalInterface</strong>是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。<strong>就像加入@Override标注会检查是否重载了函数一样。</strong><br>有了上述接口定义，就可以写出类似如下的代码：</p>\n<p><code>ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</code></p>\n<p>进一步的，还可以这样使用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStream</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;T&gt; list;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">myForEach</span><span class=\"params\">(ConsumerInterface&lt;T&gt; consumer)</span></span>&#123;<span class=\"comment\">// 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(T t : list)&#123;</span><br><span class=\"line\">            consumer.accept(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyStream&lt;String&gt; stream = <span class=\"keyword\">new</span> MyStream&lt;String&gt;();</span><br><span class=\"line\">stream.myForEach(str -&gt; System.out.println(str));<span class=\"comment\">// 使用自定义函数接口书写Lambda表达式</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不是匿名内部类的简写\"><a href=\"#不是匿名内部类的简写\" class=\"headerlink\" title=\"不是匿名内部类的简写\"></a>不是匿名内部类的简写</h3><p>经过上面的介绍，我们看到Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。</p>\n<h4 id=\"匿名内部类实现\"><a href=\"#匿名内部类实现\" class=\"headerlink\" title=\"匿名内部类实现\"></a>匿名内部类实现</h4><p>匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名。因此如果有如下形式的代码，编译之后将会产生两个class文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainAnonymousClass</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"Anonymous Class Thread run()\"</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;).start();;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>进一步分析主类MainAnonymousClass.class的字节码，可发现其创建了匿名内部类的对象：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javap -c MainAnonymousClass.class</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainAnonymousClass</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       0: new           #2                  // class java/lang/Thread</span><br><span class=\"line\">       <span class=\"number\">3</span>: dup</span><br><span class=\"line\">       4: new           #3                  // class MainAnonymousClass$1 /*创建内部类对象*/</span><br><span class=\"line\">       <span class=\"number\">7</span>: dup</span><br><span class=\"line\">       8: invokespecial #4                  // Method MainAnonymousClass$1.\"&lt;init&gt;\":()V</span><br><span class=\"line\">      11: invokespecial #5                  // Method java/lang/Thread.\"&lt;init&gt;\":(Ljava/lang/Runnable;)V</span><br><span class=\"line\">      14: invokevirtual #6                  // Method java/lang/Thread.start:()V</span><br><span class=\"line\">      <span class=\"number\">17</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Lambda表达式实现\"><a href=\"#Lambda表达式实现\" class=\"headerlink\" title=\"Lambda表达式实现\"></a>Lambda表达式实现</h4><p><strong>Lambda</strong>表达式通过<strong>invokedynamic</strong>指令实现，书写<strong>Lambda</strong>表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainLambda</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">\t\t\t\t() -&gt; System.out.println(<span class=\"string\">\"Lambda Thread run()\"</span>)</span><br><span class=\"line\">\t\t\t).start();;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过javap反编译命名，我们更能看出Lambda表达式内部表示的不同：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javap -c -p MainLambda.class</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainLambda</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       0: new           #2                  // class java/lang/Thread</span><br><span class=\"line\">       <span class=\"number\">3</span>: dup</span><br><span class=\"line\">       4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/</span><br><span class=\"line\">       9: invokespecial #4                  // Method java/lang/Thread.\"&lt;init&gt;\":(Ljava/lang/Runnable;)V</span><br><span class=\"line\">      12: invokevirtual #5                  // Method java/lang/Thread.start:()V</span><br><span class=\"line\">      <span class=\"number\">15</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$main$<span class=\"number\">0</span>();  <span class=\"comment\">/*Lambda表达式被封装成主类的私有方法*/</span></span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">       3: ldc           #7                  // String Lambda Thread run()</span><br><span class=\"line\">       5: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法，并通过<strong>invokedynamic</strong>指令进行调用。</p>\n<h4 id=\"推论，this引用的意义\"><a href=\"#推论，this引用的意义\" class=\"headerlink\" title=\"推论，this引用的意义\"></a>推论，this引用的意义</h4><p>既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。因此下列代码将输出两遍Hello Hoolee，而不是两个引用地址。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">\tRunnable r1 = () -&gt; &#123; System.out.println(<span class=\"keyword\">this</span>); &#125;;</span><br><span class=\"line\">\tRunnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Hello().r1.run();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Hello().r2.run();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Hoolee\"</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Lambda表达式和Java集合框架\"><a href=\"#Lambda表达式和Java集合框架\" class=\"headerlink\" title=\"Lambda表达式和Java集合框架\"></a>Lambda表达式和Java集合框架</h2><p>Java8为容器新增一些有用的方法，这些方法有些是为完善原有功能，有些是为引入函数式编程（Lambda表达式），学习和使用这些方法有助于我们写出更加简洁有效的代码．本文分别以ArrayList和HashMap为例，讲解Java8集合框架（Java Collections Framework）中新加入方法的使用．</p>\n<h3 id=\"Collection中的新方法\"><a href=\"#Collection中的新方法\" class=\"headerlink\" title=\"Collection中的新方法\"></a>Collection中的新方法</h3><h4 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h4><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>\n<p>需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.</p>\n<p>Java7及以前我们可以用增强的for循环实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用曾强for循环迭代</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String str : list)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">        System.out.println(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合匿名内部类迭代</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.forEach(<span class=\"keyword\">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.forEach( str -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>\n<h4 id=\"removeIf\"><a href=\"#removeIf\" class=\"headerlink\" title=\"removeIf()\"></a>removeIf()</h4><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，作用是删除容器中所有满足<code>filter</code>指定条件的元素，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>\n<p>需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</p>\n<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用迭代器删除列表元素</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it.next().length()&gt;<span class=\"number\">3</span>) <span class=\"comment\">// 删除长度大于3的元素</span></span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.removeIf(<span class=\"keyword\">new</span> Predicate&lt;String&gt;()&#123; <span class=\"comment\">// 删除长度大于3的元素</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.length()&gt;<span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.removeIf(str -&gt; str.length()&gt;<span class=\"number\">3</span>); <span class=\"comment\">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure></p>\n<p>使用Lambda表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。</p>\n<h4 id=\"replaceAll\"><a href=\"#replaceAll\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h4><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>\n<p>需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</p>\n<p>Java7及之前似乎没有优雅的办法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用下标实现元素替换</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class=\"line\">    String str = list.get(i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">        list.set(i, str.toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用匿名内部类实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.replaceAll(<span class=\"keyword\">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">apply</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> str.toUpperCase();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Lambda表达式实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.replaceAll(str -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.toUpperCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h4><p>该方法定义在List接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法根据c指定的比较规则对容器元素进行排序。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>\n<p>需求：假设有一个字符串列表，按照字符串长度增序对元素排序。</p>\n<p>由于Java7以及之前sort()方法在Collections工具类中，所以代码要这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Collections.sort()方法</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String str1, String str2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str1.length()-str2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>现在可以直接使用<code>List.sort()</code>方法，结合Lambda表达式，可以这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// List.sort()方法结合Lambda表达式</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"spliterator\"><a href=\"#spliterator\" class=\"headerlink\" title=\"spliterator()\"></a>spliterator()</h4><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的可拆分迭代器。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>\n<ul>\n<li><code>Spliterator</code>既可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>\n<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是this，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>\n</ul>\n<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>\n<h4 id=\"stream-和parallelStream\"><a href=\"#stream-和parallelStream\" class=\"headerlink\" title=\"stream()和parallelStream()\"></a>stream()和parallelStream()</h4><p><code>stream()</code>和<code>parallelStream()</code>分别返回该容器的<code>Stream</code>视图表示，不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。</p>\n<h3 id=\"Map中的新方法\"><a href=\"#Map中的新方法\" class=\"headerlink\" title=\"Map中的新方法\"></a>Map中的新方法</h3><h4 id=\"forEach-1\"><a href=\"#forEach-1\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h4><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>，作用是对Map中的每个映射执行<code>action</code>指定的操作，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>\n<p>需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．</p>\n<p>Java7以及之前经典的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java7以及之前迭代Map</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">\"=\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.forEach(<span class=\"keyword\">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Integer k, String v)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(k + <span class=\"string\">\"=\"</span> + v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.forEach((k, v) -&gt; System.out.println(k + <span class=\"string\">\"=\"</span> + v));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"getOrDefault\"><a href=\"#getOrDefault\" class=\"headerlink\" title=\"getOrDefault()\"></a>getOrDefault()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是按照给定的<code>key</code>查询Map中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>\n<p>需求；假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出<code>NoValue</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Java7以及之前做法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(map.containsKey(<span class=\"number\">4</span>))&#123; <span class=\"comment\">// 1</span></span><br><span class=\"line\">    System.out.println(map.get(<span class=\"number\">4</span>));</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"NoValue\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Java8使用Map.getOrDefault()</span></span><br><span class=\"line\">System.out.println(map.getOrDefault(<span class=\"number\">4</span>, <span class=\"string\">\"NoValue\"</span>)); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"putIfAbsent\"><a href=\"#putIfAbsent\" class=\"headerlink\" title=\"putIfAbsent()\"></a>putIfAbsent()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在不存在key值的映射或映射值为<code>null</code>时，才将<code>value</code>指定的值放入到Map中，否则不对Map做更改．该方法将条件判断和赋值合二为一，使用起来更加方便</p>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h4><p>我们都知道Map中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除Map中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前Map中<code>key</code>正好映射到<code>value</code>时才删除该映射，否则什么也不做．</p>\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><p>在Java7及以前，要想替换Map中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在Map中加入了两个<code>replace()</code>方法，分别如下：</p>\n<ul>\n<li><code>replace(K key, V value)</code>，只有在当前Map中<code>key</code>的映射存在时才用<code>value</code>去替换原来的值，否则什么也不做．</li>\n<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前Map中key的映射存在且等于<code>oldValue</code>时才用<code>newValue</code>去替换原来的值，否则什么也不做．<h4 id=\"replaceAll-1\"><a href=\"#replaceAll-1\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h4>该方法签名为<code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>，作用是对Map中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</li>\n</ul>\n<p>需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．</p>\n<p>Java7以及之前经典的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.replaceAll(<span class=\"keyword\">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">apply</span><span class=\"params\">(Integer k, String v)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge()\"></a>merge()</h4><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>，作用是：</p>\n<ul>\n<li>如果Map中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是null）关联到<code>key</code>上；</li>\n<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在Map中删除<code>key</code>的映射．</li>\n</ul>\n<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>\n<p><code>merge()</code>方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>\n<p><code>map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</code></p>\n<h4 id=\"compute\"><a href=\"#compute\" class=\"headerlink\" title=\"compute()\"></a>compute()</h4><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在Map中删除<code>key</code>的映射．</p>\n<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>\n<p><code>map.compute(key, (k,v) -&gt; v==null ? newMsg : v.concat(newMsg));</code></p>\n<h4 id=\"computeIfAbsent\"><a href=\"#computeIfAbsent\" class=\"headerlink\" title=\"computeIfAbsent()\"></a>computeIfAbsent()</h4><p>该方法签名为<code>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>，作用是：只有在当前Map中不存在<code>key</code>值的映射或映射值为<code>null</code>时，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>\n<p>Function是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>\n<p><code>computeIfAbsent()</code>常用来对Map的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，Map的定义可能是<code>Map&lt;K,Set&lt;V&gt;&gt;</code>，要向Map中放入新值，可通过如下代码实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// Java7及以前的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(map.containsKey(<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">    map.get(<span class=\"number\">1</span>).add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    Set&lt;String&gt; valueSet = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">    valueSet.add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">1</span>, valueSet);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Java8的实现方式</span></span><br><span class=\"line\">map.computeIfAbsent(<span class=\"number\">1</span>, v -&gt; <span class=\"keyword\">new</span> HashSet&lt;String&gt;()).add(<span class=\"string\">\"yi\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>\n<h4 id=\"computeIfPresent\"><a href=\"#computeIfPresent\" class=\"headerlink\" title=\"computeIfPresent()\"></a>computeIfPresent()</h4><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前Map中存在<code>key</code>值的映射且非<code>null</code>时，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>\n<p>这个函数的功能跟如下代码是等效的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (map.get(key) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    V oldValue = map.get(key);</span><br><span class=\"line\">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.put(key, newValue);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        map.remove(key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Java-Stream-API入门\"><a href=\"#Java-Stream-API入门\" class=\"headerlink\" title=\"Java Stream API入门\"></a>Java Stream API入门</h2><p>Java 8之所以费这么大功夫引入函数式编程，原因有二：</p>\n<ul>\n<li>代码简洁，函数式编程写出的代码简洁且意图明确，使用<code>stream</code>接口让你从此告别for循环。</li>\n<li>多核友好，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下<code>parallel()</code>方法。</li>\n</ul>\n<p><code>stream</code>，也就是Java函数式编程的主角。对于Java 7来说stream完全是个陌生东西，stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如：</p>\n<ul>\n<li>调用<code>Collection.stream()</code>或者<code>Collection.parallelStream()</code>方法</li>\n<li>调用<code>Arrays.stream(T[] array)</code>方法</li>\n</ul>\n<p>常见的stream接口继承关系如图：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/Java_stream_Interfaces.png\" alt=\"avatar\"></p>\n<p>图中4种stream接口继承自<code>BaseStream</code>，其中<code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code>对应三种基本类型（<code>int</code>, <code>long</code>, <code>double</code>，注意不是包装类型），Stream对应所有剩余类型的<code>stream</code>视图。为不同数据类型设置不同<code>stream</code>接口，可以 1.提高性能，2.增加特定接口函数。</p>\n<p>你可能会奇怪为什么不把<code>IntStream</code>等设计成<code>Stream</code>的子接口？毕竟这接口中的方法名大部分是一样的。答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。</p>\n<p>虽然大部分情况下<code>stream</code>是容器调用<code>Collection.stream()</code>方法得到的，但<code>stream</code>和<code>collections</code>有以下不同：</p>\n<ul>\n<li>无存储。<code>stream</code>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>\n<li>为函数式编程而生。对<code>stream</code>的任何修改都不会修改背后的数据源，比如对<code>stream</code>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<code>stream</code>。</li>\n<li>惰式执行。<code>stream</code>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li>可消费性。<code>stream</code>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n<p>对<code>stream</code>的操作分为为两类，中间操作(<code>intermediate operations</code>)和结束操作(<code>terminal operations</code>)，二者特点是：</p>\n<ul>\n<li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新<code>stream</code>，仅此而已。</li>\n<li>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以<code>pipeline</code>的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>\n</ul>\n<p>下表汇总了Stream接口的部分常见方法：</p>\n<table>\n<thead>\n<tr>\n<th>操作类型</th>\n<th style=\"text-align:center\">接口方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>中间操作</td>\n<td style=\"text-align:center\">concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td style=\"text-align:center\">allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>\n</tr>\n</tbody>\n</table>\n<p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。</p>\n<h3 id=\"stream方法使用\"><a href=\"#stream方法使用\" class=\"headerlink\" title=\"stream方法使用\"></a>stream方法使用</h3><p><code>stream</code>跟函数接口关系非常紧密，没有函数接口<code>stream</code>就无法工作。回顾一下：函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。</p>\n<h4 id=\"forEach-2\"><a href=\"#forEach-2\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h4><p>我们对<code>forEach()</code>方法并不陌生，在<code>Collection</code>中我们已经见过。方法签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，也就是对元素进行遍历。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Stream.forEach()迭代</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。</p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h4><p>函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足<code>predicate</code>条件元素的Stream。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 保留长度等于3的字符串</span></span><br><span class=\"line\">Stream&lt;String&gt; stream= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.filter(str -&gt; str.length()==<span class=\"number\">3</span>)</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码将输出为长度等于3的字符串<code>you</code>和<code>too</code>。注意，由于<code>filter()</code>是个中间操作，如果只调用<code>filter()</code>不会有实际计算，因此也不会输出任何信息。</p>\n<h4 id=\"distinct\"><a href=\"#distinct\" class=\"headerlink\" title=\"distinct()\"></a>distinct()</h4><p>函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的<code>Stream</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.distinct()</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码会输出去掉一个too之后的其余字符串。</p>\n<h4 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted()\"></a>sorted()</h4><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt;　sorted()和Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.sorted((str1, str2) -&gt; str1.length()-str2.length())</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h4><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream　= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.map(str -&gt; str.toUpperCase())</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码将输出原字符串的大写形式。</p>\n<h4 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap()\"></a>flatMap()</h4><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<code>stream</code>中的所有元素都”摊平”之后组成的Stream，转换前后元素的个数和类型都可能会改变。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>), Arrays.asList(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">stream.flatMap(list -&gt; list.stream())</span><br><span class=\"line\">    .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，原来的stream中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个List都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的Stream。所以最终将输出1~5这5个数字。</p>\n<h2 id=\"Java-Stream-API进阶\"><a href=\"#Java-Stream-API进阶\" class=\"headerlink\" title=\"Java Stream API进阶\"></a>Java Stream API进阶</h2><p>规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。</p>\n<p>最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍<code>reduce()</code>和<code>collect()</code>，这是比较有魔法的地方。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p><code>reduce</code>操作可以实现从一组元素中生成一个值，<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等都是<code>reduce</code>操作，将他们单独设为函数只是因为常用。<code>reduce()</code>的方法定义有三种重写形式：</p>\n<ul>\n<li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></li>\n<li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></li>\n<li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></li>\n</ul>\n<p>虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。</p>\n<p>需求：从一组单词中找出最长的单词。这里“大”的含义就是“长”。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class=\"line\"><span class=\"comment\">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class=\"line\">System.out.println(longest.get());</span><br></pre></td></tr></table></figure></p>\n<p>上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用<code>Stream.max(Comparator&lt;? super T&gt; comparator)</code>方法来达到同等效果，但<code>reduce()</code>自有其存在的理由。</p>\n<p>需求：求出一组单词的长度之和。这是个“求和”操作，操作对象输入类型是String，而结果类型是Integer。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求单词长度之和</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Integer lengthSum = stream.reduce(<span class=\"number\">0</span>,　<span class=\"comment\">// 初始值　// (1)</span></span><br><span class=\"line\">        (sum, str) -&gt; sum+str.length(), <span class=\"comment\">// 累加器 // (2)</span></span><br><span class=\"line\">        (a, b) -&gt; a+b);　<span class=\"comment\">// 部分和拼接器，并行执行时才会用到 // (3)</span></span><br><span class=\"line\"><span class=\"comment\">// int lengthSum = stream.mapToInt(str -&gt; str.length()).sum();</span></span><br><span class=\"line\">System.out.println(lengthSum);</span><br></pre></td></tr></table></figure>\n<p>上述代码标号(2)处将i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用<code>reduce()</code>函数将这两步合二为一，更有助于提升性能。如果想要使用<code>map()</code>和<code>sum()</code>组合来达到上述目的，也是可以的。</p>\n<p><code>reduce()</code>擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？终极武器<code>collect()</code>横空出世！</p>\n<h3 id=\"collect\"><a href=\"#collect\" class=\"headerlink\" title=\"collect()\"></a>collect()</h3><p>不夸张的讲，如果你发现某个功能在Stream接口中没找到，十有八九可以通过<code>collect()</code>方法实现。<code>collect()</code>是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。先看几个热身的小例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Stream转换成容器或Map</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"comment\">// Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span></span><br><span class=\"line\"><span class=\"comment\">// Map&lt;String, Integer&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)</span></span><br></pre></td></tr></table></figure></p>\n<p>上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问：</p>\n<ul>\n<li><code>Function.identity()</code>是干什么的？</li>\n<li><code>String::length</code>是什么意思？</li>\n<li><code>Collectors</code>是个什么东西？</li>\n</ul>\n<h4 id=\"接口的静态方法和默认方法\"><a href=\"#接口的静态方法和默认方法\" class=\"headerlink\" title=\"接口的静态方法和默认方法\"></a>接口的静态方法和默认方法</h4><p>Function是一个接口，那么<code>Function.identity()</code>是什么意思呢？这要从两方面解释：</p>\n<ul>\n<li>Java 8允许在接口中加入具体方法。接口中的具体方法有两种，<code>default</code>方法和<code>static</code>方法，<code>identity()</code>就是Function接口的一个静态方法。</li>\n<li><code>Function.identity()</code>返回一个输出跟输入一样的Lambda表达式对象，等价于形如<code>t -&gt; t</code>形式的Lambda表达式。</li>\n</ul>\n<p>上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得<code>t -&gt; t</code>比<code>identity()</code>方法更直观。我会告诉你接口中的<code>default</code>方法是一个无奈之举，在Java 7及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在Collection接口中加入一个stream()抽象方法会怎样？<code>default</code>方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了<code>default</code>方法，为何不再加入<code>static</code>方法来避免专门的工具类呢！</p>\n<h4 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h4><p>诸如<code>String::length</code>的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：</p>\n<table>\n<thead>\n<tr>\n<th>方法引用类别</th>\n<th style=\"text-align:center\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>引用静态方法</td>\n<td style=\"text-align:center\"><code>Integer::sum</code></td>\n</tr>\n<tr>\n<td>引用某个对象的方法</td>\n<td style=\"text-align:center\"><code>list::add</code></td>\n</tr>\n<tr>\n<td>引用某个类的方法</td>\n<td style=\"text-align:center\"><code>String::length</code></td>\n</tr>\n<tr>\n<td>引用构造方法</td>\n<td style=\"text-align:center\"><code>HashMap::new</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"收集器\"><a href=\"#收集器\" class=\"headerlink\" title=\"收集器\"></a>收集器</h4><p>收集器（Collector）是为<code>Stream.collect()</code>方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：</p>\n<ul>\n<li>目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。</li>\n<li>新元素如何添加到容器中？是List.add()还是Map.put()。如果并行的进行规约，还需要告诉<code>collect()</code> </li>\n<li>多个部分结果如何合并成一个。</li>\n</ul>\n<p>结合以上分析，<code>collect()</code>方法定义为<code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>，三个参数依次对应上述三条分析。不过每次调用<code>collect()</code>都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以<code>collect()</code>的另一定义为<code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</code>。Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　将Stream规约成List</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">List&lt;String&gt; list = stream.collect(ArrayList::<span class=\"keyword\">new</span>, ArrayList::add, ArrayList::addAll);<span class=\"comment\">// 方式１</span></span><br><span class=\"line\"><span class=\"comment\">//List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure></p>\n<p>通常情况下我们不需要手动指定<code>collect()</code>的三个参数，而是调用<code>collect(Collector&lt;? super T,A,R&gt; collector)</code>方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了<code>collect()</code>的行为。</p>\n<h4 id=\"使用collect-生成Collection\"><a href=\"#使用collect-生成Collection\" class=\"headerlink\" title=\"使用collect()生成Collection\"></a>使用collect()生成Collection</h4><p>前面已经提到通过<code>collect()</code>方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Stream转换成List或Set</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class=\"comment\">// (1)</span></span><br><span class=\"line\">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); <span class=\"comment\">// (2)</span></span><br></pre></td></tr></table></figure>\n<p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用toCollection()指定规约容器的类型</span></span><br><span class=\"line\">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class=\"keyword\">new</span>));<span class=\"comment\">// (3)</span></span><br><span class=\"line\">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class=\"keyword\">new</span>));<span class=\"comment\">// (4)</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用collect-生成Map\"><a href=\"#使用collect-生成Map\" class=\"headerlink\" title=\"使用collect()生成Map\"></a>使用collect()生成Map</h4><p>前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的<code>key</code>和<code>value</code>分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下<code>collect()</code>的结果会是Map：</p>\n<ul>\n<li>使用<code>Collectors.toMap()</code>生成的收集器，用户需要指定如何生成Map的<code>key</code>和<code>value</code>。</li>\n<li>使用<code>Collectors.partitioningBy()</code>生成的收集器，对元素进行二分区操作时用到。</li>\n<li>使用<code>Collectors.groupingBy()</code>生成的收集器，对元素做<code>group</code>操作时用到。<br>情况1：使用<code>toMap()</code>生成的收集器，这种情况是最直接的，前面例子中已提到，这是和<code>Collectors.toCollection()</code>并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的Map。非常直观，无需多言。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用toMap()统计学生GPA</span></span><br><span class=\"line\">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class=\"line\">     students.stream().collect(Collectors.toMap(Functions.identity(),<span class=\"comment\">// 如何生成key</span></span><br><span class=\"line\">                                     student -&gt; computeGPA(student)));<span class=\"comment\">// 如何生成value</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>情况2：使用<code>partitioningBy()</code>生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Partition students into passing and failing</span></span><br><span class=\"line\">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class=\"line\">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure></p>\n<p>情况3：使用<code>groupingBy()</code>生成的收集器，这是比较灵活的一种情况。跟SQL中的<code>group by</code>语句类似，这里的<code>groupingBy()</code>也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个<code>key</code>上。下列代码展示将员工按照部门进行分组：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Group employees by department</span></span><br><span class=\"line\">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class=\"line\">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure></p>\n<p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的<code>groupingBy()</code>能够满足这种需求。增强版的<code>groupingBy()</code>允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做<strong>上游收集器</strong>，之后执行其他运算的收集器叫做<strong>下游收集器(downstream Collector)</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用下游收集器统计每个部门的人数</span></span><br><span class=\"line\">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class=\"line\">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class=\"line\">                                                   Collectors.counting()));<span class=\"comment\">// 下游收集器</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照部门对员工分布组，并只保留员工的名字</span></span><br><span class=\"line\">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class=\"line\">                        Collectors.mapping(Employee::getName,<span class=\"comment\">// 下游收集器</span></span><br><span class=\"line\">                                Collectors.toList())));<span class=\"comment\">// 更下游的收集器</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用collect-做字符串join\"><a href=\"#使用collect-做字符串join\" class=\"headerlink\" title=\"使用collect()做字符串join\"></a>使用collect()做字符串join</h4><p>这个肯定是大家喜闻乐见的功能，字符串拼接时使用<code>Collectors.joining()</code>生成的收集器，从此告别<code>for</code>循环。<code>Collectors.joining()</code>方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Collectors.joining()拼接字符串</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//String joined = stream.collect(Collectors.joining());// \"Iloveyou\"</span></span><br><span class=\"line\"><span class=\"comment\">//String joined = stream.collect(Collectors.joining(\",\"));// \"I,love,you\"</span></span><br><span class=\"line\">String joined = stream.collect(Collectors.joining(<span class=\"string\">\",\"</span>, <span class=\"string\">\"&#123;\"</span>, <span class=\"string\">\"&#125;\"</span>));<span class=\"comment\">// \"&#123;I,love,you&#125;\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"collect-还可以做更多\"><a href=\"#collect-还可以做更多\" class=\"headerlink\" title=\"collect()还可以做更多\"></a>collect()还可以做更多</h4><p>除了可以使用Collectors工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用<code>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>方法，收集任何形式你想要的信息。不过Collectors工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。</p>\n<h2 id=\"Java-Stream流水线\"><a href=\"#Java-Stream流水线\" class=\"headerlink\" title=\"Java Stream流水线\"></a>Java Stream流水线</h2><p>Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线的原理，这是Stream实现的关键所在。</p>\n<p>容器执行Lambda表达式的方式，以<code>ArrayList.forEach()</code>方法为例，具体代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ArrayList.forEach()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class=\"line\">        action.accept(elementData[i]);<span class=\"comment\">// 回调方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看到<code>ArrayList.forEach()</code>方法的主要逻辑就是一个for循环，在该for循环里不断调用<code>action.accept()</code>回调方法完成对元素的遍历。这完全没有什么新奇之处，回调方法在Java GUI的监听器中广泛使用。Lambda表达式的作用就是相当于一个回调方法，这很好理解。</p>\n<p>Stream API中大量使用Lambda表达式作为回调方法，但这并不是关键。理解Stream我们更关心的是另外两个问题：流水线和自动并行。使用Stream或许很容易写入如下形式的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> longestStringLengthStartingWithA</span><br><span class=\"line\">        = strings.stream()</span><br><span class=\"line\">              .filter(s -&gt; s.startsWith(<span class=\"string\">\"A\"</span>))</span><br><span class=\"line\">              .mapToInt(String::length)</span><br><span class=\"line\">              .max();</span><br></pre></td></tr></table></figure>\n<p>上述代码求出以字母A开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。类库的实现着使用流水线（Pipeline）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了Stream的所有操作。<br>|Stream操作分类|||<br>|——–:|———:|———:|<br>|中间操作(Intermediate operations)|无状态(Stateless)|unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()|<br>||有状态(Stateful)|distinct() sorted() sorted() limit() skip()|<br>|结束操作(Terminal operations)|非短路操作|forEach() forEachOrdered() toArray() reduce() collect() max() min() count()|<br>||短路操作(short-circuiting)|anyMatch() allMatch() noneMatch() findFirst() findAny()|</p>\n<p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p>\n<h3 id=\"一种直白的实现方式\"><a href=\"#一种直白的实现方式\" class=\"headerlink\" title=\"一种直白的实现方式\"></a>一种直白的实现方式</h3><p>仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。具体说来，就是调用<code>filter()</code>方法后立即执行，选出所有以A开头的字符串并放到一个列表<code>list1</code>中，之后让<code>list1</code>传递给<code>mapToInt()</code>方法并立即执行，生成的结果放到<code>list2</code>中，最后遍历<code>list2</code>找出最大的数字作为最终结果。程序的执行流程如如所示：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/1.png\" alt=\"一种直白的实现方式\"></p>\n<p>这样做实现起来非常简单直观，但有两个明显的弊端：</p>\n<ul>\n<li>迭代次数多。迭代次数跟函数调用的次数相等。</li>\n<li>频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。</li>\n</ul>\n<p>这些弊端使得效率底下，根本无法接受。如果不使用Stream API我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> longest = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String str : strings)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.startsWith(<span class=\"string\">\"A\"</span>))&#123;<span class=\"comment\">// 1. filter(), 保留以A开头的字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = str.length();<span class=\"comment\">// 2. mapToInt(), 转换成长度</span></span><br><span class=\"line\">        longest = Math.max(len, longest);<span class=\"comment\">// 3. max(), 保留最长的长度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟Stream API等价的功能，但问题是Stream类库的设计者并不知道用户的意图是什么。如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。</p>\n<h3 id=\"Stream流水线解决方案\"><a href=\"#Stream流水线解决方案\" class=\"headerlink\" title=\"Stream流水线解决方案\"></a>Stream流水线解决方案</h3><p>我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：</p>\n<ul>\n<li>用户的操作如何记录？</li>\n<li>操作如何叠加？</li>\n<li>叠加之后的操作如何执行？</li>\n<li>执行后的结果（如果有）在哪里？</li>\n</ul>\n<h4 id=\"操作如何记录\"><a href=\"#操作如何记录\" class=\"headerlink\" title=\"操作如何记录\"></a>操作如何记录</h4><p>注意这里使用的是“操作(operation)”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是&lt;数据来源，操作，回调函数&gt;构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/Stream%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"Stream相关类和接口的继承关系图\"></p>\n<p>还有IntPipeline, LongPipeline, DoublePipeline没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟ReferencePipeline是并列关系。图中Head用于表示第一个Stage，即调用调用诸如Collection.stream()方法产生的Stage，很显然这个Stage里不包含任何操作；StatelessOp和StatefulOp分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。</p>\n<p>Stream流水线组织结构示意图如下：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/Stream%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"Stream流水线组织结构示意图\"></p>\n<p>图中通过<code>Collection.stream()</code>方法得到Head也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作。这就是Stream记录操作的方式。</p>\n<h4 id=\"操作如何叠加\"><a href=\"#操作如何叠加\" class=\"headerlink\" title=\"操作如何叠加\"></a>操作如何叠加</h4><p>以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">方法名</th>\n<th style=\"text-align:right\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\"><code>void begin(long size)</code></td>\n<td style=\"text-align:right\">开始遍历元素之前调用该方法，通知Sink做好准备。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\"><code>void end()</code></td>\n<td style=\"text-align:right\">所有元素遍历完成之后调用，通知Sink没有更多的元素了。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\"><code>boolean cancellationRequested()</code></td>\n<td style=\"text-align:right\">是否可以结束操作，可以让短路操作尽早结束。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\"><code>void accept(T t)</code></td>\n<td style=\"text-align:right\">遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前<code>Stage.accept(T t)</code>方法就行了。</td>\n</tr>\n</tbody>\n</table>\n<p>有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的<code>accept()</code>方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink的<code>begin()</code>和<code>end()</code>方法也是必须实现的。比如<code>Stream.sorted()</code>是一个有状态的中间操作，其对应的<code>Sink.begin()</code>方法可能创建一个乘放结果的容器，而<code>accept()</code>方法负责将元素添加到该容器，最后<code>end()</code>负责对容器进行排序。对于短路操作，<code>Sink.cancellationRequested()</code>也是必须实现的，比如<code>Stream.findFirst()</code>是短路操作，只要找到一个元素，<code>cancellationRequested()</code>就应该返回true，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。实际上Stream API内部实现的的本质，就是如何重载Sink的这四个接口方法。</p>\n<p>有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的<code>Sink.{begin(), accept(), cancellationRequested(), end()}</code>方法就可以了。一种可能的<code>Sink.accept()</code>方法流程是这样的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(U u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>. 使用当前Sink包装的回调函数处理u</span><br><span class=\"line\">    <span class=\"number\">2</span>. 将处理结果传递给流水线下游的Sink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Sink接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看<code>Stream.map()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Stream.map()，调用该方法将产生一个新的Stream</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Stream&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class=\"keyword\">this</span>, StreamShape.REFERENCE,</span><br><span class=\"line\">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"comment\">/*opWripSink()方法返回由回调函数包装而成Sink*/</span></span><br><span class=\"line\">        <span class=\"function\">Sink&lt;P_OUT&gt; <span class=\"title\">opWrapSink</span><span class=\"params\">(<span class=\"keyword\">int</span> flags, Sink&lt;R&gt; downstream)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(P_OUT u)</span> </span>&#123;</span><br><span class=\"line\">                    R r = mapper.apply(u);<span class=\"comment\">// 1. 使用当前Sink包装的回调函数mapper处理u</span></span><br><span class=\"line\">                    downstream.accept(r);<span class=\"comment\">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码看似复杂，其实逻辑很简单，就是将回调函数<code>mapper</code>包装到一个Sink当中。由于<code>Stream.map()</code>是一个无状态的中间操作，所以<code>map()</code>方法返回了一个<code>StatelessOp</code>内部类对象（一个新的Stream），调用这个新Stream的<code>opWripSink()</code>方法将得到一个包装了当前回调函数的Sink。</p>\n<p>再来看一个复杂一点的例子。<code>Stream.sorted()</code>方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，<code>sorted()</code>方法是如何将操作封装成Sink的呢？<code>sorted()</code>一种可能封装的Sink代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Stream.sort()方法用到的Sink实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefSortingSink</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRefSortingSink</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;T&gt; list;<span class=\"comment\">// 存放用于排序的元素</span></span><br><span class=\"line\">    RefSortingSink(Sink&lt;? <span class=\"keyword\">super</span> T&gt; downstream, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; comparator) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(downstream, comparator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个存放排序元素的列表</span></span><br><span class=\"line\">        list = (size &gt;= <span class=\"number\">0</span>) ? <span class=\"keyword\">new</span> ArrayList&lt;T&gt;((<span class=\"keyword\">int</span>) size) : <span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        list.sort(comparator);<span class=\"comment\">// 只有元素全部接收之后才能开始排序</span></span><br><span class=\"line\">        downstream.begin(list.size());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cancellationWasRequested) &#123;<span class=\"comment\">// 下游Sink不包含短路操作</span></span><br><span class=\"line\">            list.forEach(downstream::accept);<span class=\"comment\">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 下游Sink包含短路操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (T t : list) &#123;<span class=\"comment\">// 每次都调用cancellationRequested()询问是否可以结束处理。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (downstream.cancellationRequested()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                downstream.accept(t);<span class=\"comment\">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        downstream.end();</span><br><span class=\"line\">        list = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        list.add(t);<span class=\"comment\">// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码完美的展现了Sink的四个接口方法是如何协同工作的：</p>\n<ul>\n<li>首先<code>beging()</code>方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；</li>\n<li>之后通过<code>accept()</code>方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；</li>\n<li>最后<code>end()</code>方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；</li>\n<li>如果下游的Sink是短路操作，将结果传递给下游时不断询问下游<code>cancellationRequested()</code>是否可以结束处理。<h4 id=\"叠加之后的操作如何执行\"><a href=\"#叠加之后的操作如何执行\" class=\"headerlink\" title=\"叠加之后的操作如何执行\"></a>叠加之后的操作如何执行</h4>Sink完美封装了Stream每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。</li>\n</ul>\n<p>结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理-&gt;转发]模型，结束操作的Sink就是调用链的出口。</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%89%A7%E8%A1%8C.png\" alt=\"流水线的执行\"></p>\n<p>我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在PipelineHelper中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个<code>Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)</code>方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AbstractPipeline.wrapSink()</span></span><br><span class=\"line\"><span class=\"comment\">// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN&gt; <span class=\"function\">Sink&lt;P_IN&gt; <span class=\"title\">wrapSink</span><span class=\"params\">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (AbstractPipeline p=AbstractPipeline.<span class=\"keyword\">this</span>; p.depth &gt; <span class=\"number\">0</span>; p=p.previousStage) &#123;</span><br><span class=\"line\">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyInto</span><span class=\"params\">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class=\"line\">        wrappedSink.begin(spliterator.getExactSizeIfKnown());<span class=\"comment\">// 通知开始遍历</span></span><br><span class=\"line\">        spliterator.forEachRemaining(wrappedSink);<span class=\"comment\">// 迭代</span></span><br><span class=\"line\">        wrappedSink.end();<span class=\"comment\">// 通知遍历结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器，参阅），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。</p>\n<h4 id=\"执行后的结果在哪里\"><a href=\"#执行后的结果在哪里\" class=\"headerlink\" title=\"执行后的结果在哪里\"></a>执行后的结果在哪里</h4><p>最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(Side-effects)，比如使用<code>Stream.forEach()</code>方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？</p>\n<p><strong>特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误的收集方式</span></span><br><span class=\"line\">ArrayList&lt;String&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class=\"line\">      .forEach(s -&gt; results.add(s));  <span class=\"comment\">// Unnecessary use of side-effects!</span></span><br><span class=\"line\"><span class=\"comment\">// 正确的收集方式</span></span><br><span class=\"line\">List&lt;String&gt;results =</span><br><span class=\"line\">     stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class=\"line\">             .collect(Collectors.toList());  <span class=\"comment\">// No side-effects!</span></span><br></pre></td></tr></table></figure>\n<p>回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。<br>|返回类型    |对应的结束操作    |<br>|———-:|———-:|<br>|boolean|anyMatch() allMatch() noneMatch()|<br>|Optional|findFirst() findAny()|<br>|归约结果    |reduce() collect()|<br>|数组|toArray()|</p>\n<ul>\n<li>对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。</li>\n<li>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用reduce()方法实现的。</li>\n<li>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做Node的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。</li>\n</ul>\n<p>参考资料：</p>\n<p><a href=\"http://www.cnblogs.com/CarpenterLee/p/6729368.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java函数式编程》系列文章</a></p>\n<p><a href=\"http://lucida.me/\" target=\"_blank\" rel=\"noopener\">《深入理解Java 8 Lambda》系列文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Lambda表达式和匿名内部类\"><a href=\"#Lambda表达式和匿名内部类\" class=\"headerlink\" title=\"Lambda表达式和匿名内部类\"></a>Lambda表达式和匿名内部类</h2><p>昨天突然看到一篇关于JDK1.8 Stream 讲解的文章，之前一直是简单的使用，并没有仔细分析过其中的细节。仅仅做到了知其然，看了那位大牛的博客后，打算花一些时间，尽力做到知其所以然。本文是对<a href=\"http://www.cnblogs.com/CarpenterLee/p/6729368.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java函数式编程》</a>系列文章的合并整理</p>\n<h3 id=\"取代某些匿名内部类\"><a href=\"#取代某些匿名内部类\" class=\"headerlink\" title=\"取代某些匿名内部类\"></a>取代某些匿名内部类</h3><p>Java Lambda表达式的一个重要用法是简化某些匿名内部类（<code>Anonymous Classes</code>）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的。</p>\n<h4 id=\"demo1-无参函数的简写\"><a href=\"#demo1-无参函数的简写\" class=\"headerlink\" title=\"demo1: 无参函数的简写\"></a>demo1: 无参函数的简写</h4><p>如果需要新建一个线程，一种常见的写法是这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK7 匿名内部类写法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;<span class=\"comment\">// 接口名</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">// 方法名</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Thread run()\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure></p>\n<p>上述代码给<code>Tread</code>类传递了一个匿名的<code>Runnable</code>对象，重载<code>Runnable</code>接口的<code>run()</code>方法来实现相应逻辑。这是JDK7以及之前的常见写法。匿名内部类省去了为类起名字的烦恼，但还是不够简化，在Java 8中可以简化为如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK8 Lambda表达式代码块写法</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">        () -&gt; &#123;</span><br><span class=\"line\">            System.out.print(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\" Hoolee\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">).start();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"demo2-带参函数的简写\"><a href=\"#demo2-带参函数的简写\" class=\"headerlink\" title=\"demo2: 带参函数的简写\"></a>demo2: 带参函数的简写</h4><p>如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK7 匿名内部类写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;<span class=\"comment\">// 接口名</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span></span>&#123;<span class=\"comment\">// 方法名</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s2 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码通过内部类重载了<code>Comparator</code>接口的<code>compare()</code>方法，实现比较逻辑。采用Lambda表达式可简写如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDK8 Lambda表达式写法</span></span><br><span class=\"line\">List&lt;String&gt; list = Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Collections.sort(list, (s1, s2) -&gt;&#123;<span class=\"comment\">// 省略参数表的类型</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s1 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s2 == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.length()-s2.length();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码跟匿名内部类的作用是一样的。除了省略了接口名和方法名，代码中把参数表的类型也省略了。这得益于javac的<strong>类型推断机制</strong>，编译器能够根据上下文信息推断出参数的类型，当然也有推断失败的时候，这时就需要手动指明参数类型了。注意，Java是强类型语言，每个变量和对象都必需有明确的类型。</p>\n<h3 id=\"简写的依据\"><a href=\"#简写的依据\" class=\"headerlink\" title=\"简写的依据\"></a>简写的依据</h3><p>也许你已经想到了，能够使用<strong>Lambda</strong>的依据是必须有相应的函数接口（函数接口，是指内部只有一个抽象方法的接口）。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上<strong>Lambda</strong>的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。<strong>Lambda</strong>表达更多合法的书写形式如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lambda表达式的书写形式</span></span><br><span class=\"line\">Runnable run = () -&gt; System.out.println(<span class=\"string\">\"Hello World\"</span>);<span class=\"comment\">// 1</span></span><br><span class=\"line\">ActionListener listener = event -&gt; System.out.println(<span class=\"string\">\"button clicked\"</span>);<span class=\"comment\">// 2</span></span><br><span class=\"line\">Runnable multiLine = () -&gt; &#123;<span class=\"comment\">// 3 代码块</span></span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\" Hoolee\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;<span class=\"comment\">// 4</span></span><br><span class=\"line\">BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;<span class=\"comment\">// 5 类型推断</span></span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，1展示了无参函数的简写；2处展示了有参函数的简写，以及类型推断机制；3是代码块的写法；4和5再次展示了类型推断机制。</p>\n<h3 id=\"自定义函数接口\"><a href=\"#自定义函数接口\" class=\"headerlink\" title=\"自定义函数接口\"></a>自定义函数接口</h3><p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义函数接口</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConsumerInterface</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中的<strong>@FunctionalInterface</strong>是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。<strong>就像加入@Override标注会检查是否重载了函数一样。</strong><br>有了上述接口定义，就可以写出类似如下的代码：</p>\n<p><code>ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str);</code></p>\n<p>进一步的，还可以这样使用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStream</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;T&gt; list;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">myForEach</span><span class=\"params\">(ConsumerInterface&lt;T&gt; consumer)</span></span>&#123;<span class=\"comment\">// 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(T t : list)&#123;</span><br><span class=\"line\">            consumer.accept(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyStream&lt;String&gt; stream = <span class=\"keyword\">new</span> MyStream&lt;String&gt;();</span><br><span class=\"line\">stream.myForEach(str -&gt; System.out.println(str));<span class=\"comment\">// 使用自定义函数接口书写Lambda表达式</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不是匿名内部类的简写\"><a href=\"#不是匿名内部类的简写\" class=\"headerlink\" title=\"不是匿名内部类的简写\"></a>不是匿名内部类的简写</h3><p>经过上面的介绍，我们看到Lambda表达式似乎只是为了简化匿名内部类书写，这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了。但实时并非如此。在JVM层面，Lambda表达式和匿名内部类有着明显的差别。</p>\n<h4 id=\"匿名内部类实现\"><a href=\"#匿名内部类实现\" class=\"headerlink\" title=\"匿名内部类实现\"></a>匿名内部类实现</h4><p>匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名。因此如果有如下形式的代码，编译之后将会产生两个class文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainAnonymousClass</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">\t\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">\"Anonymous Class Thread run()\"</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;).start();;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>进一步分析主类MainAnonymousClass.class的字节码，可发现其创建了匿名内部类的对象：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javap -c MainAnonymousClass.class</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainAnonymousClass</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       0: new           #2                  // class java/lang/Thread</span><br><span class=\"line\">       <span class=\"number\">3</span>: dup</span><br><span class=\"line\">       4: new           #3                  // class MainAnonymousClass$1 /*创建内部类对象*/</span><br><span class=\"line\">       <span class=\"number\">7</span>: dup</span><br><span class=\"line\">       8: invokespecial #4                  // Method MainAnonymousClass$1.\"&lt;init&gt;\":()V</span><br><span class=\"line\">      11: invokespecial #5                  // Method java/lang/Thread.\"&lt;init&gt;\":(Ljava/lang/Runnable;)V</span><br><span class=\"line\">      14: invokevirtual #6                  // Method java/lang/Thread.start:()V</span><br><span class=\"line\">      <span class=\"number\">17</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Lambda表达式实现\"><a href=\"#Lambda表达式实现\" class=\"headerlink\" title=\"Lambda表达式实现\"></a>Lambda表达式实现</h4><p><strong>Lambda</strong>表达式通过<strong>invokedynamic</strong>指令实现，书写<strong>Lambda</strong>表达式不会产生新的类。如果有如下代码，编译之后只有一个class文件：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainLambda</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">\t\t\t\t() -&gt; System.out.println(<span class=\"string\">\"Lambda Thread run()\"</span>)</span><br><span class=\"line\">\t\t\t).start();;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过javap反编译命名，我们更能看出Lambda表达式内部表示的不同：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// javap -c -p MainLambda.class</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainLambda</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       0: new           #2                  // class java/lang/Thread</span><br><span class=\"line\">       <span class=\"number\">3</span>: dup</span><br><span class=\"line\">       4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/</span><br><span class=\"line\">       9: invokespecial #4                  // Method java/lang/Thread.\"&lt;init&gt;\":(Ljava/lang/Runnable;)V</span><br><span class=\"line\">      12: invokevirtual #5                  // Method java/lang/Thread.start:()V</span><br><span class=\"line\">      <span class=\"number\">15</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lambda$main$<span class=\"number\">0</span>();  <span class=\"comment\">/*Lambda表达式被封装成主类的私有方法*/</span></span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class=\"line\">       3: ldc           #7                  // String Lambda Thread run()</span><br><span class=\"line\">       5: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class=\"line\">       <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法，并通过<strong>invokedynamic</strong>指令进行调用。</p>\n<h4 id=\"推论，this引用的意义\"><a href=\"#推论，this引用的意义\" class=\"headerlink\" title=\"推论，this引用的意义\"></a>推论，this引用的意义</h4><p>既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。因此下列代码将输出两遍Hello Hoolee，而不是两个引用地址。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">\tRunnable r1 = () -&gt; &#123; System.out.println(<span class=\"keyword\">this</span>); &#125;;</span><br><span class=\"line\">\tRunnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Hello().r1.run();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Hello().r2.run();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"Hello Hoolee\"</span>; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Lambda表达式和Java集合框架\"><a href=\"#Lambda表达式和Java集合框架\" class=\"headerlink\" title=\"Lambda表达式和Java集合框架\"></a>Lambda表达式和Java集合框架</h2><p>Java8为容器新增一些有用的方法，这些方法有些是为完善原有功能，有些是为引入函数式编程（Lambda表达式），学习和使用这些方法有助于我们写出更加简洁有效的代码．本文分别以ArrayList和HashMap为例，讲解Java8集合框架（Java Collections Framework）中新加入方法的使用．</p>\n<h3 id=\"Collection中的新方法\"><a href=\"#Collection中的新方法\" class=\"headerlink\" title=\"Collection中的新方法\"></a>Collection中的新方法</h3><h4 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h4><p>该方法的签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。</p>\n<p>需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.</p>\n<p>Java7及以前我们可以用增强的for循环实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用曾强for循环迭代</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String str : list)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">        System.out.println(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合匿名内部类迭代</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.forEach(<span class=\"keyword\">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.forEach( str -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">            System.out.println(str);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码给<code>forEach()</code>方法传入一个Lambda表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p>\n<h4 id=\"removeIf\"><a href=\"#removeIf\" class=\"headerlink\" title=\"removeIf()\"></a>removeIf()</h4><p>该方法签名为<code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code>，作用是删除容器中所有满足<code>filter</code>指定条件的元素，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。</p>\n<p>需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</p>\n<p>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用迭代器删除列表元素</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it.next().length()&gt;<span class=\"number\">3</span>) <span class=\"comment\">// 删除长度大于3的元素</span></span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.removeIf(<span class=\"keyword\">new</span> Predicate&lt;String&gt;()&#123; <span class=\"comment\">// 删除长度大于3的元素</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.length()&gt;<span class=\"number\">3</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.removeIf(str -&gt; str.length()&gt;<span class=\"number\">3</span>); <span class=\"comment\">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure></p>\n<p>使用Lambda表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。</p>\n<h4 id=\"replaceAll\"><a href=\"#replaceAll\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h4><p>该方法签名为<code>void replaceAll(UnaryOperator&lt;E&gt; operator)</code>，作用是对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。</p>\n<p>需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</p>\n<p>Java7及之前似乎没有优雅的办法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用下标实现元素替换</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class=\"line\">    String str = list.get(i);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">        list.set(i, str.toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用匿名内部类实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.replaceAll(<span class=\"keyword\">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">apply</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> str.toUpperCase();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Lambda表达式实现</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.replaceAll(str -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.length()&gt;<span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str.toUpperCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort()\"></a>sort()</h4><p>该方法定义在List接口中，方法签名为<code>void sort(Comparator&lt;? super E&gt; c)</code>，该方法根据c指定的比较规则对容器元素进行排序。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。</p>\n<p>需求：假设有一个字符串列表，按照字符串长度增序对元素排序。</p>\n<p>由于Java7以及之前sort()方法在Collections工具类中，所以代码要这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Collections.sort()方法</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">Collections.sort(list, <span class=\"keyword\">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String str1, String str2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> str1.length()-str2.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>现在可以直接使用<code>List.sort()</code>方法，结合Lambda表达式，可以这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// List.sort()方法结合Lambda表达式</span></span><br><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>));</span><br><span class=\"line\">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"spliterator\"><a href=\"#spliterator\" class=\"headerlink\" title=\"spliterator()\"></a>spliterator()</h4><p>方法签名为<code>Spliterator&lt;E&gt; spliterator()</code>，该方法返回容器的可拆分迭代器。从名字来看该方法跟<code>iterator()</code>方法有点像，我们知道<code>Iterator</code>是用来迭代容器的，<code>Spliterator</code>也有类似作用，但二者有如下不同：</p>\n<ul>\n<li><code>Spliterator</code>既可以像<code>Iterator</code>那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。</li>\n<li><code>Spliterator</code>是可拆分的，一个<code>Spliterator</code>可以通过调用<code>Spliterator&lt;T&gt; trySplit()</code>方法来尝试分成两个。一个是this，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。</li>\n</ul>\n<p>可通过（多次）调用<code>Spliterator.trySplit()</code>方法来分解负载，以便多线程处理。</p>\n<h4 id=\"stream-和parallelStream\"><a href=\"#stream-和parallelStream\" class=\"headerlink\" title=\"stream()和parallelStream()\"></a>stream()和parallelStream()</h4><p><code>stream()</code>和<code>parallelStream()</code>分别返回该容器的<code>Stream</code>视图表示，不同之处在于<code>parallelStream()</code>返回并行的<code>Stream</code>。</p>\n<h3 id=\"Map中的新方法\"><a href=\"#Map中的新方法\" class=\"headerlink\" title=\"Map中的新方法\"></a>Map中的新方法</h3><h4 id=\"forEach-1\"><a href=\"#forEach-1\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h4><p>该方法签名为<code>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>，作用是对Map中的每个映射执行<code>action</code>指定的操作，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。</p>\n<p>需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．</p>\n<p>Java7以及之前经典的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java7以及之前迭代Map</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">    System.out.println(entry.getKey() + <span class=\"string\">\"=\"</span> + entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.forEach(<span class=\"keyword\">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Integer k, String v)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(k + <span class=\"string\">\"=\"</span> + v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.forEach((k, v) -&gt; System.out.println(k + <span class=\"string\">\"=\"</span> + v));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"getOrDefault\"><a href=\"#getOrDefault\" class=\"headerlink\" title=\"getOrDefault()\"></a>getOrDefault()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V getOrDefault(Object key, V defaultValue)</code>，作用是按照给定的<code>key</code>查询Map中对应的<code>value</code>，如果没有找到则返回<code>defaultValue</code>。使用该方法程序员可以省去查询指定键值是否存在的麻烦．</p>\n<p>需求；假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出<code>NoValue</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询Map中指定的值，不存在时使用默认值</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Java7以及之前做法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(map.containsKey(<span class=\"number\">4</span>))&#123; <span class=\"comment\">// 1</span></span><br><span class=\"line\">    System.out.println(map.get(<span class=\"number\">4</span>));</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"NoValue\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Java8使用Map.getOrDefault()</span></span><br><span class=\"line\">System.out.println(map.getOrDefault(<span class=\"number\">4</span>, <span class=\"string\">\"NoValue\"</span>)); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"putIfAbsent\"><a href=\"#putIfAbsent\" class=\"headerlink\" title=\"putIfAbsent()\"></a>putIfAbsent()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为<code>V putIfAbsent(K key, V value)</code>，作用是只有在不存在key值的映射或映射值为<code>null</code>时，才将<code>value</code>指定的值放入到Map中，否则不对Map做更改．该方法将条件判断和赋值合二为一，使用起来更加方便</p>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h4><p>我们都知道Map中有一个<code>remove(Object key)</code>方法，来根据指定<code>key</code>值删除Map中的映射关系；Java8新增了<code>remove(Object key, Object value)</code>方法，只有在当前Map中<code>key</code>正好映射到<code>value</code>时才删除该映射，否则什么也不做．</p>\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><p>在Java7及以前，要想替换Map中的映射关系可通过<code>put(K key, V value)</code>方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在Map中加入了两个<code>replace()</code>方法，分别如下：</p>\n<ul>\n<li><code>replace(K key, V value)</code>，只有在当前Map中<code>key</code>的映射存在时才用<code>value</code>去替换原来的值，否则什么也不做．</li>\n<li><code>replace(K key, V oldValue, V newValue)</code>，只有在当前Map中key的映射存在且等于<code>oldValue</code>时才用<code>newValue</code>去替换原来的值，否则什么也不做．<h4 id=\"replaceAll-1\"><a href=\"#replaceAll-1\" class=\"headerlink\" title=\"replaceAll()\"></a>replaceAll()</h4>该方法签名为<code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>，作用是对Map中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．</li>\n</ul>\n<p>需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．</p>\n<p>Java7以及之前经典的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class=\"line\">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.replaceAll(<span class=\"keyword\">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">apply</span><span class=\"params\">(Integer k, String v)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.toUpperCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">2</span>, <span class=\"string\">\"two\"</span>);</span><br><span class=\"line\">map.put(<span class=\"number\">3</span>, <span class=\"string\">\"three\"</span>);</span><br><span class=\"line\">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge()\"></a>merge()</h4><p>该方法签名为<code>merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</code>，作用是：</p>\n<ul>\n<li>如果Map中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是null）关联到<code>key</code>上；</li>\n<li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在Map中删除<code>key</code>的映射．</li>\n</ul>\n<p>参数中<code>BiFunction</code>函数接口前面已经介绍过，里面有一个待实现方法<code>R apply(T t, U u)</code>．</p>\n<p><code>merge()</code>方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p>\n<p><code>map.merge(key, newMsg, (v1, v2) -&gt; v1+v2);</code></p>\n<h4 id=\"compute\"><a href=\"#compute\" class=\"headerlink\" title=\"compute()\"></a>compute()</h4><p>该方法签名为<code>compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在Map中删除<code>key</code>的映射．</p>\n<p>要实现上述<code>merge()</code>方法中错误信息拼接的例子，使用<code>compute()</code>代码如下：</p>\n<p><code>map.compute(key, (k,v) -&gt; v==null ? newMsg : v.concat(newMsg));</code></p>\n<h4 id=\"computeIfAbsent\"><a href=\"#computeIfAbsent\" class=\"headerlink\" title=\"computeIfAbsent()\"></a>computeIfAbsent()</h4><p>该方法签名为<code>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</code>，作用是：只有在当前Map中不存在<code>key</code>值的映射或映射值为<code>null</code>时，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联．</p>\n<p>Function是一个函数接口，里面有一个待实现方法<code>R apply(T t)</code>．</p>\n<p><code>computeIfAbsent()</code>常用来对Map的某个<code>key</code>值建立初始化映射．比如我们要实现一个多值映射，Map的定义可能是<code>Map&lt;K,Set&lt;V&gt;&gt;</code>，要向Map中放入新值，可通过如下代码实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// Java7及以前的实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(map.containsKey(<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">    map.get(<span class=\"number\">1</span>).add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    Set&lt;String&gt; valueSet = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">    valueSet.add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">    map.put(<span class=\"number\">1</span>, valueSet);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Java8的实现方式</span></span><br><span class=\"line\">map.computeIfAbsent(<span class=\"number\">1</span>, v -&gt; <span class=\"keyword\">new</span> HashSet&lt;String&gt;()).add(<span class=\"string\">\"yi\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>computeIfAbsent()</code>将条件判断和添加操作合二为一，使代码更加简洁．</p>\n<h4 id=\"computeIfPresent\"><a href=\"#computeIfPresent\" class=\"headerlink\" title=\"computeIfPresent()\"></a>computeIfPresent()</h4><p>该方法签名为<code>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前Map中存在<code>key</code>值的映射且非<code>null</code>时，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．</p>\n<p>这个函数的功能跟如下代码是等效的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java7及以前跟computeIfPresent()等效的代码</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (map.get(key) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    V oldValue = map.get(key);</span><br><span class=\"line\">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.put(key, newValue);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        map.remove(key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Java-Stream-API入门\"><a href=\"#Java-Stream-API入门\" class=\"headerlink\" title=\"Java Stream API入门\"></a>Java Stream API入门</h2><p>Java 8之所以费这么大功夫引入函数式编程，原因有二：</p>\n<ul>\n<li>代码简洁，函数式编程写出的代码简洁且意图明确，使用<code>stream</code>接口让你从此告别for循环。</li>\n<li>多核友好，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下<code>parallel()</code>方法。</li>\n</ul>\n<p><code>stream</code>，也就是Java函数式编程的主角。对于Java 7来说stream完全是个陌生东西，stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。正因如此要得到一个stream通常不会手动创建，而是调用对应的工具方法，比如：</p>\n<ul>\n<li>调用<code>Collection.stream()</code>或者<code>Collection.parallelStream()</code>方法</li>\n<li>调用<code>Arrays.stream(T[] array)</code>方法</li>\n</ul>\n<p>常见的stream接口继承关系如图：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/Java_stream_Interfaces.png\" alt=\"avatar\"></p>\n<p>图中4种stream接口继承自<code>BaseStream</code>，其中<code>IntStream</code>, <code>LongStream</code>, <code>DoubleStream</code>对应三种基本类型（<code>int</code>, <code>long</code>, <code>double</code>，注意不是包装类型），Stream对应所有剩余类型的<code>stream</code>视图。为不同数据类型设置不同<code>stream</code>接口，可以 1.提高性能，2.增加特定接口函数。</p>\n<p>你可能会奇怪为什么不把<code>IntStream</code>等设计成<code>Stream</code>的子接口？毕竟这接口中的方法名大部分是一样的。答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。</p>\n<p>虽然大部分情况下<code>stream</code>是容器调用<code>Collection.stream()</code>方法得到的，但<code>stream</code>和<code>collections</code>有以下不同：</p>\n<ul>\n<li>无存储。<code>stream</code>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>\n<li>为函数式编程而生。对<code>stream</code>的任何修改都不会修改背后的数据源，比如对<code>stream</code>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<code>stream</code>。</li>\n<li>惰式执行。<code>stream</code>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li>可消费性。<code>stream</code>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n<p>对<code>stream</code>的操作分为为两类，中间操作(<code>intermediate operations</code>)和结束操作(<code>terminal operations</code>)，二者特点是：</p>\n<ul>\n<li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新<code>stream</code>，仅此而已。</li>\n<li>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以<code>pipeline</code>的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>\n</ul>\n<p>下表汇总了Stream接口的部分常见方法：</p>\n<table>\n<thead>\n<tr>\n<th>操作类型</th>\n<th style=\"text-align:center\">接口方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>中间操作</td>\n<td style=\"text-align:center\">concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td>\n</tr>\n<tr>\n<td>结束操作</td>\n<td style=\"text-align:center\">allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td>\n</tr>\n</tbody>\n</table>\n<p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。</p>\n<h3 id=\"stream方法使用\"><a href=\"#stream方法使用\" class=\"headerlink\" title=\"stream方法使用\"></a>stream方法使用</h3><p><code>stream</code>跟函数接口关系非常紧密，没有函数接口<code>stream</code>就无法工作。回顾一下：函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。</p>\n<h4 id=\"forEach-2\"><a href=\"#forEach-2\" class=\"headerlink\" title=\"forEach()\"></a>forEach()</h4><p>我们对<code>forEach()</code>方法并不陌生，在<code>Collection</code>中我们已经见过。方法签名为<code>void forEach(Consumer&lt;? super E&gt; action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，也就是对元素进行遍历。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Stream.forEach()迭代</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。</p>\n<h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h4><p>函数原型为<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，作用是返回一个只包含满足<code>predicate</code>条件元素的Stream。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 保留长度等于3的字符串</span></span><br><span class=\"line\">Stream&lt;String&gt; stream= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.filter(str -&gt; str.length()==<span class=\"number\">3</span>)</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码将输出为长度等于3的字符串<code>you</code>和<code>too</code>。注意，由于<code>filter()</code>是个中间操作，如果只调用<code>filter()</code>不会有实际计算，因此也不会输出任何信息。</p>\n<h4 id=\"distinct\"><a href=\"#distinct\" class=\"headerlink\" title=\"distinct()\"></a>distinct()</h4><p>函数原型为<code>Stream&lt;T&gt; distinct()</code>，作用是返回一个去除重复元素之后的<code>Stream</code><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.distinct()</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码会输出去掉一个too之后的其余字符串。</p>\n<h4 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted()\"></a>sorted()</h4><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream&lt;T&gt;　sorted()和Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.sorted((str1, str2) -&gt; str1.length()-str2.length())</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码将输出按照长度升序排序后的字符串，结果完全在预料之中。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h4><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream　= Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">stream.map(str -&gt; str.toUpperCase())</span><br><span class=\"line\">    .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码将输出原字符串的大写形式。</p>\n<h4 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap()\"></a>flatMap()</h4><p>函数原型为<code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<code>stream</code>中的所有元素都”摊平”之后组成的Stream，转换前后元素的个数和类型都可能会改变。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class=\"number\">1</span>,<span class=\"number\">2</span>), Arrays.asList(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\">stream.flatMap(list -&gt; list.stream())</span><br><span class=\"line\">    .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中，原来的stream中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个List都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的Stream。所以最终将输出1~5这5个数字。</p>\n<h2 id=\"Java-Stream-API进阶\"><a href=\"#Java-Stream-API进阶\" class=\"headerlink\" title=\"Java Stream API进阶\"></a>Java Stream API进阶</h2><p>规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作<code>reduce()</code>和<code>collect()</code>，也有一些为简化书写而设计的专用规约操作，比如<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等。</p>\n<p>最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍<code>reduce()</code>和<code>collect()</code>，这是比较有魔法的地方。</p>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p><code>reduce</code>操作可以实现从一组元素中生成一个值，<code>sum()</code>、<code>max()</code>、<code>min()</code>、<code>count()</code>等都是<code>reduce</code>操作，将他们单独设为函数只是因为常用。<code>reduce()</code>的方法定义有三种重写形式：</p>\n<ul>\n<li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></li>\n<li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></li>\n<li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></li>\n</ul>\n<p>虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。用这么复杂的函数去求一个最大或最小值，你是不是觉得设计者有病。其实不然，因为“大”和“小”或者“求和”有时会有不同的语义。</p>\n<p>需求：从一组单词中找出最长的单词。这里“大”的含义就是“长”。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class=\"line\"><span class=\"comment\">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class=\"line\">System.out.println(longest.get());</span><br></pre></td></tr></table></figure></p>\n<p>上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用<code>Stream.max(Comparator&lt;? super T&gt; comparator)</code>方法来达到同等效果，但<code>reduce()</code>自有其存在的理由。</p>\n<p>需求：求出一组单词的长度之和。这是个“求和”操作，操作对象输入类型是String，而结果类型是Integer。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求单词长度之和</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Integer lengthSum = stream.reduce(<span class=\"number\">0</span>,　<span class=\"comment\">// 初始值　// (1)</span></span><br><span class=\"line\">        (sum, str) -&gt; sum+str.length(), <span class=\"comment\">// 累加器 // (2)</span></span><br><span class=\"line\">        (a, b) -&gt; a+b);　<span class=\"comment\">// 部分和拼接器，并行执行时才会用到 // (3)</span></span><br><span class=\"line\"><span class=\"comment\">// int lengthSum = stream.mapToInt(str -&gt; str.length()).sum();</span></span><br><span class=\"line\">System.out.println(lengthSum);</span><br></pre></td></tr></table></figure>\n<p>上述代码标号(2)处将i. 字符串映射成长度，ii. 并和当前累加和相加。这显然是两步操作，使用<code>reduce()</code>函数将这两步合二为一，更有助于提升性能。如果想要使用<code>map()</code>和<code>sum()</code>组合来达到上述目的，也是可以的。</p>\n<p><code>reduce()</code>擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？终极武器<code>collect()</code>横空出世！</p>\n<h3 id=\"collect\"><a href=\"#collect\" class=\"headerlink\" title=\"collect()\"></a>collect()</h3><p>不夸张的讲，如果你发现某个功能在Stream接口中没找到，十有八九可以通过<code>collect()</code>方法实现。<code>collect()</code>是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。先看几个热身的小例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Stream转换成容器或Map</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class=\"comment\">// (1)</span></span><br><span class=\"line\"><span class=\"comment\">// Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span></span><br><span class=\"line\"><span class=\"comment\">// Map&lt;String, Integer&gt; map = stream.collect(Collectors.toMap(Function.identity(), String::length)); // (3)</span></span><br></pre></td></tr></table></figure></p>\n<p>上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问：</p>\n<ul>\n<li><code>Function.identity()</code>是干什么的？</li>\n<li><code>String::length</code>是什么意思？</li>\n<li><code>Collectors</code>是个什么东西？</li>\n</ul>\n<h4 id=\"接口的静态方法和默认方法\"><a href=\"#接口的静态方法和默认方法\" class=\"headerlink\" title=\"接口的静态方法和默认方法\"></a>接口的静态方法和默认方法</h4><p>Function是一个接口，那么<code>Function.identity()</code>是什么意思呢？这要从两方面解释：</p>\n<ul>\n<li>Java 8允许在接口中加入具体方法。接口中的具体方法有两种，<code>default</code>方法和<code>static</code>方法，<code>identity()</code>就是Function接口的一个静态方法。</li>\n<li><code>Function.identity()</code>返回一个输出跟输入一样的Lambda表达式对象，等价于形如<code>t -&gt; t</code>形式的Lambda表达式。</li>\n</ul>\n<p>上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得<code>t -&gt; t</code>比<code>identity()</code>方法更直观。我会告诉你接口中的<code>default</code>方法是一个无奈之举，在Java 7及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在Collection接口中加入一个stream()抽象方法会怎样？<code>default</code>方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了<code>default</code>方法，为何不再加入<code>static</code>方法来避免专门的工具类呢！</p>\n<h4 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h4><p>诸如<code>String::length</code>的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：</p>\n<table>\n<thead>\n<tr>\n<th>方法引用类别</th>\n<th style=\"text-align:center\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>引用静态方法</td>\n<td style=\"text-align:center\"><code>Integer::sum</code></td>\n</tr>\n<tr>\n<td>引用某个对象的方法</td>\n<td style=\"text-align:center\"><code>list::add</code></td>\n</tr>\n<tr>\n<td>引用某个类的方法</td>\n<td style=\"text-align:center\"><code>String::length</code></td>\n</tr>\n<tr>\n<td>引用构造方法</td>\n<td style=\"text-align:center\"><code>HashMap::new</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"收集器\"><a href=\"#收集器\" class=\"headerlink\" title=\"收集器\"></a>收集器</h4><p>收集器（Collector）是为<code>Stream.collect()</code>方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：</p>\n<ul>\n<li>目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。</li>\n<li>新元素如何添加到容器中？是List.add()还是Map.put()。如果并行的进行规约，还需要告诉<code>collect()</code> </li>\n<li>多个部分结果如何合并成一个。</li>\n</ul>\n<p>结合以上分析，<code>collect()</code>方法定义为<code>&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>，三个参数依次对应上述三条分析。不过每次调用<code>collect()</code>都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以<code>collect()</code>的另一定义为<code>&lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)</code>。Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　将Stream规约成List</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">List&lt;String&gt; list = stream.collect(ArrayList::<span class=\"keyword\">new</span>, ArrayList::add, ArrayList::addAll);<span class=\"comment\">// 方式１</span></span><br><span class=\"line\"><span class=\"comment\">//List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class=\"line\">System.out.println(list);</span><br></pre></td></tr></table></figure></p>\n<p>通常情况下我们不需要手动指定<code>collect()</code>的三个参数，而是调用<code>collect(Collector&lt;? super T,A,R&gt; collector)</code>方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了<code>collect()</code>的行为。</p>\n<h4 id=\"使用collect-生成Collection\"><a href=\"#使用collect-生成Collection\" class=\"headerlink\" title=\"使用collect()生成Collection\"></a>使用collect()生成Collection</h4><p>前面已经提到通过<code>collect()</code>方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将Stream转换成List或Set</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class=\"comment\">// (1)</span></span><br><span class=\"line\">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); <span class=\"comment\">// (2)</span></span><br></pre></td></tr></table></figure>\n<p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用toCollection()指定规约容器的类型</span></span><br><span class=\"line\">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class=\"keyword\">new</span>));<span class=\"comment\">// (3)</span></span><br><span class=\"line\">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class=\"keyword\">new</span>));<span class=\"comment\">// (4)</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用collect-生成Map\"><a href=\"#使用collect-生成Map\" class=\"headerlink\" title=\"使用collect()生成Map\"></a>使用collect()生成Map</h4><p>前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的<code>key</code>和<code>value</code>分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下<code>collect()</code>的结果会是Map：</p>\n<ul>\n<li>使用<code>Collectors.toMap()</code>生成的收集器，用户需要指定如何生成Map的<code>key</code>和<code>value</code>。</li>\n<li>使用<code>Collectors.partitioningBy()</code>生成的收集器，对元素进行二分区操作时用到。</li>\n<li>使用<code>Collectors.groupingBy()</code>生成的收集器，对元素做<code>group</code>操作时用到。<br>情况1：使用<code>toMap()</code>生成的收集器，这种情况是最直接的，前面例子中已提到，这是和<code>Collectors.toCollection()</code>并列的方法。如下代码展示将学生列表转换成由&lt;学生，GPA&gt;组成的Map。非常直观，无需多言。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用toMap()统计学生GPA</span></span><br><span class=\"line\">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class=\"line\">     students.stream().collect(Collectors.toMap(Functions.identity(),<span class=\"comment\">// 如何生成key</span></span><br><span class=\"line\">                                     student -&gt; computeGPA(student)));<span class=\"comment\">// 如何生成value</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>情况2：使用<code>partitioningBy()</code>生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将学生分成成绩及格或不及格的两部分。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Partition students into passing and failing</span></span><br><span class=\"line\">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class=\"line\">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure></p>\n<p>情况3：使用<code>groupingBy()</code>生成的收集器，这是比较灵活的一种情况。跟SQL中的<code>group by</code>语句类似，这里的<code>groupingBy()</code>也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个<code>key</code>上。下列代码展示将员工按照部门进行分组：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Group employees by department</span></span><br><span class=\"line\">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class=\"line\">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure></p>\n<p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如1. 先将员工按照部门分组，2. 然后统计每个部门员工的人数。Java类库设计者也考虑到了这种情况，增强版的<code>groupingBy()</code>能够满足这种需求。增强版的<code>groupingBy()</code>允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做<strong>上游收集器</strong>，之后执行其他运算的收集器叫做<strong>下游收集器(downstream Collector)</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用下游收集器统计每个部门的人数</span></span><br><span class=\"line\">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class=\"line\">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class=\"line\">                                                   Collectors.counting()));<span class=\"comment\">// 下游收集器</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照部门对员工分布组，并只保留员工的名字</span></span><br><span class=\"line\">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class=\"line\">                        Collectors.mapping(Employee::getName,<span class=\"comment\">// 下游收集器</span></span><br><span class=\"line\">                                Collectors.toList())));<span class=\"comment\">// 更下游的收集器</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用collect-做字符串join\"><a href=\"#使用collect-做字符串join\" class=\"headerlink\" title=\"使用collect()做字符串join\"></a>使用collect()做字符串join</h4><p>这个肯定是大家喜闻乐见的功能，字符串拼接时使用<code>Collectors.joining()</code>生成的收集器，从此告别<code>for</code>循环。<code>Collectors.joining()</code>方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用Collectors.joining()拼接字符串</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//String joined = stream.collect(Collectors.joining());// \"Iloveyou\"</span></span><br><span class=\"line\"><span class=\"comment\">//String joined = stream.collect(Collectors.joining(\",\"));// \"I,love,you\"</span></span><br><span class=\"line\">String joined = stream.collect(Collectors.joining(<span class=\"string\">\",\"</span>, <span class=\"string\">\"&#123;\"</span>, <span class=\"string\">\"&#125;\"</span>));<span class=\"comment\">// \"&#123;I,love,you&#125;\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"collect-还可以做更多\"><a href=\"#collect-还可以做更多\" class=\"headerlink\" title=\"collect()还可以做更多\"></a>collect()还可以做更多</h4><p>除了可以使用Collectors工具类已经封装好的收集器，我们还可以自定义收集器，或者直接调用<code>collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</code>方法，收集任何形式你想要的信息。不过Collectors工具类应该能满足我们的绝大部分需求，手动实现之间请先看看文档。</p>\n<h2 id=\"Java-Stream流水线\"><a href=\"#Java-Stream流水线\" class=\"headerlink\" title=\"Java Stream流水线\"></a>Java Stream流水线</h2><p>Stream API，用起来真的很爽，但简洁的方法下面似乎隐藏着无尽的秘密，如此强大的API是如何实现的呢？Pipeline是怎么执行的，每次方法调用都会导致一次迭代吗？自动并行又是怎么做到的，线程个数是多少？本节我们学习Stream流水线的原理，这是Stream实现的关键所在。</p>\n<p>容器执行Lambda表达式的方式，以<code>ArrayList.forEach()</code>方法为例，具体代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ArrayList.forEach()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forEach</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class=\"line\">        action.accept(elementData[i]);<span class=\"comment\">// 回调方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们看到<code>ArrayList.forEach()</code>方法的主要逻辑就是一个for循环，在该for循环里不断调用<code>action.accept()</code>回调方法完成对元素的遍历。这完全没有什么新奇之处，回调方法在Java GUI的监听器中广泛使用。Lambda表达式的作用就是相当于一个回调方法，这很好理解。</p>\n<p>Stream API中大量使用Lambda表达式作为回调方法，但这并不是关键。理解Stream我们更关心的是另外两个问题：流水线和自动并行。使用Stream或许很容易写入如下形式的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> longestStringLengthStartingWithA</span><br><span class=\"line\">        = strings.stream()</span><br><span class=\"line\">              .filter(s -&gt; s.startsWith(<span class=\"string\">\"A\"</span>))</span><br><span class=\"line\">              .mapToInt(String::length)</span><br><span class=\"line\">              .max();</span><br></pre></td></tr></table></figure>\n<p>上述代码求出以字母A开头的字符串的最大长度，一种直白的方式是为每一次函数调用都执一次迭代，这样做能够实现功能，但效率上肯定是无法接受的。类库的实现着使用流水线（Pipeline）的方式巧妙的避免了多次迭代，其基本思想是在一次迭代中尽可能多的执行用户指定的操作。为讲解方便我们汇总了Stream的所有操作。<br>|Stream操作分类|||<br>|——–:|———:|———:|<br>|中间操作(Intermediate operations)|无状态(Stateless)|unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()|<br>||有状态(Stateful)|distinct() sorted() sorted() limit() skip()|<br>|结束操作(Terminal operations)|非短路操作|forEach() forEachOrdered() toArray() reduce() collect() max() min() count()|<br>||短路操作(short-circuiting)|anyMatch() allMatch() noneMatch() findFirst() findAny()|</p>\n<p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记，只有结束操作才会触发实际计算。中间操作又可以分为无状态的(Stateless)和有状态的(Stateful)，无状态中间操作是指元素的处理不受前面元素的影响，而有状态的中间操作必须等到所有元素处理之后才知道最终结果，比如排序是有状态操作，在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作，短路操作是指不用处理全部元素就可以返回结果，比如找到第一个满足条件的元素。之所以要进行如此精细的划分，是因为底层对每一种情况的处理方式不同。</p>\n<h3 id=\"一种直白的实现方式\"><a href=\"#一种直白的实现方式\" class=\"headerlink\" title=\"一种直白的实现方式\"></a>一种直白的实现方式</h3><p>仍然考虑上述求最长字符串的程序，一种直白的流水线实现方式是为每一次函数调用都执一次迭代，并将处理中间结果放到某种数据结构中（比如数组，容器等）。具体说来，就是调用<code>filter()</code>方法后立即执行，选出所有以A开头的字符串并放到一个列表<code>list1</code>中，之后让<code>list1</code>传递给<code>mapToInt()</code>方法并立即执行，生成的结果放到<code>list2</code>中，最后遍历<code>list2</code>找出最大的数字作为最终结果。程序的执行流程如如所示：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/1.png\" alt=\"一种直白的实现方式\"></p>\n<p>这样做实现起来非常简单直观，但有两个明显的弊端：</p>\n<ul>\n<li>迭代次数多。迭代次数跟函数调用的次数相等。</li>\n<li>频繁产生中间结果。每次函数调用都产生一次中间结果，存储开销无法接受。</li>\n</ul>\n<p>这些弊端使得效率底下，根本无法接受。如果不使用Stream API我们都知道上述代码该如何在一次迭代中完成，大致是如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> longest = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(String str : strings)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(str.startsWith(<span class=\"string\">\"A\"</span>))&#123;<span class=\"comment\">// 1. filter(), 保留以A开头的字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = str.length();<span class=\"comment\">// 2. mapToInt(), 转换成长度</span></span><br><span class=\"line\">        longest = Math.max(len, longest);<span class=\"comment\">// 3. max(), 保留最长的长度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采用这种方式我们不但减少了迭代次数，也避免了存储中间结果，显然这就是流水线，因为我们把三个操作放在了一次迭代当中。只要我们事先知道用户意图，总是能够采用上述方式实现跟Stream API等价的功能，但问题是Stream类库的设计者并不知道用户的意图是什么。如何在无法假设用户行为的前提下实现流水线，是类库的设计者要考虑的问题。</p>\n<h3 id=\"Stream流水线解决方案\"><a href=\"#Stream流水线解决方案\" class=\"headerlink\" title=\"Stream流水线解决方案\"></a>Stream流水线解决方案</h3><p>我们大致能够想到，应该采用某种方式记录用户每一步的操作，当用户调用结束操作时将之前记录的操作叠加到一起在一次迭代中全部执行掉。沿着这个思路，有几个问题需要解决：</p>\n<ul>\n<li>用户的操作如何记录？</li>\n<li>操作如何叠加？</li>\n<li>叠加之后的操作如何执行？</li>\n<li>执行后的结果（如果有）在哪里？</li>\n</ul>\n<h4 id=\"操作如何记录\"><a href=\"#操作如何记录\" class=\"headerlink\" title=\"操作如何记录\"></a>操作如何记录</h4><p>注意这里使用的是“操作(operation)”一词，指的是“Stream中间操作”的操作，很多Stream操作会需要一个回调函数（Lambda表达式），因此一个完整的操作是&lt;数据来源，操作，回调函数&gt;构成的三元组。Stream中使用Stage的概念来描述一个完整的操作，并用某种实例化后的PipelineHelper来代表Stage，将具有先后顺序的各个Stage连到一起，就构成了整个流水线。跟Stream相关类和接口的继承关系图示。<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/Stream%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"Stream相关类和接口的继承关系图\"></p>\n<p>还有IntPipeline, LongPipeline, DoublePipeline没在图中画出，这三个类专门为三种基本类型（不是包装类型）而定制的，跟ReferencePipeline是并列关系。图中Head用于表示第一个Stage，即调用调用诸如Collection.stream()方法产生的Stage，很显然这个Stage里不包含任何操作；StatelessOp和StatefulOp分别表示无状态和有状态的Stage，对应于无状态和有状态的中间操作。</p>\n<p>Stream流水线组织结构示意图如下：<br><img src=\"http://ozqzyzixv.bkt.clouddn.com/Stream%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"Stream流水线组织结构示意图\"></p>\n<p>图中通过<code>Collection.stream()</code>方法得到Head也就是stage0，紧接着调用一系列的中间操作，不断产生新的Stream。这些Stream对象以双向链表的形式组织在一起，构成整个流水线，由于每个Stage都记录了前一个Stage和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作。这就是Stream记录操作的方式。</p>\n<h4 id=\"操作如何叠加\"><a href=\"#操作如何叠加\" class=\"headerlink\" title=\"操作如何叠加\"></a>操作如何叠加</h4><p>以上只是解决了操作记录的问题，要想让流水线起到应有的作用我们需要一种将所有操作叠加到一起的方案。你可能会觉得这很简单，只需要从流水线的head开始依次执行每一步的操作（包括回调函数）就行了。这听起来似乎是可行的，但是你忽略了前面的Stage并不知道后面Stage到底执行了哪种操作，以及回调函数是哪种形式。换句话说，只有当前Stage本身才知道该如何执行自己包含的动作。这就需要有某种协议来协调相邻Stage之间的调用关系。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">方法名</th>\n<th style=\"text-align:right\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\"><code>void begin(long size)</code></td>\n<td style=\"text-align:right\">开始遍历元素之前调用该方法，通知Sink做好准备。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\"><code>void end()</code></td>\n<td style=\"text-align:right\">所有元素遍历完成之后调用，通知Sink没有更多的元素了。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\"><code>boolean cancellationRequested()</code></td>\n<td style=\"text-align:right\">是否可以结束操作，可以让短路操作尽早结束。</td>\n</tr>\n<tr>\n<td style=\"text-align:right\"><code>void accept(T t)</code></td>\n<td style=\"text-align:right\">遍历元素时调用，接受一个待处理元素，并对元素进行处理。Stage把自己包含的操作和回调方法封装到该方法里，前一个Stage只需要调用当前<code>Stage.accept(T t)</code>方法就行了。</td>\n</tr>\n</tbody>\n</table>\n<p>有了上面的协议，相邻Stage之间调用就很方便了，每个Stage都会将自己的操作封装到一个Sink里，前一个Stage只需调用后一个Stage的<code>accept()</code>方法即可，并不需要知道其内部是如何处理的。当然对于有状态的操作，Sink的<code>begin()</code>和<code>end()</code>方法也是必须实现的。比如<code>Stream.sorted()</code>是一个有状态的中间操作，其对应的<code>Sink.begin()</code>方法可能创建一个乘放结果的容器，而<code>accept()</code>方法负责将元素添加到该容器，最后<code>end()</code>负责对容器进行排序。对于短路操作，<code>Sink.cancellationRequested()</code>也是必须实现的，比如<code>Stream.findFirst()</code>是短路操作，只要找到一个元素，<code>cancellationRequested()</code>就应该返回true，以便调用者尽快结束查找。Sink的四个接口方法常常相互协作，共同完成计算任务。实际上Stream API内部实现的的本质，就是如何重载Sink的这四个接口方法。</p>\n<p>有了Sink对操作的包装，Stage之间的调用问题就解决了，执行时只需要从流水线的head开始对数据源依次调用每个Stage对应的<code>Sink.{begin(), accept(), cancellationRequested(), end()}</code>方法就可以了。一种可能的<code>Sink.accept()</code>方法流程是这样的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(U u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>. 使用当前Sink包装的回调函数处理u</span><br><span class=\"line\">    <span class=\"number\">2</span>. 将处理结果传递给流水线下游的Sink</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Sink接口的其他几个方法也是按照这种[处理-&gt;转发]的模型实现。下面我们结合具体例子看看Stream的中间操作是如何将自身的操作包装成Sink以及Sink是如何将处理结果转发给下一个Sink的。先看<code>Stream.map()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Stream.map()，调用该方法将产生一个新的Stream</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Stream&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Function&lt;? <span class=\"keyword\">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class=\"keyword\">this</span>, StreamShape.REFERENCE,</span><br><span class=\"line\">                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"comment\">/*opWripSink()方法返回由回调函数包装而成Sink*/</span></span><br><span class=\"line\">        <span class=\"function\">Sink&lt;P_OUT&gt; <span class=\"title\">opWrapSink</span><span class=\"params\">(<span class=\"keyword\">int</span> flags, Sink&lt;R&gt; downstream)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(downstream) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(P_OUT u)</span> </span>&#123;</span><br><span class=\"line\">                    R r = mapper.apply(u);<span class=\"comment\">// 1. 使用当前Sink包装的回调函数mapper处理u</span></span><br><span class=\"line\">                    downstream.accept(r);<span class=\"comment\">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码看似复杂，其实逻辑很简单，就是将回调函数<code>mapper</code>包装到一个Sink当中。由于<code>Stream.map()</code>是一个无状态的中间操作，所以<code>map()</code>方法返回了一个<code>StatelessOp</code>内部类对象（一个新的Stream），调用这个新Stream的<code>opWripSink()</code>方法将得到一个包装了当前回调函数的Sink。</p>\n<p>再来看一个复杂一点的例子。<code>Stream.sorted()</code>方法将对Stream中的元素进行排序，显然这是一个有状态的中间操作，因为读取所有元素之前是没法得到最终顺序的。抛开模板代码直接进入问题本质，<code>sorted()</code>方法是如何将操作封装成Sink的呢？<code>sorted()</code>一种可能封装的Sink代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Stream.sort()方法用到的Sink实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefSortingSink</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRefSortingSink</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ArrayList&lt;T&gt; list;<span class=\"comment\">// 存放用于排序的元素</span></span><br><span class=\"line\">    RefSortingSink(Sink&lt;? <span class=\"keyword\">super</span> T&gt; downstream, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; comparator) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(downstream, comparator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个存放排序元素的列表</span></span><br><span class=\"line\">        list = (size &gt;= <span class=\"number\">0</span>) ? <span class=\"keyword\">new</span> ArrayList&lt;T&gt;((<span class=\"keyword\">int</span>) size) : <span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        list.sort(comparator);<span class=\"comment\">// 只有元素全部接收之后才能开始排序</span></span><br><span class=\"line\">        downstream.begin(list.size());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cancellationWasRequested) &#123;<span class=\"comment\">// 下游Sink不包含短路操作</span></span><br><span class=\"line\">            list.forEach(downstream::accept);<span class=\"comment\">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 下游Sink包含短路操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (T t : list) &#123;<span class=\"comment\">// 每次都调用cancellationRequested()询问是否可以结束处理。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (downstream.cancellationRequested()) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                downstream.accept(t);<span class=\"comment\">// 2. 将处理结果传递给流水线下游的Sink</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        downstream.end();</span><br><span class=\"line\">        list = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        list.add(t);<span class=\"comment\">// 1. 使用当前Sink包装动作处理t，只是简单的将元素添加到中间列表当中</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码完美的展现了Sink的四个接口方法是如何协同工作的：</p>\n<ul>\n<li>首先<code>beging()</code>方法告诉Sink参与排序的元素个数，方便确定中间结果容器的的大小；</li>\n<li>之后通过<code>accept()</code>方法将元素添加到中间结果当中，最终执行时调用者会不断调用该方法，直到遍历所有元素；</li>\n<li>最后<code>end()</code>方法告诉Sink所有元素遍历完毕，启动排序步骤，排序完成后将结果传递给下游的Sink；</li>\n<li>如果下游的Sink是短路操作，将结果传递给下游时不断询问下游<code>cancellationRequested()</code>是否可以结束处理。<h4 id=\"叠加之后的操作如何执行\"><a href=\"#叠加之后的操作如何执行\" class=\"headerlink\" title=\"叠加之后的操作如何执行\"></a>叠加之后的操作如何执行</h4>Sink完美封装了Stream每一步操作，并给出了[处理-&gt;转发]的模式来叠加操作。这一连串的齿轮已经咬合，就差最后一步拨动齿轮启动执行。是什么启动这一连串的操作呢？也许你已经想到了启动的原始动力就是结束操作(Terminal Operation)，一旦调用某个结束操作，就会触发整个流水线的执行。</li>\n</ul>\n<p>结束操作之后不能再有别的操作，所以结束操作不会创建新的流水线阶段(Stage)，直观的说就是流水线的链表不会在往后延伸了。结束操作会创建一个包装了自己操作的Sink，这也是流水线中最后一个Sink，这个Sink只需要处理数据而不需要将结果传递给下游的Sink（因为没有下游）。对于Sink的[处理-&gt;转发]模型，结束操作的Sink就是调用链的出口。</p>\n<p><img src=\"http://ozqzyzixv.bkt.clouddn.com/%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%89%A7%E8%A1%8C.png\" alt=\"流水线的执行\"></p>\n<p>我们再来考察一下上游的Sink是如何找到下游Sink的。一种可选的方案是在PipelineHelper中设置一个Sink字段，在流水线中找到下游Stage并访问Sink字段即可。但Stream类库的设计者没有这么做，而是设置了一个<code>Sink AbstractPipeline.opWrapSink(int flags, Sink downstream)</code>方法来得到Sink，该方法的作用是返回一个新的包含了当前Stage代表的操作以及能够将结果传递给downstream的Sink对象。为什么要产生一个新对象而不是返回一个Sink字段？这是因为使用opWrapSink()可以将当前操作与下游Sink（上文中的downstream参数）结合成新Sink。试想只要从流水线的最后一个Stage开始，不断调用上一个Stage的opWrapSink()方法直到最开始（不包括stage0，因为stage0代表数据源，不包含操作），就可以得到一个代表了流水线上所有操作的Sink，用代码表示就是这样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AbstractPipeline.wrapSink()</span></span><br><span class=\"line\"><span class=\"comment\">// 从下游向上游不断包装Sink。如果最初传入的sink代表结束操作，</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回时就可以得到一个代表了流水线上所有操作的Sink。</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN&gt; <span class=\"function\">Sink&lt;P_IN&gt; <span class=\"title\">wrapSink</span><span class=\"params\">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (AbstractPipeline p=AbstractPipeline.<span class=\"keyword\">this</span>; p.depth &gt; <span class=\"number\">0</span>; p=p.previousStage) &#123;</span><br><span class=\"line\">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在流水线上从开始到结束的所有的操作都被包装到了一个Sink里，执行这个Sink就相当于执行整个流水线，执行Sink的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AbstractPipeline.copyInto(), 对spliterator代表的数据执行wrappedSink代表的操作。</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> &lt;P_IN&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copyInto</span><span class=\"params\">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class=\"line\">        wrappedSink.begin(spliterator.getExactSizeIfKnown());<span class=\"comment\">// 通知开始遍历</span></span><br><span class=\"line\">        spliterator.forEachRemaining(wrappedSink);<span class=\"comment\">// 迭代</span></span><br><span class=\"line\">        wrappedSink.end();<span class=\"comment\">// 通知遍历结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码首先调用wrappedSink.begin()方法告诉Sink数据即将到来，然后调用spliterator.forEachRemaining()方法对数据进行迭代（Spliterator是容器的一种迭代器，参阅），最后调用wrappedSink.end()方法通知Sink数据处理结束。逻辑如此清晰。</p>\n<h4 id=\"执行后的结果在哪里\"><a href=\"#执行后的结果在哪里\" class=\"headerlink\" title=\"执行后的结果在哪里\"></a>执行后的结果在哪里</h4><p>最后一个问题是流水线上所有操作都执行后，用户所需要的结果（如果有）在哪里？首先要说明的是不是所有的Stream结束操作都需要返回结果，有些操作只是为了使用其副作用(Side-effects)，比如使用<code>Stream.forEach()</code>方法将结果打印出来就是常见的使用副作用的场景（事实上，除了打印之外其他场景都应避免使用副作用），对于真正需要返回结果的结束操作结果存在哪里呢？</p>\n<p><strong>特别说明：副作用不应该被滥用，也许你会觉得在Stream.forEach()里进行元素收集是个不错的选择，就像下面代码中那样，但遗憾的是这样使用的正确性和效率都无法保证，因为Stream可能会并行执行。大多数使用副作用的地方都可以使用归约操作更安全和有效的完成。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误的收集方式</span></span><br><span class=\"line\">ArrayList&lt;String&gt; results = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class=\"line\">      .forEach(s -&gt; results.add(s));  <span class=\"comment\">// Unnecessary use of side-effects!</span></span><br><span class=\"line\"><span class=\"comment\">// 正确的收集方式</span></span><br><span class=\"line\">List&lt;String&gt;results =</span><br><span class=\"line\">     stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class=\"line\">             .collect(Collectors.toList());  <span class=\"comment\">// No side-effects!</span></span><br></pre></td></tr></table></figure>\n<p>回到流水线执行结果的问题上来，需要返回结果的流水线结果存在哪里呢？这要分不同的情况讨论，下表给出了各种有返回结果的Stream结束操作。<br>|返回类型    |对应的结束操作    |<br>|———-:|———-:|<br>|boolean|anyMatch() allMatch() noneMatch()|<br>|Optional|findFirst() findAny()|<br>|归约结果    |reduce() collect()|<br>|数组|toArray()|</p>\n<ul>\n<li>对于表中返回boolean或者Optional的操作（Optional是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的Sink中记录这个值，等到执行结束时返回就可以了。</li>\n<li>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然max()和min()也是返回一个Optional，但事实上底层是通过调用reduce()方法实现的。</li>\n<li>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做Node的数据结构中的。Node是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。关于Node的具体结构，我们会在下一节探究Stream如何并行执行时给出详细说明。</li>\n</ul>\n<p>参考资料：</p>\n<p><a href=\"http://www.cnblogs.com/CarpenterLee/p/6729368.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java函数式编程》系列文章</a></p>\n<p><a href=\"http://lucida.me/\" target=\"_blank\" rel=\"noopener\">《深入理解Java 8 Lambda》系列文章</a></p>\n"},{"title":"Docker-intro","date":"2017-11-20T02:34:22.000Z","description":"docker的一些基本操作","_content":"\n\n\n### 查看docker信息（version、info）\n\n```bash\n# 查看docker版本  \n$docker version  \n# 显示docker系统的信息  \n$docker info  \n```\n\n### 对image的操作（search、pull、images、rmi、history）\n```bash\n # 检索image  \n$docker search image_name  \n  \n# 下载image  \n$docker pull image_name  \n  \n# 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  \n$docker images  \n  \n# 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  \n$docker rmi image_name  \n  \n# 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  \n$docker history image_name \n``` \n\n### 启动容器（run）\n```bash\n# 在容器中运行\"echo\"命令，输出\"hello word\"  \n$docker run image_name echo \"hello word\"  \n\n# 交互式进入容器中  \n$docker run -i -t image_name /bin/bash  \n\n\n# 在容器中安装新的程序  \n$docker run image_name apt-get install -y app_name  \n```\n\n### 查看容器（ps）\n```bash\n# 列出当前所有正在运行的container  \n$docker ps  \n# 列出所有的container  \n$docker ps -a  \n# 列出最近一次启动的container  \n$docker ps -l  \n```\n    \n### 保存对容器的修改（commit）\n\n```bash\n # 保存对容器的修改; -a, --author=\"\" Author; -m, --message=\"\" Commit message  \n$docker commit ID new_image_name \n```\n    \n### 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\n    \n```bash\n# 删除所有容器  \n$docker rm `docker ps -a -q`  \n  \n# 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container  \n$docker rm Name/ID  \n  \n# 停止、启动、杀死一个容器  \n$docker stop Name/ID  \n$docker start Name/ID  \n$docker kill Name/ID  \n  \n# 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  \n$docker logs Name/ID  \n  \n# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  \n$docker diff Name/ID  \n  \n# 显示一个运行的容器里面的进程信息  \n$docker top Name/ID  \n  \n# 从容器里面拷贝文件/目录到本地一个路径  \n$docker cp Name:/container_path to_path  \n$docker cp ID:/container_path to_path  \n  \n# 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  \n$docker restart Name/ID  \n  \n# 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  \n$docker attach ID \n```\n    \n### 保存和加载镜像（save、load）\n    \n```bash\n# 保存镜像到一个tar包; -o, --output=\"\" Write to an file  \n$docker save image_name -o file_path  \n# 加载一个tar包格式的镜像; -i, --input=\"\" Read from a tar archive file  \n$docker load -i file_path  \n  \n# 机器a  \n$docker save image_name > /home/save.tar  \n# 使用scp将save.tar拷到机器b上，然后：  \n$docker load < /home/save.tar  \n```\n    \n### 登录registry server（login）\n```bash\n# 登陆registry server; -e, --email=\"\" Email; -p, --password=\"\" Password; -u, --username=\"\" Username  \n$docker login \n```\n    \n### 发布image（push）\n```bash\n# 发布docker镜像  \n$docker push new_image_name  \n\n```\n### 根据Dockerfile 构建出一个容器\n```bash\n#build  \n      --no-cache=false Do not use cache when building the image  \n      -q, --quiet=false Suppress the verbose output generated by the containers  \n      --rm=true Remove intermediate containers after a successful build  \n      -t, --tag=\"\" Repository name (and optionally a tag) to be applied to the resulting image in case of success  \n$docker build -t image_name Dockerfile_path  \n```","source":"_posts/service/docker/Docker-intro.md","raw":"---\ntitle : Docker-intro\ndate: 2017-11-20 10:34:22\ncategories: 服务器\ntags: [docker]\ndescription: docker的一些基本操作\n---\n\n\n\n### 查看docker信息（version、info）\n\n```bash\n# 查看docker版本  \n$docker version  \n# 显示docker系统的信息  \n$docker info  \n```\n\n### 对image的操作（search、pull、images、rmi、history）\n```bash\n # 检索image  \n$docker search image_name  \n  \n# 下载image  \n$docker pull image_name  \n  \n# 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  \n$docker images  \n  \n# 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  \n$docker rmi image_name  \n  \n# 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  \n$docker history image_name \n``` \n\n### 启动容器（run）\n```bash\n# 在容器中运行\"echo\"命令，输出\"hello word\"  \n$docker run image_name echo \"hello word\"  \n\n# 交互式进入容器中  \n$docker run -i -t image_name /bin/bash  \n\n\n# 在容器中安装新的程序  \n$docker run image_name apt-get install -y app_name  \n```\n\n### 查看容器（ps）\n```bash\n# 列出当前所有正在运行的container  \n$docker ps  \n# 列出所有的container  \n$docker ps -a  \n# 列出最近一次启动的container  \n$docker ps -l  \n```\n    \n### 保存对容器的修改（commit）\n\n```bash\n # 保存对容器的修改; -a, --author=\"\" Author; -m, --message=\"\" Commit message  \n$docker commit ID new_image_name \n```\n    \n### 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\n    \n```bash\n# 删除所有容器  \n$docker rm `docker ps -a -q`  \n  \n# 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container  \n$docker rm Name/ID  \n  \n# 停止、启动、杀死一个容器  \n$docker stop Name/ID  \n$docker start Name/ID  \n$docker kill Name/ID  \n  \n# 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  \n$docker logs Name/ID  \n  \n# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  \n$docker diff Name/ID  \n  \n# 显示一个运行的容器里面的进程信息  \n$docker top Name/ID  \n  \n# 从容器里面拷贝文件/目录到本地一个路径  \n$docker cp Name:/container_path to_path  \n$docker cp ID:/container_path to_path  \n  \n# 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  \n$docker restart Name/ID  \n  \n# 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  \n$docker attach ID \n```\n    \n### 保存和加载镜像（save、load）\n    \n```bash\n# 保存镜像到一个tar包; -o, --output=\"\" Write to an file  \n$docker save image_name -o file_path  \n# 加载一个tar包格式的镜像; -i, --input=\"\" Read from a tar archive file  \n$docker load -i file_path  \n  \n# 机器a  \n$docker save image_name > /home/save.tar  \n# 使用scp将save.tar拷到机器b上，然后：  \n$docker load < /home/save.tar  \n```\n    \n### 登录registry server（login）\n```bash\n# 登陆registry server; -e, --email=\"\" Email; -p, --password=\"\" Password; -u, --username=\"\" Username  \n$docker login \n```\n    \n### 发布image（push）\n```bash\n# 发布docker镜像  \n$docker push new_image_name  \n\n```\n### 根据Dockerfile 构建出一个容器\n```bash\n#build  \n      --no-cache=false Do not use cache when building the image  \n      -q, --quiet=false Suppress the verbose output generated by the containers  \n      --rm=true Remove intermediate containers after a successful build  \n      -t, --tag=\"\" Repository name (and optionally a tag) to be applied to the resulting image in case of success  \n$docker build -t image_name Dockerfile_path  \n```","slug":"service/docker/Docker-intro","published":1,"updated":"2017-12-15T08:12:58.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqs001t6dofvmtg64g9","content":"<h3 id=\"查看docker信息（version、info）\"><a href=\"#查看docker信息（version、info）\" class=\"headerlink\" title=\"查看docker信息（version、info）\"></a>查看docker信息（version、info）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看docker版本  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> version  </span><br><span class=\"line\"><span class=\"comment\"># 显示docker系统的信息  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> info</span><br></pre></td></tr></table></figure>\n<h3 id=\"对image的操作（search、pull、images、rmi、history）\"><a href=\"#对image的操作（search、pull、images、rmi、history）\" class=\"headerlink\" title=\"对image的操作（search、pull、images、rmi、history）\"></a>对image的操作（search、pull、images、rmi、history）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\"># 检索image  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> search image_name  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 下载image  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> pull image_name  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> images  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> rmi image_name  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> <span class=\"built_in\">history</span> image_name </span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 启动容器（run）</span></span><br><span class=\"line\">```bash</span><br><span class=\"line\"><span class=\"comment\"># 在容器中运行\"echo\"命令，输出\"hello word\"  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> run image_name <span class=\"built_in\">echo</span> <span class=\"string\">\"hello word\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 交互式进入容器中  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> run -i -t image_name /bin/bash  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在容器中安装新的程序  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> run image_name apt-get install -y app_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看容器（ps）\"><a href=\"#查看容器（ps）\" class=\"headerlink\" title=\"查看容器（ps）\"></a>查看容器（ps）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出当前所有正在运行的container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> ps  </span><br><span class=\"line\"><span class=\"comment\"># 列出所有的container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> ps -a  </span><br><span class=\"line\"><span class=\"comment\"># 列出最近一次启动的container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> ps -l</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存对容器的修改（commit）\"><a href=\"#保存对容器的修改（commit）\" class=\"headerlink\" title=\"保存对容器的修改（commit）\"></a>保存对容器的修改（commit）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\"># 保存对容器的修改; -a, --author=\"\" Author; -m, --message=\"\" Commit message  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> commit ID new_image_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\"><a href=\"#对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\" class=\"headerlink\" title=\"对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\"></a>对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有容器  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> rm `docker ps -a -q`  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> rm Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 停止、启动、杀死一个容器  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> stop Name/ID  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> start Name/ID  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> <span class=\"built_in\">kill</span> Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> logs Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> diff Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 显示一个运行的容器里面的进程信息  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> top Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 从容器里面拷贝文件/目录到本地一个路径  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> cp Name:/container_path to_path  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> cp ID:/container_path to_path  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> restart Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> attach ID</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存和加载镜像（save、load）\"><a href=\"#保存和加载镜像（save、load）\" class=\"headerlink\" title=\"保存和加载镜像（save、load）\"></a>保存和加载镜像（save、load）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存镜像到一个tar包; -o, --output=\"\" Write to an file  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> save image_name -o file_path  </span><br><span class=\"line\"><span class=\"comment\"># 加载一个tar包格式的镜像; -i, --input=\"\" Read from a tar archive file  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> load -i file_path  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 机器a  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> save image_name &gt; /home/save.tar  </span><br><span class=\"line\"><span class=\"comment\"># 使用scp将save.tar拷到机器b上，然后：  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> load &lt; /home/save.tar</span><br></pre></td></tr></table></figure>\n<h3 id=\"登录registry-server（login）\"><a href=\"#登录registry-server（login）\" class=\"headerlink\" title=\"登录registry server（login）\"></a>登录registry server（login）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登陆registry server; -e, --email=\"\" Email; -p, --password=\"\" Password; -u, --username=\"\" Username  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> login</span><br></pre></td></tr></table></figure>\n<h3 id=\"发布image（push）\"><a href=\"#发布image（push）\" class=\"headerlink\" title=\"发布image（push）\"></a>发布image（push）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发布docker镜像  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> push new_image_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"根据Dockerfile-构建出一个容器\"><a href=\"#根据Dockerfile-构建出一个容器\" class=\"headerlink\" title=\"根据Dockerfile 构建出一个容器\"></a>根据Dockerfile 构建出一个容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#build  </span></span><br><span class=\"line\">      --no-cache=<span class=\"literal\">false</span> Do not use cache when building the image  </span><br><span class=\"line\">      -q, --quiet=<span class=\"literal\">false</span> Suppress the verbose output generated by the containers  </span><br><span class=\"line\">      --rm=<span class=\"literal\">true</span> Remove intermediate containers after a successful build  </span><br><span class=\"line\">      -t, --tag=<span class=\"string\">\"\"</span> Repository name (and optionally a tag) to be applied to the resulting image <span class=\"keyword\">in</span> <span class=\"keyword\">case</span> of success  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> build -t image_name Dockerfile_path</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"查看docker信息（version、info）\"><a href=\"#查看docker信息（version、info）\" class=\"headerlink\" title=\"查看docker信息（version、info）\"></a>查看docker信息（version、info）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看docker版本  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> version  </span><br><span class=\"line\"><span class=\"comment\"># 显示docker系统的信息  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> info</span><br></pre></td></tr></table></figure>\n<h3 id=\"对image的操作（search、pull、images、rmi、history）\"><a href=\"#对image的操作（search、pull、images、rmi、history）\" class=\"headerlink\" title=\"对image的操作（search、pull、images、rmi、history）\"></a>对image的操作（search、pull、images、rmi、history）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\"># 检索image  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> search image_name  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 下载image  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> pull image_name  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> images  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> rmi image_name  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> <span class=\"built_in\">history</span> image_name </span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 启动容器（run）</span></span><br><span class=\"line\">```bash</span><br><span class=\"line\"><span class=\"comment\"># 在容器中运行\"echo\"命令，输出\"hello word\"  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> run image_name <span class=\"built_in\">echo</span> <span class=\"string\">\"hello word\"</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 交互式进入容器中  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> run -i -t image_name /bin/bash  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在容器中安装新的程序  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> run image_name apt-get install -y app_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"查看容器（ps）\"><a href=\"#查看容器（ps）\" class=\"headerlink\" title=\"查看容器（ps）\"></a>查看容器（ps）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出当前所有正在运行的container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> ps  </span><br><span class=\"line\"><span class=\"comment\"># 列出所有的container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> ps -a  </span><br><span class=\"line\"><span class=\"comment\"># 列出最近一次启动的container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> ps -l</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存对容器的修改（commit）\"><a href=\"#保存对容器的修改（commit）\" class=\"headerlink\" title=\"保存对容器的修改（commit）\"></a>保存对容器的修改（commit）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\"># 保存对容器的修改; -a, --author=\"\" Author; -m, --message=\"\" Commit message  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> commit ID new_image_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\"><a href=\"#对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\" class=\"headerlink\" title=\"对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）\"></a>对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 删除所有容器  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> rm `docker ps -a -q`  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> rm Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 停止、启动、杀死一个容器  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> stop Name/ID  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> start Name/ID  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> <span class=\"built_in\">kill</span> Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> logs Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> diff Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 显示一个运行的容器里面的进程信息  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> top Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 从容器里面拷贝文件/目录到本地一个路径  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> cp Name:/container_path to_path  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> cp ID:/container_path to_path  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> restart Name/ID  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> attach ID</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存和加载镜像（save、load）\"><a href=\"#保存和加载镜像（save、load）\" class=\"headerlink\" title=\"保存和加载镜像（save、load）\"></a>保存和加载镜像（save、load）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 保存镜像到一个tar包; -o, --output=\"\" Write to an file  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> save image_name -o file_path  </span><br><span class=\"line\"><span class=\"comment\"># 加载一个tar包格式的镜像; -i, --input=\"\" Read from a tar archive file  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> load -i file_path  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 机器a  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> save image_name &gt; /home/save.tar  </span><br><span class=\"line\"><span class=\"comment\"># 使用scp将save.tar拷到机器b上，然后：  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> load &lt; /home/save.tar</span><br></pre></td></tr></table></figure>\n<h3 id=\"登录registry-server（login）\"><a href=\"#登录registry-server（login）\" class=\"headerlink\" title=\"登录registry server（login）\"></a>登录registry server（login）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登陆registry server; -e, --email=\"\" Email; -p, --password=\"\" Password; -u, --username=\"\" Username  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> login</span><br></pre></td></tr></table></figure>\n<h3 id=\"发布image（push）\"><a href=\"#发布image（push）\" class=\"headerlink\" title=\"发布image（push）\"></a>发布image（push）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 发布docker镜像  </span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> push new_image_name</span><br></pre></td></tr></table></figure>\n<h3 id=\"根据Dockerfile-构建出一个容器\"><a href=\"#根据Dockerfile-构建出一个容器\" class=\"headerlink\" title=\"根据Dockerfile 构建出一个容器\"></a>根据Dockerfile 构建出一个容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#build  </span></span><br><span class=\"line\">      --no-cache=<span class=\"literal\">false</span> Do not use cache when building the image  </span><br><span class=\"line\">      -q, --quiet=<span class=\"literal\">false</span> Suppress the verbose output generated by the containers  </span><br><span class=\"line\">      --rm=<span class=\"literal\">true</span> Remove intermediate containers after a successful build  </span><br><span class=\"line\">      -t, --tag=<span class=\"string\">\"\"</span> Repository name (and optionally a tag) to be applied to the resulting image <span class=\"keyword\">in</span> <span class=\"keyword\">case</span> of success  </span><br><span class=\"line\"><span class=\"variable\">$docker</span> build -t image_name Dockerfile_path</span><br></pre></td></tr></table></figure>"},{"title":"hexo+gitPage+travis-ci自动部署","date":"2017-11-20T07:33:22.000Z","description":"之前整理笔记一直在自己的leanote私服上放着，后来发现笔记越来越多，也很乱！于是，狠下决心花些时间把笔记好好整理一下。所以，这次打算放gitPage上，travis-ci做持续构建,做到本地markdown文件提交到git后，自动部署到gitPage上，简单省事！而且Hexo提供了很多主题模板，也就不重复造轮子了！","_content":"\n## Hexo 填坑之路\n### 准备\n安装nvm\n```bash\ncurl https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n安装node\n```bash\nnvm install v8.1.2\n```\n在此处遇到一个小问题，nvm安装node之后，`node -v`一直找不到node，后来`nvm ls`看了一下，当前node版本没有指定所以需要`nvm use v8.1.2`手动指定一下\n\n安装hexo脚手架\n```bash\nnpm install -g hexo-cli\n```\n创建Hexo工程\n```bash\nhexo init <folder>\ncd <folder>\nnpm install\n\n```\n### Hexo相关配置\n\n","source":"_posts/service/git/hexo+gitPage+travis-ci.md","raw":"---\ntitle: hexo+gitPage+travis-ci自动部署\ndate: 2017-11-20 15:33:22\ncategories: 服务器\ntags: [server]\ndescription: 之前整理笔记一直在自己的leanote私服上放着，后来发现笔记越来越多，也很乱！于是，狠下决心花些时间把笔记好好整理一下。所以，这次打算放gitPage上，travis-ci做持续构建,做到本地markdown文件提交到git后，自动部署到gitPage上，简单省事！而且Hexo提供了很多主题模板，也就不重复造轮子了！\n---\n\n## Hexo 填坑之路\n### 准备\n安装nvm\n```bash\ncurl https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n安装node\n```bash\nnvm install v8.1.2\n```\n在此处遇到一个小问题，nvm安装node之后，`node -v`一直找不到node，后来`nvm ls`看了一下，当前node版本没有指定所以需要`nvm use v8.1.2`手动指定一下\n\n安装hexo脚手架\n```bash\nnpm install -g hexo-cli\n```\n创建Hexo工程\n```bash\nhexo init <folder>\ncd <folder>\nnpm install\n\n```\n### Hexo相关配置\n\n","slug":"service/git/hexo+gitPage+travis-ci","published":1,"updated":"2017-12-15T08:12:58.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqu001x6dofaesdwn6d","content":"<h2 id=\"Hexo-填坑之路\"><a href=\"#Hexo-填坑之路\" class=\"headerlink\" title=\"Hexo 填坑之路\"></a>Hexo 填坑之路</h2><h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>安装nvm<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p>\n<p>安装node<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install v8.1.2</span><br></pre></td></tr></table></figure></p>\n<p>在此处遇到一个小问题，nvm安装node之后，<code>node -v</code>一直找不到node，后来<code>nvm ls</code>看了一下，当前node版本没有指定所以需要<code>nvm use v8.1.2</code>手动指定一下</p>\n<p>安装hexo脚手架<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>\n<p>创建Hexo工程<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init &lt;folder&gt;</span><br><span class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Hexo相关配置\"><a href=\"#Hexo相关配置\" class=\"headerlink\" title=\"Hexo相关配置\"></a>Hexo相关配置</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hexo-填坑之路\"><a href=\"#Hexo-填坑之路\" class=\"headerlink\" title=\"Hexo 填坑之路\"></a>Hexo 填坑之路</h2><h3 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h3><p>安装nvm<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p>\n<p>安装node<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install v8.1.2</span><br></pre></td></tr></table></figure></p>\n<p>在此处遇到一个小问题，nvm安装node之后，<code>node -v</code>一直找不到node，后来<code>nvm ls</code>看了一下，当前node版本没有指定所以需要<code>nvm use v8.1.2</code>手动指定一下</p>\n<p>安装hexo脚手架<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>\n<p>创建Hexo工程<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init &lt;folder&gt;</span><br><span class=\"line\"><span class=\"built_in\">cd</span> &lt;folder&gt;</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Hexo相关配置\"><a href=\"#Hexo相关配置\" class=\"headerlink\" title=\"Hexo相关配置\"></a>Hexo相关配置</h3>"},{"title":"elasticsearch","date":"2017-11-20T02:34:22.000Z","description":"elasticsearch docker安装以及常用操作","_content":"\n### 安装\n```bash\ndocker pull elasticsearch\n\ndocker run -itd \\\n    --name my-es \\\n    -p 9200:9200 \\\n    -p 9300:9300 \\\n    -v /Users/lit/docker/elasticsearch/es-conf/:/usr/share/elasticsearch/config/ \\\n    -v /Users/lit/docker/elasticsearch/es-data/:/usr/share/elasticsearch/data/:rw \\\n    elasticsearch\n\ndocker start my-es\n\ndocker exec -it my-es bash\n\nvi /Users/lit/docker/elasticsearch/es-conf/elasticsearch.yml\ncluster.name: \"my-es\"   # 节点名如果不设置，会自动随机生成\nnode.name: \"local\"\n```\n\n\n    \n测试 Elasticsearch 是否启动成功\n\n```bash\ncurl 'http://localhost:9200/?pretty'\n```\n### RESTful API\n```bash\n#计算集群中文件的数量\n    curl -XGET 'http://localhost:9200/_count?pretty' -d '\n    {  \n        \"query\": {\n            \"match_all\": {}\n        }\n    }'\n```\n### 索引\n在 Elasticsearch 中，文档属于一种 类型(type)，各种各样的类型存在于一个 索引 中。你也可以通过类比传统的关系数据库得到一些大致的相似之处：\n\n```bash\n关系数据库     ⇒ 数据库 ⇒ 表    ⇒ 行    ⇒ 列(Columns)\nElasticsearch  ⇒ 索引   ⇒ 类型  ⇒ 文档  ⇒ 字段(Fields)\n一个 Elasticsearch 集群可以包含多个\n```\n索引（数据库），也就是说其中包含了很多 类型（表）。这些类型中包含了很多的 文档（行），然后每个文档中又包含了很多的 字段（列）。\n```bash\n#插入示例：\n    curl -XPUT 'http://localhost:9200/megacorp/employee/1?pretty' -d '\n    {\n        \"first_name\" : \"John\",\n        \"last_name\" :  \"Smith\",\n        \"age\" :        25,\n        \"about\" :      \"I love to go rock climbing\",\n        \"interests\": [ \"sports\", \"music\" ]\n    }'\t\n# 会得到类似返回值\n    {\n      \"_index\" : \"megacorp\",\n      \"_type\" : \"employee\",\n      \"_id\" : \"1\",\n      \"_version\" : 1,\n      \"result\" : \"created\",\n      \"_shards\" : {\n        \"total\" : 2,\n        \"successful\" : 1,\n        \"failed\" : 0\n      },\n      \"created\" : true\n    }\n#检索示例：\n    curl -XGET 'http://localhost:9200/megacorp/employee/1?pretty'\n# 会得到类似返回值\n    {\n      \"_index\" : \"megacorp\",\n      \"_type\" : \"employee\",\n      \"_id\" : \"1\",\n      \"_version\" : 2,\n      \"found\" : true,\n      \"_source\" : {\n        \"first_name\" : \"Douglas\",\n        \"last_name\" : \"Fir\",\n        \"age\" : 35,\n        \"about\" : \"I like to build cabinets\",\n        \"interests\" : [\n          \"forestry\"\n        ]\n      }\n    }\n#删除示例\n    curl -XDELETE 'http://localhost:9200/megacorp/employee/3?pretty'\n# 全部搜索\n    curl -XGET 'http://localhost:9200/megacorp/employee/_search?pretty'\n# 关键字搜索\n    curl -XGET 'http://localhost:9200/megacorp/employee/_search?q=last_name:Fir&pretty'\n```\n### Query DSL搜索\n```bash\ncurl -XGET 'http://localhost:9200/megacorp/employee/_search?pretty' -d '\n    {\n        \"query\" : {\n            \"match\" : {\n                \"last_name\" : \"Smith\"\n            }\n        }\n    }'\n```\n    \n    \n    ","source":"_posts/service/elasticsearch/elasticsearch.md","raw":"---\ntitle: elasticsearch\ndate: 2017-11-20 10:34:22\ncategories: 服务器\ntags: [elasticsearch]\ndescription: \"elasticsearch docker安装以及常用操作\"\n---\n\n### 安装\n```bash\ndocker pull elasticsearch\n\ndocker run -itd \\\n    --name my-es \\\n    -p 9200:9200 \\\n    -p 9300:9300 \\\n    -v /Users/lit/docker/elasticsearch/es-conf/:/usr/share/elasticsearch/config/ \\\n    -v /Users/lit/docker/elasticsearch/es-data/:/usr/share/elasticsearch/data/:rw \\\n    elasticsearch\n\ndocker start my-es\n\ndocker exec -it my-es bash\n\nvi /Users/lit/docker/elasticsearch/es-conf/elasticsearch.yml\ncluster.name: \"my-es\"   # 节点名如果不设置，会自动随机生成\nnode.name: \"local\"\n```\n\n\n    \n测试 Elasticsearch 是否启动成功\n\n```bash\ncurl 'http://localhost:9200/?pretty'\n```\n### RESTful API\n```bash\n#计算集群中文件的数量\n    curl -XGET 'http://localhost:9200/_count?pretty' -d '\n    {  \n        \"query\": {\n            \"match_all\": {}\n        }\n    }'\n```\n### 索引\n在 Elasticsearch 中，文档属于一种 类型(type)，各种各样的类型存在于一个 索引 中。你也可以通过类比传统的关系数据库得到一些大致的相似之处：\n\n```bash\n关系数据库     ⇒ 数据库 ⇒ 表    ⇒ 行    ⇒ 列(Columns)\nElasticsearch  ⇒ 索引   ⇒ 类型  ⇒ 文档  ⇒ 字段(Fields)\n一个 Elasticsearch 集群可以包含多个\n```\n索引（数据库），也就是说其中包含了很多 类型（表）。这些类型中包含了很多的 文档（行），然后每个文档中又包含了很多的 字段（列）。\n```bash\n#插入示例：\n    curl -XPUT 'http://localhost:9200/megacorp/employee/1?pretty' -d '\n    {\n        \"first_name\" : \"John\",\n        \"last_name\" :  \"Smith\",\n        \"age\" :        25,\n        \"about\" :      \"I love to go rock climbing\",\n        \"interests\": [ \"sports\", \"music\" ]\n    }'\t\n# 会得到类似返回值\n    {\n      \"_index\" : \"megacorp\",\n      \"_type\" : \"employee\",\n      \"_id\" : \"1\",\n      \"_version\" : 1,\n      \"result\" : \"created\",\n      \"_shards\" : {\n        \"total\" : 2,\n        \"successful\" : 1,\n        \"failed\" : 0\n      },\n      \"created\" : true\n    }\n#检索示例：\n    curl -XGET 'http://localhost:9200/megacorp/employee/1?pretty'\n# 会得到类似返回值\n    {\n      \"_index\" : \"megacorp\",\n      \"_type\" : \"employee\",\n      \"_id\" : \"1\",\n      \"_version\" : 2,\n      \"found\" : true,\n      \"_source\" : {\n        \"first_name\" : \"Douglas\",\n        \"last_name\" : \"Fir\",\n        \"age\" : 35,\n        \"about\" : \"I like to build cabinets\",\n        \"interests\" : [\n          \"forestry\"\n        ]\n      }\n    }\n#删除示例\n    curl -XDELETE 'http://localhost:9200/megacorp/employee/3?pretty'\n# 全部搜索\n    curl -XGET 'http://localhost:9200/megacorp/employee/_search?pretty'\n# 关键字搜索\n    curl -XGET 'http://localhost:9200/megacorp/employee/_search?q=last_name:Fir&pretty'\n```\n### Query DSL搜索\n```bash\ncurl -XGET 'http://localhost:9200/megacorp/employee/_search?pretty' -d '\n    {\n        \"query\" : {\n            \"match\" : {\n                \"last_name\" : \"Smith\"\n            }\n        }\n    }'\n```\n    \n    \n    ","slug":"service/elasticsearch/elasticsearch","published":1,"updated":"2017-12-15T08:12:58.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqv001z6doflup929aj","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull elasticsearch</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -itd \\</span><br><span class=\"line\">    --name my-es \\</span><br><span class=\"line\">    -p 9200:9200 \\</span><br><span class=\"line\">    -p 9300:9300 \\</span><br><span class=\"line\">    -v /Users/lit/docker/elasticsearch/es-conf/:/usr/share/elasticsearch/config/ \\</span><br><span class=\"line\">    -v /Users/lit/docker/elasticsearch/es-data/:/usr/share/elasticsearch/data/:rw \\</span><br><span class=\"line\">    elasticsearch</span><br><span class=\"line\"></span><br><span class=\"line\">docker start my-es</span><br><span class=\"line\"></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it my-es bash</span><br><span class=\"line\"></span><br><span class=\"line\">vi /Users/lit/docker/elasticsearch/es-conf/elasticsearch.yml</span><br><span class=\"line\">cluster.name: <span class=\"string\">\"my-es\"</span>   <span class=\"comment\"># 节点名如果不设置，会自动随机生成</span></span><br><span class=\"line\">node.name: <span class=\"string\">\"local\"</span></span><br></pre></td></tr></table></figure>\n<p>测试 Elasticsearch 是否启动成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl <span class=\"string\">'http://localhost:9200/?pretty'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#计算集群中文件的数量</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/_count?pretty'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">    &#123;  </span></span><br><span class=\"line\"><span class=\"string\">        \"query\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">            \"match_all\": &#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>在 Elasticsearch 中，文档属于一种 类型(type)，各种各样的类型存在于一个 索引 中。你也可以通过类比传统的关系数据库得到一些大致的相似之处：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">关系数据库     ⇒ 数据库 ⇒ 表    ⇒ 行    ⇒ 列(Columns)</span><br><span class=\"line\">Elasticsearch  ⇒ 索引   ⇒ 类型  ⇒ 文档  ⇒ 字段(Fields)</span><br><span class=\"line\">一个 Elasticsearch 集群可以包含多个</span><br></pre></td></tr></table></figure>\n<p>索引（数据库），也就是说其中包含了很多 类型（表）。这些类型中包含了很多的 文档（行），然后每个文档中又包含了很多的 字段（列）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#插入示例：</span></span><br><span class=\"line\">    curl -XPUT <span class=\"string\">'http://localhost:9200/megacorp/employee/1?pretty'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"first_name\" : \"John\",</span></span><br><span class=\"line\"><span class=\"string\">        \"last_name\" :  \"Smith\",</span></span><br><span class=\"line\"><span class=\"string\">        \"age\" :        25,</span></span><br><span class=\"line\"><span class=\"string\">        \"about\" :      \"I love to go rock climbing\",</span></span><br><span class=\"line\"><span class=\"string\">        \"interests\": [ \"sports\", \"music\" ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span>\t</span><br><span class=\"line\"><span class=\"comment\"># 会得到类似返回值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"megacorp\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"employee\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_version\"</span> : 1,</span><br><span class=\"line\">      <span class=\"string\">\"result\"</span> : <span class=\"string\">\"created\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_shards\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">\"total\"</span> : 2,</span><br><span class=\"line\">        <span class=\"string\">\"successful\"</span> : 1,</span><br><span class=\"line\">        <span class=\"string\">\"failed\"</span> : 0</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"created\"</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">#检索示例：</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/1?pretty'</span></span><br><span class=\"line\"><span class=\"comment\"># 会得到类似返回值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"megacorp\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"employee\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_version\"</span> : 2,</span><br><span class=\"line\">      <span class=\"string\">\"found\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_source\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">\"first_name\"</span> : <span class=\"string\">\"Douglas\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"last_name\"</span> : <span class=\"string\">\"Fir\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"age\"</span> : 35,</span><br><span class=\"line\">        <span class=\"string\">\"about\"</span> : <span class=\"string\">\"I like to build cabinets\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"interests\"</span> : [</span><br><span class=\"line\">          <span class=\"string\">\"forestry\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">#删除示例</span></span><br><span class=\"line\">    curl -XDELETE <span class=\"string\">'http://localhost:9200/megacorp/employee/3?pretty'</span></span><br><span class=\"line\"><span class=\"comment\"># 全部搜索</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/_search?pretty'</span></span><br><span class=\"line\"><span class=\"comment\"># 关键字搜索</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/_search?q=last_name:Fir&amp;pretty'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Query-DSL搜索\"><a href=\"#Query-DSL搜索\" class=\"headerlink\" title=\"Query DSL搜索\"></a>Query DSL搜索</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/_search?pretty'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"query\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">            \"match\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">                \"last_name\" : \"Smith\"</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull elasticsearch</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -itd \\</span><br><span class=\"line\">    --name my-es \\</span><br><span class=\"line\">    -p 9200:9200 \\</span><br><span class=\"line\">    -p 9300:9300 \\</span><br><span class=\"line\">    -v /Users/lit/docker/elasticsearch/es-conf/:/usr/share/elasticsearch/config/ \\</span><br><span class=\"line\">    -v /Users/lit/docker/elasticsearch/es-data/:/usr/share/elasticsearch/data/:rw \\</span><br><span class=\"line\">    elasticsearch</span><br><span class=\"line\"></span><br><span class=\"line\">docker start my-es</span><br><span class=\"line\"></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it my-es bash</span><br><span class=\"line\"></span><br><span class=\"line\">vi /Users/lit/docker/elasticsearch/es-conf/elasticsearch.yml</span><br><span class=\"line\">cluster.name: <span class=\"string\">\"my-es\"</span>   <span class=\"comment\"># 节点名如果不设置，会自动随机生成</span></span><br><span class=\"line\">node.name: <span class=\"string\">\"local\"</span></span><br></pre></td></tr></table></figure>\n<p>测试 Elasticsearch 是否启动成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl <span class=\"string\">'http://localhost:9200/?pretty'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"RESTful-API\"><a href=\"#RESTful-API\" class=\"headerlink\" title=\"RESTful API\"></a>RESTful API</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#计算集群中文件的数量</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/_count?pretty'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">    &#123;  </span></span><br><span class=\"line\"><span class=\"string\">        \"query\": &#123;</span></span><br><span class=\"line\"><span class=\"string\">            \"match_all\": &#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>在 Elasticsearch 中，文档属于一种 类型(type)，各种各样的类型存在于一个 索引 中。你也可以通过类比传统的关系数据库得到一些大致的相似之处：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">关系数据库     ⇒ 数据库 ⇒ 表    ⇒ 行    ⇒ 列(Columns)</span><br><span class=\"line\">Elasticsearch  ⇒ 索引   ⇒ 类型  ⇒ 文档  ⇒ 字段(Fields)</span><br><span class=\"line\">一个 Elasticsearch 集群可以包含多个</span><br></pre></td></tr></table></figure>\n<p>索引（数据库），也就是说其中包含了很多 类型（表）。这些类型中包含了很多的 文档（行），然后每个文档中又包含了很多的 字段（列）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#插入示例：</span></span><br><span class=\"line\">    curl -XPUT <span class=\"string\">'http://localhost:9200/megacorp/employee/1?pretty'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"first_name\" : \"John\",</span></span><br><span class=\"line\"><span class=\"string\">        \"last_name\" :  \"Smith\",</span></span><br><span class=\"line\"><span class=\"string\">        \"age\" :        25,</span></span><br><span class=\"line\"><span class=\"string\">        \"about\" :      \"I love to go rock climbing\",</span></span><br><span class=\"line\"><span class=\"string\">        \"interests\": [ \"sports\", \"music\" ]</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span>\t</span><br><span class=\"line\"><span class=\"comment\"># 会得到类似返回值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"megacorp\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"employee\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_version\"</span> : 1,</span><br><span class=\"line\">      <span class=\"string\">\"result\"</span> : <span class=\"string\">\"created\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_shards\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">\"total\"</span> : 2,</span><br><span class=\"line\">        <span class=\"string\">\"successful\"</span> : 1,</span><br><span class=\"line\">        <span class=\"string\">\"failed\"</span> : 0</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"created\"</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">#检索示例：</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/1?pretty'</span></span><br><span class=\"line\"><span class=\"comment\"># 会得到类似返回值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"_index\"</span> : <span class=\"string\">\"megacorp\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_type\"</span> : <span class=\"string\">\"employee\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_id\"</span> : <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_version\"</span> : 2,</span><br><span class=\"line\">      <span class=\"string\">\"found\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"string\">\"_source\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">\"first_name\"</span> : <span class=\"string\">\"Douglas\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"last_name\"</span> : <span class=\"string\">\"Fir\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"age\"</span> : 35,</span><br><span class=\"line\">        <span class=\"string\">\"about\"</span> : <span class=\"string\">\"I like to build cabinets\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"interests\"</span> : [</span><br><span class=\"line\">          <span class=\"string\">\"forestry\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">#删除示例</span></span><br><span class=\"line\">    curl -XDELETE <span class=\"string\">'http://localhost:9200/megacorp/employee/3?pretty'</span></span><br><span class=\"line\"><span class=\"comment\"># 全部搜索</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/_search?pretty'</span></span><br><span class=\"line\"><span class=\"comment\"># 关键字搜索</span></span><br><span class=\"line\">    curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/_search?q=last_name:Fir&amp;pretty'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Query-DSL搜索\"><a href=\"#Query-DSL搜索\" class=\"headerlink\" title=\"Query DSL搜索\"></a>Query DSL搜索</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -XGET <span class=\"string\">'http://localhost:9200/megacorp/employee/_search?pretty'</span> -d <span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">        \"query\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">            \"match\" : &#123;</span></span><br><span class=\"line\"><span class=\"string\">                \"last_name\" : \"Smith\"</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;'</span></span><br></pre></td></tr></table></figure>\n"},{"title":"git部分技巧","description":"git部分技巧","date":"2017-10-20T22:49:50.000Z","comments":0,"_content":"* [Git中文手册](http://git-scm.com/book/zh)、\n* [git Refspec](http://git-scm.com/book/zh/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec)、\n* [Git Commit-ish/Tree-ish ](http://stackoverflow.com/questions/4044368/what-does-tree-ish-mean-in-git/18605496#18605496)\n* git工作量统计： [查看](http://btpka3.github.io/js/node/git-stat/stat/)， [源码](https://github.com/btpka3/btpka3.github.com/blob/master/js/node/git-stat/)\n\n# 记住密码\n使用ssh协议，可以使用ssh key来免密码登录。但是如果使用 http/https 协议来clone，则可以参考 [这里](https://help.github.com/articles/caching-your-github-password-in-git/)\n\n```\n# Mac\ngit credential-osxkeychain\nbrew install git\nbrew install git-lfs\nbrew install gitk\n\ngit config --global credential.helper osxkeychain\n\ngit credential-osxkeychain erase\n\n# Windows\ngit config --global credential.helper wincred\n\n# Linux\ngit config --global credential.helper 'cache --timeout=3600'   # 保存在内存中\n# 保存在磁盘上, 默认查找 ~/.git-credentials  $XDG_CONFIG_HOME/git/credentials\ngit config credential.helper 'store --file=<path>'\n```\n\n\n# git lfs\n[git-lfs](brew install git-lfs) \n\n```bash\nbrew install git-lfs\n\ngit lfs install\ncd xxx.git\ngit lfs track \"*.psd\"\ngit add .gitattributes\ngit add *.psd\ngit commit -m \"log msg\"\ngit push\n\n```\n\n# git archive\n\n\n```bash\ngit archive --format=tar --remote=https://github.com/vozlt/nginx-module-vts.git HEAD | tar xf -\n```\n\n# 配置\n\n```bash\n# 用户级的配置文件路径\n~/.gitconfig\n# 配置用户身份\ngit config --global user.name \"zhangll\"\ngit config --global user.email zhangll@lizi.com\ngit config --global core.editor vim\ngit config --global merge.tool vimdiff\ngit config --global push.default simple           # 在 \"git push\" 时，会推到当前分支跟踪的远程分支（可能名称不同）\ngit config --global core.filemode false           # 忽略文件仅文件权限的变更（比如 old mode 100755  new mode 100644）\ngit config --global color.ui auto                 # git命令下会使用红色、绿色等来突出显示。\ngit config --global branch.autosetuprebase always # 在 \"git pull\" 时，总会自动rebase\ngit config --global credential.helper cache       # 在 clone `https` 类型的URL时，可减少用户名密码输入次数\ngit config --global core.quotepath false          # 在提交中文名称的文件时，不转义为 \\350\\256\\256\\346\\200\\273\\347\\273\\223.xlsx\ngit config --global core.ignorecase false         # 文件名区分大小写 \ngit config --list\n\n\ngit config --global http.proxy 'socks5://127.0.0.1:9999'\n```\n\n```bash\ngit add path/file              # 添加新文件\ngit reset HEAD path/file       # 取消添加\ngit commit  -m \"commit msg\"    # 提交修改\ngit push                       # 推送到远程\n```\n\n# 代理\n\n[参考](https://cms-sw.github.io/tutorial-proxy.html)\n\n## git 协议\n需要配置 ssh 的相关代理配置\n\n```bash\n# ~/.ssh/config  @ internal \nHost github.com\n    User                    git\n    ProxyCommand            ssh user@gateway.host /usr/bin/nc %h %p\n    IdentityFile             ~/.ssh/id_rsa.gitlab\n```\n\n## 镜像\n\n```bash\ngit clone --mirror git@gitlab.com:kingsilk/qh-env.wiki.git\ncd qh-env.wiki.git\ngit remote update\n```\n\n## http, https 协议\n\n```bash\n# @gateway  开启 socks5 代理\n/usr/bin/ssh proxy@gateway.kingsilk.net \\\n    -C -N -g -D gateway.kingsilk.net:9999 \\\n    -o ExitOnForwardFailure=yes \\\n    -o ServerAliveInterval=60\n\n# @internal 配置 git 使用代理\ngit config --global http.proxy socks5://gateway.kingsilk.net:9999\n#git config core.gitproxy  socks5://prod11.kingsilk.net:9999\n```\n## git 协议\n\n参考: [1](https://www.emilsit.net/blog/archives/how-to-use-the-git-protocol-through-a-http-connect-proxy/)、\n[2](https://gist.github.com/sit/49288)、\n[git-proxy@cms-sw/cms-git-tools](https://github.com/cms-sw/cms-git-tools/blob/master/git-proxy)\n\n\n\n```bash\n# @gateway  开启 socks5 代理\n/usr/bin/ssh proxy@gateway.kingsilk.net \\\n    -C -N -g -D gateway.kingsilk.net:9999 \\\n    -o ExitOnForwardFailure=yes \\\n    -o ServerAliveInterval=60\n\n\nvi /data0/git-proxy\n#!/bin/bash\nnc -x gateway.kingsilk.net:9999 $1 $2\n\nchmod +x /data0/git-proxy\n\ngit config --global core.gitproxy \"/data0/git-proxy\"\ngit config --global socks.proxy \"localhost:1080\"\n```\n\n\n\n# 创建仓库\n\n参考：http://gitref.org/\n\n```bash\n# 远程服务器创建\nmkdir lizi-tmp\ncd lizi-tmp\ngit --bare init\n\n# 本地创建\nmkdir zll\ncd zll\ngit init\necho hello > README\ngit add README\ngit commit -m \"first commit\"\n\n# 将本地设置为跟踪远程服务器\ngit remote add origin git@newcrm.nalashop.com:~/web/lizi-tmp\ngit push --set-upstream origin master\n\n# 删除\ngit rm README\ngit mv file_from file_to\ngit log\n\n# 在提交前，将已标记为要提交的文件移除。\ngit reset HEAD xxxFile\n\n# 取消修改\ngit checkout -- benchmarks.rb\n\n# 修改最后一次提交\ngit commit --amend\n\n# 查看当前工作区的状态\ngit status\n# .gitignore 中可以忽略特定的文件\ngit diff\n\n# 查看远程仓库的URL\ngit config --get remote.origin.url\n```\n\n\n# 远程\n\n```bash\n# 如果使用ssh key，就不要使用https协议\ngit remote add origin git@10.1.18.153:zhangliangliang/test.git\ngit remote set-url origin git@new-host:new-url\ngit remote show\ngit remote rm origin\ngit push -u origin master:master  # 第一个master是本地分支，第二个master是远程分支\n\n# 重命名\ngit remote rename origin xx\n\n# 从远程仓库上获取最新内容（不合并本地已经修改的内容）\n# 注意：分支号前面的加号可选\n# 如果 :local-branch-name 省略，则默认与remote-branch-name 相同\ngit fetch remote-name  +remote-branch-name:local-branchName\n\n# 从远程仓库上获取最新内容（合并本地已经修改的内容）\ngit pull --rebase\n\n# 提交到远程服务器\ngit push remote-name [branch-name]\n\n## FIXME fetch, pull 是保存到工作空间？还是状态空间？\n\n```\n\n# Tag\n\n```bash\n# 显示本地所有tag\ngit tag\n# 显示指定前缀的tag\ngit tag -l \"v1.1*\"\n# 显示具体某个tag的详情\ngit show tag-name\n# 显示远程所有的分支和标签\ngit ls-remote\n\n# 新建轻量级tag（不要使用 -a -s -m 选项）\ngit tag v1.4-lw\n# 新建tag(默认是对当前状态进行tag)\ngit tag -a new-tag-name -m some-message [commit-hash]\n# 新建签名的tag(不要使用 -a 选项）\ngit tag -s tag-name -m some-message\n# 验证签名tag：会使用GPG进行验证，需要预先下载签名者的公钥\ngit tag -v tag-name\n\n# 提交指定的tag到远程\ngit push remote-name tag-name\n# 提交所有的tag到远程\ngit push remote-name --tags\n\n# 删除本地tag\ngit tag -d tag-name\n# 删除远程tag\ngit push origin :refs/tags/tag-name\n\n# 检出tag\ngit checkout tags/tag-name\n```\n\n# Branch\n\n```bash\n# 新建分支\ngit branch branch-name\n# 检出远程分支\ngit checkout -b local-branch-name origin/remote-branch-name\n# 切换本地分支\ngit checkout branch-name\n\n# 新建并切换到该新分支(等价于上述两个命令)\ngit checkout -b new-branch-name\n\n# 查看本地所有分支，以及工作空间所用的分支（前缀有*号）\ngit branch\n# 查看远程分支\ngit branch -r\n# 查看所有分支（本地和远程）\ngit branch -av\ngit show-branch\n# 查看当前分支是track远程的哪个分支\ngit remote show origin\n\n# 查看分支最后一个提交对象\ngit branch -v\n（分别叫做 stashing 和 commit amending）\n\n# 如果有有合并冲突的文件，需要手动合并后，再使用以下命令就OK了\ngit add merged-by-hand-file\ngit commit\n\n# 将本地分支推送到远程其他分支\ngit push <REMOTENAME> <LOCALBRANCHNAME>:<REMOTEBRANCHNAME> \ngit push origin master:1.0.x\n\n# 删除分支(本地)\ngit branch -d branch-name\n# 删除分支(远程)\ngit push origin --delete <branch_name>\n\n###  合并分支\n#          A---B---C 2.0.x\n#         /\n#    D---E---F---G master\n\ngit checkout 2.0.x\ngit rebase master\n#git rebase master 2.0.x\n\n#                  A'--B'--C' 2.0.x\n#                 /\n#    D---E---F---G master\n\ngit checkout master\ngit merge 2.0.x         # 这种情形是可以 fast-forwad 的\n```\n\n# 远程分支\n\n```bash\n# 新建远程分支\ngit push origin test:master         // 提交本地test分支作为远程的master分支\n\n# 合并远程分支\ngit checkout remoteBranch1                 # ??? git checkout origin/branch1\ngit push origin remoteBranch1:remoteBranch2\n\n\n# 删除远程分支\ngit push origin :remoteBranch2\n\n\n```\n\n\n\n# 取消本地所有修改\n\n```bash\n# 取消对文件的修改\ngit reset --hard HEAD\n\n# 删除本地未索引的文件\ngit clean -fdx\n\ngit status\n```\n\n# 删除最后几次commit\n```bash\n# 查看提交的log，并找到想要回滚到的commit的\ngit log\ngit reset --hard <sha1-commit-id>\n```\n\n# rebase\n假如有新修改提交到本地了。在push前进行pull的时候，\ngit自动合并并创建了一个新的commit，其注释为 \"Merge branch 'xxx' of git@xxxx/path/to/xxx.git into xxx\"。此时，大家应当立即运行\n\n```bash\ngitk  # 此时有比较复杂的路线图\ngit rebase\ngitk  # 此时就变成单线路了\n\n# rebase之后，会将本地的多个提交合并成一个提交，原来的多个提交的历史记录可以通过以下命令找到\ngit reflog\ngit cherry-pick 12944d8\n```\n\n\n\n# 单个文件\n## 查看日志\n\n```bash\ngit log path/to/file\n```\n\n## diff\n\n```bash\ngit diff <sha1-commit-id1> <sha1-commit-id2> path/to/file\n```\n\n\n## 检出特定版本\n\n```bash\ngit checkout <sha1-commit-id> path/to/file\n```\n## 无本地copy情况下，从远程仓库检出最新的指定文件\n\n```bash\ngit ls-remote git@git.test.me:/path/to/git/repo\ngit archive --remote=git@git.test.me:/path/to/git/repo refs/heads/test path/to/file  --format zip -o /tmp/a.zip\ncd /tmp/\nunzip /tmp/a.zip\ncp path/to/file /path/to/dest\n```\n\n## 无本地copy情况下，从远程仓库检出指定版本的指定文件\n\n```bash\n# 先通过SSH登录到远程仓库，看一下test分支上指定文件的最近3条日志，找到所需的commit SHA1.\nssh git@git.test.me \"cd /path/to/git/repo && git log -n 3 test -- path/to/file\"\ngit archive --remote=git@git.test.me:/path/to/git/repo d787416b0aec88747075ef0f5909bc4f863aa26e path/to/file  --format zip -o /tmp/a.zip\ncd /tmp/\nunzip /tmp/a.zip\ncp path/to/file /path/to/dest\n```\n\n\n# .gitignore\n\n```\n/target-eclipse/classes\n/web-app/WEB-INF/classes\n/target/\n/out/\n/test/\n/overlays/\n/db/\n.classpath\n.settings/\n.project\n.idea/\n.DS_Store\n*.iml\n*.ipr\n*.iws\n*.swp\n*.log\n```\n\n注意：如果要忽略特定的目录中的文件，但还想在远程仓库中保持该目录，则：\n\n```\nemptyDir/*\n!emptyDir/.gitkeep\n```\n\n\n\n\n# 撤销提交\n## 编辑最后一次本地提交\n也即，本地已经commit，但是没push到远程\n\n```bash\ngit reset --soft HEAD~1             # 先reset，会copy HEAD为.git/ORIG_HEAD\ndoSomeEdit\ngit add .\ngit commit -c ORIG_HEAD             # 使用原来的commit消息，并提交\n```\n\n\n## 本地已经commit，也已经push到远程，但其他开发人员尚未拉取\n```bash\ngit push -f                         # 本地修改之后，强制提交\n```\n\n## 本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\n\n```bash\ngit rever <commit-id>               # 该方法通过在最新commit之后新建一个commit来达到回滚的效果。\n```\n\n# 统计\n\n```\n# 一定时期内的代码提交次数\ngit log --after=2015-01-01 --before=2016-03-01 --pretty='%ae' | sort | uniq -c | sort -k1 -n -r\n\n\n# 统计代码修改量\ngit log --after=2015-01-01 --before=2016-03-01 --pretty='%an' | sort -u\ngit log --author=\"btpka3\" --pretty=tformat: --numstat \\\n    | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } \\\n    END { printf \"added lines: %s removed lines : %s total lines: %s\\n\",add,subs,loc }' -\n\n# gitstats\ngitstats -c project_name=qh-app \\\n    -c commit_begin=`git log --date-order --date=iso --before=2015-01-01 -n 1 --pretty='%H'` \\\n    -c commit_end=`git log --date-order --date=iso --before=2016-03-01  -n 1 --pretty='%H'`  \\\n    qh-app \\\n    stat/qh-app\n```\n\n\n# sync\n\n\n## repo\n\n```\ngit clone http://git.oschina.net/btpka3/btpka3.wiki.git\ncd btpka3.wiki\ngit remote add gitlab git@git.kingsilk.xyz:btpka3/btpka3.wiki.git\ngit config --list\n```\n## crontab\n```\n0 */1  *   *   *   /home/zll/work/git-repo/oschina/sync-wiki.sh 2>&1 >>  /home/zll/work/git-repo/oschina/sync-wiki.log\n```\n\n## sync-wiki.sh\n\n```\n#!/bin/bash\nTIME=\"date +%Y-%m-%d.%H:%M:%S\"\n\ncd /home/zll/work/git-repo/oschina/btpka3.wiki\necho `$TIME` pull from gitlab\ngit pull --rebase gitlab master\n[ $? = 0 ] || exit -1\n\necho `$TIME` pull from oschina\ngit pull --rebase origin master\n[ $? = 0 ] || exit -1\n\necho `$TIME` push to oschina\ngit push origin master:master\n[ $? = 0 ] || exit -1\n\necho `$TIME` push to oschina\ngit push -f gitlab master:master\n[ $? = 0 ] || exit -1\n\necho `$TIME` Done.\n```\n\n\n## pull request, merge request\n\n```bash\n# 1. 开发人员fork一个要修改的分支(比如 \"master\")，修改、测试、并推送到远程（比如：远程分支 \"zll-123\")\n# 2. 要合并的人员进行以下操作：\n\n# 2.0 先获取最新\ngit pull --all\n\n# 2.1 先获取最新，并检出经过修改的分支\ngit fetch origin\ngit checkout -b zll-123 origin/zll-123\n\n# 2.2 再检出要合并到的目标分支，\ngit checkout master\ngit merge --no-ff zll-123\n\n# 2.3 进行代码审查和测试\n\n# 2.4 推送的远程\ngit push origin master\n```\n\n\n## change remote\n\n```bash\nAPP=xhs\n\ncd ${APP}\ngit status .\ngit branch -av\ngit remote -v\ngit remote rm origin\ngit remote add origin git@gitlab.com:kingsilk/${APP}.git\ngit fetch\ngit branch --set-upstream-to=origin/master master\ngit remote -v\ngit pull\ncd ..\n```\n\n\n## transfer\n\n```bash\ncd /tmp\ngit clone root@192.168.0.12:/home/git/repositories/kingsilk/env.wiki.git\ncd env.wiki\ngit remote show\ngit remote rm origin\ngit remote add origin git@gitlab.com:kingsilk/qh-env.wiki.git\ngit push -u origin --all\ngit push -u origin --tags\ncd ..\n```\n\n","source":"_posts/service/git/git.md","raw":"---\ntitle : git部分技巧\ndescription: git部分技巧\ndate: 2017-10-21 06:49:50\ncomments: false\n---\n* [Git中文手册](http://git-scm.com/book/zh)、\n* [git Refspec](http://git-scm.com/book/zh/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec)、\n* [Git Commit-ish/Tree-ish ](http://stackoverflow.com/questions/4044368/what-does-tree-ish-mean-in-git/18605496#18605496)\n* git工作量统计： [查看](http://btpka3.github.io/js/node/git-stat/stat/)， [源码](https://github.com/btpka3/btpka3.github.com/blob/master/js/node/git-stat/)\n\n# 记住密码\n使用ssh协议，可以使用ssh key来免密码登录。但是如果使用 http/https 协议来clone，则可以参考 [这里](https://help.github.com/articles/caching-your-github-password-in-git/)\n\n```\n# Mac\ngit credential-osxkeychain\nbrew install git\nbrew install git-lfs\nbrew install gitk\n\ngit config --global credential.helper osxkeychain\n\ngit credential-osxkeychain erase\n\n# Windows\ngit config --global credential.helper wincred\n\n# Linux\ngit config --global credential.helper 'cache --timeout=3600'   # 保存在内存中\n# 保存在磁盘上, 默认查找 ~/.git-credentials  $XDG_CONFIG_HOME/git/credentials\ngit config credential.helper 'store --file=<path>'\n```\n\n\n# git lfs\n[git-lfs](brew install git-lfs) \n\n```bash\nbrew install git-lfs\n\ngit lfs install\ncd xxx.git\ngit lfs track \"*.psd\"\ngit add .gitattributes\ngit add *.psd\ngit commit -m \"log msg\"\ngit push\n\n```\n\n# git archive\n\n\n```bash\ngit archive --format=tar --remote=https://github.com/vozlt/nginx-module-vts.git HEAD | tar xf -\n```\n\n# 配置\n\n```bash\n# 用户级的配置文件路径\n~/.gitconfig\n# 配置用户身份\ngit config --global user.name \"zhangll\"\ngit config --global user.email zhangll@lizi.com\ngit config --global core.editor vim\ngit config --global merge.tool vimdiff\ngit config --global push.default simple           # 在 \"git push\" 时，会推到当前分支跟踪的远程分支（可能名称不同）\ngit config --global core.filemode false           # 忽略文件仅文件权限的变更（比如 old mode 100755  new mode 100644）\ngit config --global color.ui auto                 # git命令下会使用红色、绿色等来突出显示。\ngit config --global branch.autosetuprebase always # 在 \"git pull\" 时，总会自动rebase\ngit config --global credential.helper cache       # 在 clone `https` 类型的URL时，可减少用户名密码输入次数\ngit config --global core.quotepath false          # 在提交中文名称的文件时，不转义为 \\350\\256\\256\\346\\200\\273\\347\\273\\223.xlsx\ngit config --global core.ignorecase false         # 文件名区分大小写 \ngit config --list\n\n\ngit config --global http.proxy 'socks5://127.0.0.1:9999'\n```\n\n```bash\ngit add path/file              # 添加新文件\ngit reset HEAD path/file       # 取消添加\ngit commit  -m \"commit msg\"    # 提交修改\ngit push                       # 推送到远程\n```\n\n# 代理\n\n[参考](https://cms-sw.github.io/tutorial-proxy.html)\n\n## git 协议\n需要配置 ssh 的相关代理配置\n\n```bash\n# ~/.ssh/config  @ internal \nHost github.com\n    User                    git\n    ProxyCommand            ssh user@gateway.host /usr/bin/nc %h %p\n    IdentityFile             ~/.ssh/id_rsa.gitlab\n```\n\n## 镜像\n\n```bash\ngit clone --mirror git@gitlab.com:kingsilk/qh-env.wiki.git\ncd qh-env.wiki.git\ngit remote update\n```\n\n## http, https 协议\n\n```bash\n# @gateway  开启 socks5 代理\n/usr/bin/ssh proxy@gateway.kingsilk.net \\\n    -C -N -g -D gateway.kingsilk.net:9999 \\\n    -o ExitOnForwardFailure=yes \\\n    -o ServerAliveInterval=60\n\n# @internal 配置 git 使用代理\ngit config --global http.proxy socks5://gateway.kingsilk.net:9999\n#git config core.gitproxy  socks5://prod11.kingsilk.net:9999\n```\n## git 协议\n\n参考: [1](https://www.emilsit.net/blog/archives/how-to-use-the-git-protocol-through-a-http-connect-proxy/)、\n[2](https://gist.github.com/sit/49288)、\n[git-proxy@cms-sw/cms-git-tools](https://github.com/cms-sw/cms-git-tools/blob/master/git-proxy)\n\n\n\n```bash\n# @gateway  开启 socks5 代理\n/usr/bin/ssh proxy@gateway.kingsilk.net \\\n    -C -N -g -D gateway.kingsilk.net:9999 \\\n    -o ExitOnForwardFailure=yes \\\n    -o ServerAliveInterval=60\n\n\nvi /data0/git-proxy\n#!/bin/bash\nnc -x gateway.kingsilk.net:9999 $1 $2\n\nchmod +x /data0/git-proxy\n\ngit config --global core.gitproxy \"/data0/git-proxy\"\ngit config --global socks.proxy \"localhost:1080\"\n```\n\n\n\n# 创建仓库\n\n参考：http://gitref.org/\n\n```bash\n# 远程服务器创建\nmkdir lizi-tmp\ncd lizi-tmp\ngit --bare init\n\n# 本地创建\nmkdir zll\ncd zll\ngit init\necho hello > README\ngit add README\ngit commit -m \"first commit\"\n\n# 将本地设置为跟踪远程服务器\ngit remote add origin git@newcrm.nalashop.com:~/web/lizi-tmp\ngit push --set-upstream origin master\n\n# 删除\ngit rm README\ngit mv file_from file_to\ngit log\n\n# 在提交前，将已标记为要提交的文件移除。\ngit reset HEAD xxxFile\n\n# 取消修改\ngit checkout -- benchmarks.rb\n\n# 修改最后一次提交\ngit commit --amend\n\n# 查看当前工作区的状态\ngit status\n# .gitignore 中可以忽略特定的文件\ngit diff\n\n# 查看远程仓库的URL\ngit config --get remote.origin.url\n```\n\n\n# 远程\n\n```bash\n# 如果使用ssh key，就不要使用https协议\ngit remote add origin git@10.1.18.153:zhangliangliang/test.git\ngit remote set-url origin git@new-host:new-url\ngit remote show\ngit remote rm origin\ngit push -u origin master:master  # 第一个master是本地分支，第二个master是远程分支\n\n# 重命名\ngit remote rename origin xx\n\n# 从远程仓库上获取最新内容（不合并本地已经修改的内容）\n# 注意：分支号前面的加号可选\n# 如果 :local-branch-name 省略，则默认与remote-branch-name 相同\ngit fetch remote-name  +remote-branch-name:local-branchName\n\n# 从远程仓库上获取最新内容（合并本地已经修改的内容）\ngit pull --rebase\n\n# 提交到远程服务器\ngit push remote-name [branch-name]\n\n## FIXME fetch, pull 是保存到工作空间？还是状态空间？\n\n```\n\n# Tag\n\n```bash\n# 显示本地所有tag\ngit tag\n# 显示指定前缀的tag\ngit tag -l \"v1.1*\"\n# 显示具体某个tag的详情\ngit show tag-name\n# 显示远程所有的分支和标签\ngit ls-remote\n\n# 新建轻量级tag（不要使用 -a -s -m 选项）\ngit tag v1.4-lw\n# 新建tag(默认是对当前状态进行tag)\ngit tag -a new-tag-name -m some-message [commit-hash]\n# 新建签名的tag(不要使用 -a 选项）\ngit tag -s tag-name -m some-message\n# 验证签名tag：会使用GPG进行验证，需要预先下载签名者的公钥\ngit tag -v tag-name\n\n# 提交指定的tag到远程\ngit push remote-name tag-name\n# 提交所有的tag到远程\ngit push remote-name --tags\n\n# 删除本地tag\ngit tag -d tag-name\n# 删除远程tag\ngit push origin :refs/tags/tag-name\n\n# 检出tag\ngit checkout tags/tag-name\n```\n\n# Branch\n\n```bash\n# 新建分支\ngit branch branch-name\n# 检出远程分支\ngit checkout -b local-branch-name origin/remote-branch-name\n# 切换本地分支\ngit checkout branch-name\n\n# 新建并切换到该新分支(等价于上述两个命令)\ngit checkout -b new-branch-name\n\n# 查看本地所有分支，以及工作空间所用的分支（前缀有*号）\ngit branch\n# 查看远程分支\ngit branch -r\n# 查看所有分支（本地和远程）\ngit branch -av\ngit show-branch\n# 查看当前分支是track远程的哪个分支\ngit remote show origin\n\n# 查看分支最后一个提交对象\ngit branch -v\n（分别叫做 stashing 和 commit amending）\n\n# 如果有有合并冲突的文件，需要手动合并后，再使用以下命令就OK了\ngit add merged-by-hand-file\ngit commit\n\n# 将本地分支推送到远程其他分支\ngit push <REMOTENAME> <LOCALBRANCHNAME>:<REMOTEBRANCHNAME> \ngit push origin master:1.0.x\n\n# 删除分支(本地)\ngit branch -d branch-name\n# 删除分支(远程)\ngit push origin --delete <branch_name>\n\n###  合并分支\n#          A---B---C 2.0.x\n#         /\n#    D---E---F---G master\n\ngit checkout 2.0.x\ngit rebase master\n#git rebase master 2.0.x\n\n#                  A'--B'--C' 2.0.x\n#                 /\n#    D---E---F---G master\n\ngit checkout master\ngit merge 2.0.x         # 这种情形是可以 fast-forwad 的\n```\n\n# 远程分支\n\n```bash\n# 新建远程分支\ngit push origin test:master         // 提交本地test分支作为远程的master分支\n\n# 合并远程分支\ngit checkout remoteBranch1                 # ??? git checkout origin/branch1\ngit push origin remoteBranch1:remoteBranch2\n\n\n# 删除远程分支\ngit push origin :remoteBranch2\n\n\n```\n\n\n\n# 取消本地所有修改\n\n```bash\n# 取消对文件的修改\ngit reset --hard HEAD\n\n# 删除本地未索引的文件\ngit clean -fdx\n\ngit status\n```\n\n# 删除最后几次commit\n```bash\n# 查看提交的log，并找到想要回滚到的commit的\ngit log\ngit reset --hard <sha1-commit-id>\n```\n\n# rebase\n假如有新修改提交到本地了。在push前进行pull的时候，\ngit自动合并并创建了一个新的commit，其注释为 \"Merge branch 'xxx' of git@xxxx/path/to/xxx.git into xxx\"。此时，大家应当立即运行\n\n```bash\ngitk  # 此时有比较复杂的路线图\ngit rebase\ngitk  # 此时就变成单线路了\n\n# rebase之后，会将本地的多个提交合并成一个提交，原来的多个提交的历史记录可以通过以下命令找到\ngit reflog\ngit cherry-pick 12944d8\n```\n\n\n\n# 单个文件\n## 查看日志\n\n```bash\ngit log path/to/file\n```\n\n## diff\n\n```bash\ngit diff <sha1-commit-id1> <sha1-commit-id2> path/to/file\n```\n\n\n## 检出特定版本\n\n```bash\ngit checkout <sha1-commit-id> path/to/file\n```\n## 无本地copy情况下，从远程仓库检出最新的指定文件\n\n```bash\ngit ls-remote git@git.test.me:/path/to/git/repo\ngit archive --remote=git@git.test.me:/path/to/git/repo refs/heads/test path/to/file  --format zip -o /tmp/a.zip\ncd /tmp/\nunzip /tmp/a.zip\ncp path/to/file /path/to/dest\n```\n\n## 无本地copy情况下，从远程仓库检出指定版本的指定文件\n\n```bash\n# 先通过SSH登录到远程仓库，看一下test分支上指定文件的最近3条日志，找到所需的commit SHA1.\nssh git@git.test.me \"cd /path/to/git/repo && git log -n 3 test -- path/to/file\"\ngit archive --remote=git@git.test.me:/path/to/git/repo d787416b0aec88747075ef0f5909bc4f863aa26e path/to/file  --format zip -o /tmp/a.zip\ncd /tmp/\nunzip /tmp/a.zip\ncp path/to/file /path/to/dest\n```\n\n\n# .gitignore\n\n```\n/target-eclipse/classes\n/web-app/WEB-INF/classes\n/target/\n/out/\n/test/\n/overlays/\n/db/\n.classpath\n.settings/\n.project\n.idea/\n.DS_Store\n*.iml\n*.ipr\n*.iws\n*.swp\n*.log\n```\n\n注意：如果要忽略特定的目录中的文件，但还想在远程仓库中保持该目录，则：\n\n```\nemptyDir/*\n!emptyDir/.gitkeep\n```\n\n\n\n\n# 撤销提交\n## 编辑最后一次本地提交\n也即，本地已经commit，但是没push到远程\n\n```bash\ngit reset --soft HEAD~1             # 先reset，会copy HEAD为.git/ORIG_HEAD\ndoSomeEdit\ngit add .\ngit commit -c ORIG_HEAD             # 使用原来的commit消息，并提交\n```\n\n\n## 本地已经commit，也已经push到远程，但其他开发人员尚未拉取\n```bash\ngit push -f                         # 本地修改之后，强制提交\n```\n\n## 本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\n\n```bash\ngit rever <commit-id>               # 该方法通过在最新commit之后新建一个commit来达到回滚的效果。\n```\n\n# 统计\n\n```\n# 一定时期内的代码提交次数\ngit log --after=2015-01-01 --before=2016-03-01 --pretty='%ae' | sort | uniq -c | sort -k1 -n -r\n\n\n# 统计代码修改量\ngit log --after=2015-01-01 --before=2016-03-01 --pretty='%an' | sort -u\ngit log --author=\"btpka3\" --pretty=tformat: --numstat \\\n    | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } \\\n    END { printf \"added lines: %s removed lines : %s total lines: %s\\n\",add,subs,loc }' -\n\n# gitstats\ngitstats -c project_name=qh-app \\\n    -c commit_begin=`git log --date-order --date=iso --before=2015-01-01 -n 1 --pretty='%H'` \\\n    -c commit_end=`git log --date-order --date=iso --before=2016-03-01  -n 1 --pretty='%H'`  \\\n    qh-app \\\n    stat/qh-app\n```\n\n\n# sync\n\n\n## repo\n\n```\ngit clone http://git.oschina.net/btpka3/btpka3.wiki.git\ncd btpka3.wiki\ngit remote add gitlab git@git.kingsilk.xyz:btpka3/btpka3.wiki.git\ngit config --list\n```\n## crontab\n```\n0 */1  *   *   *   /home/zll/work/git-repo/oschina/sync-wiki.sh 2>&1 >>  /home/zll/work/git-repo/oschina/sync-wiki.log\n```\n\n## sync-wiki.sh\n\n```\n#!/bin/bash\nTIME=\"date +%Y-%m-%d.%H:%M:%S\"\n\ncd /home/zll/work/git-repo/oschina/btpka3.wiki\necho `$TIME` pull from gitlab\ngit pull --rebase gitlab master\n[ $? = 0 ] || exit -1\n\necho `$TIME` pull from oschina\ngit pull --rebase origin master\n[ $? = 0 ] || exit -1\n\necho `$TIME` push to oschina\ngit push origin master:master\n[ $? = 0 ] || exit -1\n\necho `$TIME` push to oschina\ngit push -f gitlab master:master\n[ $? = 0 ] || exit -1\n\necho `$TIME` Done.\n```\n\n\n## pull request, merge request\n\n```bash\n# 1. 开发人员fork一个要修改的分支(比如 \"master\")，修改、测试、并推送到远程（比如：远程分支 \"zll-123\")\n# 2. 要合并的人员进行以下操作：\n\n# 2.0 先获取最新\ngit pull --all\n\n# 2.1 先获取最新，并检出经过修改的分支\ngit fetch origin\ngit checkout -b zll-123 origin/zll-123\n\n# 2.2 再检出要合并到的目标分支，\ngit checkout master\ngit merge --no-ff zll-123\n\n# 2.3 进行代码审查和测试\n\n# 2.4 推送的远程\ngit push origin master\n```\n\n\n## change remote\n\n```bash\nAPP=xhs\n\ncd ${APP}\ngit status .\ngit branch -av\ngit remote -v\ngit remote rm origin\ngit remote add origin git@gitlab.com:kingsilk/${APP}.git\ngit fetch\ngit branch --set-upstream-to=origin/master master\ngit remote -v\ngit pull\ncd ..\n```\n\n\n## transfer\n\n```bash\ncd /tmp\ngit clone root@192.168.0.12:/home/git/repositories/kingsilk/env.wiki.git\ncd env.wiki\ngit remote show\ngit remote rm origin\ngit remote add origin git@gitlab.com:kingsilk/qh-env.wiki.git\ngit push -u origin --all\ngit push -u origin --tags\ncd ..\n```\n\n","slug":"service/git/git","published":1,"updated":"2017-12-15T08:12:58.874Z","layout":"post","photos":[],"link":"","_id":"cjclsgbqx00246dof1lan36e0","content":"<ul>\n<li><a href=\"http://git-scm.com/book/zh\" target=\"_blank\" rel=\"noopener\">Git中文手册</a>、</li>\n<li><a href=\"http://git-scm.com/book/zh/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec\" target=\"_blank\" rel=\"noopener\">git Refspec</a>、</li>\n<li><a href=\"http://stackoverflow.com/questions/4044368/what-does-tree-ish-mean-in-git/18605496#18605496\" target=\"_blank\" rel=\"noopener\">Git Commit-ish/Tree-ish </a></li>\n<li>git工作量统计： <a href=\"http://btpka3.github.io/js/node/git-stat/stat/\" target=\"_blank\" rel=\"noopener\">查看</a>， <a href=\"https://github.com/btpka3/btpka3.github.com/blob/master/js/node/git-stat/\" target=\"_blank\" rel=\"noopener\">源码</a></li>\n</ul>\n<h1 id=\"记住密码\"><a href=\"#记住密码\" class=\"headerlink\" title=\"记住密码\"></a>记住密码</h1><p>使用ssh协议，可以使用ssh key来免密码登录。但是如果使用 http/https 协议来clone，则可以参考 <a href=\"https://help.github.com/articles/caching-your-github-password-in-git/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Mac</span><br><span class=\"line\">git credential-osxkeychain</span><br><span class=\"line\">brew install git</span><br><span class=\"line\">brew install git-lfs</span><br><span class=\"line\">brew install gitk</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global credential.helper osxkeychain</span><br><span class=\"line\"></span><br><span class=\"line\">git credential-osxkeychain erase</span><br><span class=\"line\"></span><br><span class=\"line\"># Windows</span><br><span class=\"line\">git config --global credential.helper wincred</span><br><span class=\"line\"></span><br><span class=\"line\"># Linux</span><br><span class=\"line\">git config --global credential.helper &apos;cache --timeout=3600&apos;   # 保存在内存中</span><br><span class=\"line\"># 保存在磁盘上, 默认查找 ~/.git-credentials  $XDG_CONFIG_HOME/git/credentials</span><br><span class=\"line\">git config credential.helper &apos;store --file=&lt;path&gt;&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"git-lfs\"><a href=\"#git-lfs\" class=\"headerlink\" title=\"git lfs\"></a>git lfs</h1><p><a href=\"brew install git-lfs\">git-lfs</a> </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install git-lfs</span><br><span class=\"line\"></span><br><span class=\"line\">git lfs install</span><br><span class=\"line\"><span class=\"built_in\">cd</span> xxx.git</span><br><span class=\"line\">git lfs track <span class=\"string\">\"*.psd\"</span></span><br><span class=\"line\">git add .gitattributes</span><br><span class=\"line\">git add *.psd</span><br><span class=\"line\">git commit -m <span class=\"string\">\"log msg\"</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<h1 id=\"git-archive\"><a href=\"#git-archive\" class=\"headerlink\" title=\"git archive\"></a>git archive</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git archive --format=tar --remote=https://github.com/vozlt/nginx-module-vts.git HEAD | tar xf -</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用户级的配置文件路径</span></span><br><span class=\"line\">~/.gitconfig</span><br><span class=\"line\"><span class=\"comment\"># 配置用户身份</span></span><br><span class=\"line\">git config --global user.name <span class=\"string\">\"zhangll\"</span></span><br><span class=\"line\">git config --global user.email zhangll@lizi.com</span><br><span class=\"line\">git config --global core.editor vim</span><br><span class=\"line\">git config --global merge.tool vimdiff</span><br><span class=\"line\">git config --global push.default simple           <span class=\"comment\"># 在 \"git push\" 时，会推到当前分支跟踪的远程分支（可能名称不同）</span></span><br><span class=\"line\">git config --global core.filemode <span class=\"literal\">false</span>           <span class=\"comment\"># 忽略文件仅文件权限的变更（比如 old mode 100755  new mode 100644）</span></span><br><span class=\"line\">git config --global color.ui auto                 <span class=\"comment\"># git命令下会使用红色、绿色等来突出显示。</span></span><br><span class=\"line\">git config --global branch.autosetuprebase always <span class=\"comment\"># 在 \"git pull\" 时，总会自动rebase</span></span><br><span class=\"line\">git config --global credential.helper cache       <span class=\"comment\"># 在 clone `https` 类型的URL时，可减少用户名密码输入次数</span></span><br><span class=\"line\">git config --global core.quotepath <span class=\"literal\">false</span>          <span class=\"comment\"># 在提交中文名称的文件时，不转义为 \\350\\256\\256\\346\\200\\273\\347\\273\\223.xlsx</span></span><br><span class=\"line\">git config --global core.ignorecase <span class=\"literal\">false</span>         <span class=\"comment\"># 文件名区分大小写 </span></span><br><span class=\"line\">git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git config --global http.proxy <span class=\"string\">'socks5://127.0.0.1:9999'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add path/file              <span class=\"comment\"># 添加新文件</span></span><br><span class=\"line\">git reset HEAD path/file       <span class=\"comment\"># 取消添加</span></span><br><span class=\"line\">git commit  -m <span class=\"string\">\"commit msg\"</span>    <span class=\"comment\"># 提交修改</span></span><br><span class=\"line\">git push                       <span class=\"comment\"># 推送到远程</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p><a href=\"https://cms-sw.github.io/tutorial-proxy.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"git-协议\"><a href=\"#git-协议\" class=\"headerlink\" title=\"git 协议\"></a>git 协议</h2><p>需要配置 ssh 的相关代理配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ~/.ssh/config  @ internal </span></span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">    User                    git</span><br><span class=\"line\">    ProxyCommand            ssh user@gateway.host /usr/bin/nc %h %p</span><br><span class=\"line\">    IdentityFile             ~/.ssh/id_rsa.gitlab</span><br></pre></td></tr></table></figure>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> --mirror git@gitlab.com:kingsilk/qh-env.wiki.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> qh-env.wiki.git</span><br><span class=\"line\">git remote update</span><br></pre></td></tr></table></figure>\n<h2 id=\"http-https-协议\"><a href=\"#http-https-协议\" class=\"headerlink\" title=\"http, https 协议\"></a>http, https 协议</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># @gateway  开启 socks5 代理</span></span><br><span class=\"line\">/usr/bin/ssh proxy@gateway.kingsilk.net \\</span><br><span class=\"line\">    -C -N -g -D gateway.kingsilk.net:9999 \\</span><br><span class=\"line\">    -o ExitOnForwardFailure=yes \\</span><br><span class=\"line\">    -o ServerAliveInterval=60</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># @internal 配置 git 使用代理</span></span><br><span class=\"line\">git config --global http.proxy socks5://gateway.kingsilk.net:9999</span><br><span class=\"line\"><span class=\"comment\">#git config core.gitproxy  socks5://prod11.kingsilk.net:9999</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"git-协议-1\"><a href=\"#git-协议-1\" class=\"headerlink\" title=\"git 协议\"></a>git 协议</h2><p>参考: <a href=\"https://www.emilsit.net/blog/archives/how-to-use-the-git-protocol-through-a-http-connect-proxy/\" target=\"_blank\" rel=\"noopener\">1</a>、<br><a href=\"https://gist.github.com/sit/49288\" target=\"_blank\" rel=\"noopener\">2</a>、<br><a href=\"https://github.com/cms-sw/cms-git-tools/blob/master/git-proxy\" target=\"_blank\" rel=\"noopener\">git-proxy@cms-sw/cms-git-tools</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># @gateway  开启 socks5 代理</span></span><br><span class=\"line\">/usr/bin/ssh proxy@gateway.kingsilk.net \\</span><br><span class=\"line\">    -C -N -g -D gateway.kingsilk.net:9999 \\</span><br><span class=\"line\">    -o ExitOnForwardFailure=yes \\</span><br><span class=\"line\">    -o ServerAliveInterval=60</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vi /data0/git-proxy</span><br><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">nc -x gateway.kingsilk.net:9999 <span class=\"variable\">$1</span> <span class=\"variable\">$2</span></span><br><span class=\"line\"></span><br><span class=\"line\">chmod +x /data0/git-proxy</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global core.gitproxy <span class=\"string\">\"/data0/git-proxy\"</span></span><br><span class=\"line\">git config --global socks.proxy <span class=\"string\">\"localhost:1080\"</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a>创建仓库</h1><p>参考：<a href=\"http://gitref.org/\" target=\"_blank\" rel=\"noopener\">http://gitref.org/</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 远程服务器创建</span></span><br><span class=\"line\">mkdir lizi-tmp</span><br><span class=\"line\"><span class=\"built_in\">cd</span> lizi-tmp</span><br><span class=\"line\">git --bare init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本地创建</span></span><br><span class=\"line\">mkdir zll</span><br><span class=\"line\"><span class=\"built_in\">cd</span> zll</span><br><span class=\"line\">git init</span><br><span class=\"line\"><span class=\"built_in\">echo</span> hello &gt; README</span><br><span class=\"line\">git add README</span><br><span class=\"line\">git commit -m <span class=\"string\">\"first commit\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地设置为跟踪远程服务器</span></span><br><span class=\"line\">git remote add origin git@newcrm.nalashop.com:~/web/lizi-tmp</span><br><span class=\"line\">git push --<span class=\"built_in\">set</span>-upstream origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除</span></span><br><span class=\"line\">git rm README</span><br><span class=\"line\">git mv file_from file_to</span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在提交前，将已标记为要提交的文件移除。</span></span><br><span class=\"line\">git reset HEAD xxxFile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消修改</span></span><br><span class=\"line\">git checkout -- benchmarks.rb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改最后一次提交</span></span><br><span class=\"line\">git commit --amend</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前工作区的状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"><span class=\"comment\"># .gitignore 中可以忽略特定的文件</span></span><br><span class=\"line\">git diff</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看远程仓库的URL</span></span><br><span class=\"line\">git config --get remote.origin.url</span><br></pre></td></tr></table></figure>\n<h1 id=\"远程\"><a href=\"#远程\" class=\"headerlink\" title=\"远程\"></a>远程</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果使用ssh key，就不要使用https协议</span></span><br><span class=\"line\">git remote add origin git@10.1.18.153:zhangliangliang/test.git</span><br><span class=\"line\">git remote <span class=\"built_in\">set</span>-url origin git@new-host:new-url</span><br><span class=\"line\">git remote show</span><br><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git push -u origin master:master  <span class=\"comment\"># 第一个master是本地分支，第二个master是远程分支</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重命名</span></span><br><span class=\"line\">git remote rename origin xx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库上获取最新内容（不合并本地已经修改的内容）</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：分支号前面的加号可选</span></span><br><span class=\"line\"><span class=\"comment\"># 如果 :local-branch-name 省略，则默认与remote-branch-name 相同</span></span><br><span class=\"line\">git fetch remote-name  +remote-branch-name:<span class=\"built_in\">local</span>-branchName</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库上获取最新内容（合并本地已经修改的内容）</span></span><br><span class=\"line\">git pull --rebase</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交到远程服务器</span></span><br><span class=\"line\">git push remote-name [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## FIXME fetch, pull 是保存到工作空间？还是状态空间？</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Tag\"><a href=\"#Tag\" class=\"headerlink\" title=\"Tag\"></a>Tag</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示本地所有tag</span></span><br><span class=\"line\">git tag</span><br><span class=\"line\"><span class=\"comment\"># 显示指定前缀的tag</span></span><br><span class=\"line\">git tag -l <span class=\"string\">\"v1.1*\"</span></span><br><span class=\"line\"><span class=\"comment\"># 显示具体某个tag的详情</span></span><br><span class=\"line\">git show tag-name</span><br><span class=\"line\"><span class=\"comment\"># 显示远程所有的分支和标签</span></span><br><span class=\"line\">git ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建轻量级tag（不要使用 -a -s -m 选项）</span></span><br><span class=\"line\">git tag v1.4-lw</span><br><span class=\"line\"><span class=\"comment\"># 新建tag(默认是对当前状态进行tag)</span></span><br><span class=\"line\">git tag -a new-tag-name -m some-message [commit-hash]</span><br><span class=\"line\"><span class=\"comment\"># 新建签名的tag(不要使用 -a 选项）</span></span><br><span class=\"line\">git tag -s tag-name -m some-message</span><br><span class=\"line\"><span class=\"comment\"># 验证签名tag：会使用GPG进行验证，需要预先下载签名者的公钥</span></span><br><span class=\"line\">git tag -v tag-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交指定的tag到远程</span></span><br><span class=\"line\">git push remote-name tag-name</span><br><span class=\"line\"><span class=\"comment\"># 提交所有的tag到远程</span></span><br><span class=\"line\">git push remote-name --tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除本地tag</span></span><br><span class=\"line\">git tag -d tag-name</span><br><span class=\"line\"><span class=\"comment\"># 删除远程tag</span></span><br><span class=\"line\">git push origin :refs/tags/tag-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检出tag</span></span><br><span class=\"line\">git checkout tags/tag-name</span><br></pre></td></tr></table></figure>\n<h1 id=\"Branch\"><a href=\"#Branch\" class=\"headerlink\" title=\"Branch\"></a>Branch</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建分支</span></span><br><span class=\"line\">git branch branch-name</span><br><span class=\"line\"><span class=\"comment\"># 检出远程分支</span></span><br><span class=\"line\">git checkout -b <span class=\"built_in\">local</span>-branch-name origin/remote-branch-name</span><br><span class=\"line\"><span class=\"comment\"># 切换本地分支</span></span><br><span class=\"line\">git checkout branch-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建并切换到该新分支(等价于上述两个命令)</span></span><br><span class=\"line\">git checkout -b new-branch-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看本地所有分支，以及工作空间所用的分支（前缀有*号）</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"><span class=\"comment\"># 查看远程分支</span></span><br><span class=\"line\">git branch -r</span><br><span class=\"line\"><span class=\"comment\"># 查看所有分支（本地和远程）</span></span><br><span class=\"line\">git branch -av</span><br><span class=\"line\">git show-branch</span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支是track远程的哪个分支</span></span><br><span class=\"line\">git remote show origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看分支最后一个提交对象</span></span><br><span class=\"line\">git branch -v</span><br><span class=\"line\">（分别叫做 stashing 和 commit amending）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果有有合并冲突的文件，需要手动合并后，再使用以下命令就OK了</span></span><br><span class=\"line\">git add merged-by-hand-file</span><br><span class=\"line\">git commit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地分支推送到远程其他分支</span></span><br><span class=\"line\">git push &lt;REMOTENAME&gt; &lt;LOCALBRANCHNAME&gt;:&lt;REMOTEBRANCHNAME&gt; </span><br><span class=\"line\">git push origin master:1.0.x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支(本地)</span></span><br><span class=\"line\">git branch -d branch-name</span><br><span class=\"line\"><span class=\"comment\"># 删除分支(远程)</span></span><br><span class=\"line\">git push origin --delete &lt;branch_name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###  合并分支</span></span><br><span class=\"line\"><span class=\"comment\">#          A---B---C 2.0.x</span></span><br><span class=\"line\"><span class=\"comment\">#         /</span></span><br><span class=\"line\"><span class=\"comment\">#    D---E---F---G master</span></span><br><span class=\"line\"></span><br><span class=\"line\">git checkout 2.0.x</span><br><span class=\"line\">git rebase master</span><br><span class=\"line\"><span class=\"comment\">#git rebase master 2.0.x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                  A'--B'--C' 2.0.x</span></span><br><span class=\"line\"><span class=\"comment\">#                 /</span></span><br><span class=\"line\"><span class=\"comment\">#    D---E---F---G master</span></span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge 2.0.x         <span class=\"comment\"># 这种情形是可以 fast-forwad 的</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"远程分支\"><a href=\"#远程分支\" class=\"headerlink\" title=\"远程分支\"></a>远程分支</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建远程分支</span></span><br><span class=\"line\">git push origin <span class=\"built_in\">test</span>:master         // 提交本地<span class=\"built_in\">test</span>分支作为远程的master分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并远程分支</span></span><br><span class=\"line\">git checkout remoteBranch1                 <span class=\"comment\"># ??? git checkout origin/branch1</span></span><br><span class=\"line\">git push origin remoteBranch1:remoteBranch2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">git push origin :remoteBranch2</span><br></pre></td></tr></table></figure>\n<h1 id=\"取消本地所有修改\"><a href=\"#取消本地所有修改\" class=\"headerlink\" title=\"取消本地所有修改\"></a>取消本地所有修改</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 取消对文件的修改</span></span><br><span class=\"line\">git reset --hard HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除本地未索引的文件</span></span><br><span class=\"line\">git clean -fdx</span><br><span class=\"line\"></span><br><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<h1 id=\"删除最后几次commit\"><a href=\"#删除最后几次commit\" class=\"headerlink\" title=\"删除最后几次commit\"></a>删除最后几次commit</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看提交的log，并找到想要回滚到的commit的</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\">git reset --hard &lt;sha1-commit-id&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>假如有新修改提交到本地了。在push前进行pull的时候，<br>git自动合并并创建了一个新的commit，其注释为 “Merge branch ‘xxx’ of git@xxxx/path/to/xxx.git into xxx”。此时，大家应当立即运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitk  <span class=\"comment\"># 此时有比较复杂的路线图</span></span><br><span class=\"line\">git rebase</span><br><span class=\"line\">gitk  <span class=\"comment\"># 此时就变成单线路了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># rebase之后，会将本地的多个提交合并成一个提交，原来的多个提交的历史记录可以通过以下命令找到</span></span><br><span class=\"line\">git reflog</span><br><span class=\"line\">git cherry-pick 12944d8</span><br></pre></td></tr></table></figure>\n<h1 id=\"单个文件\"><a href=\"#单个文件\" class=\"headerlink\" title=\"单个文件\"></a>单个文件</h1><h2 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> path/to/file</span><br></pre></td></tr></table></figure>\n<h2 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff &lt;sha1-commit-id1&gt; &lt;sha1-commit-id2&gt; path/to/file</span><br></pre></td></tr></table></figure>\n<h2 id=\"检出特定版本\"><a href=\"#检出特定版本\" class=\"headerlink\" title=\"检出特定版本\"></a>检出特定版本</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;sha1-commit-id&gt; path/to/file</span><br></pre></td></tr></table></figure>\n<h2 id=\"无本地copy情况下，从远程仓库检出最新的指定文件\"><a href=\"#无本地copy情况下，从远程仓库检出最新的指定文件\" class=\"headerlink\" title=\"无本地copy情况下，从远程仓库检出最新的指定文件\"></a>无本地copy情况下，从远程仓库检出最新的指定文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-remote git@git.test.me:/path/to/git/repo</span><br><span class=\"line\">git archive --remote=git@git.test.me:/path/to/git/repo refs/heads/<span class=\"built_in\">test</span> path/to/file  --format zip -o /tmp/a.zip</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/</span><br><span class=\"line\">unzip /tmp/a.zip</span><br><span class=\"line\">cp path/to/file /path/to/dest</span><br></pre></td></tr></table></figure>\n<h2 id=\"无本地copy情况下，从远程仓库检出指定版本的指定文件\"><a href=\"#无本地copy情况下，从远程仓库检出指定版本的指定文件\" class=\"headerlink\" title=\"无本地copy情况下，从远程仓库检出指定版本的指定文件\"></a>无本地copy情况下，从远程仓库检出指定版本的指定文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先通过SSH登录到远程仓库，看一下test分支上指定文件的最近3条日志，找到所需的commit SHA1.</span></span><br><span class=\"line\">ssh git@git.test.me <span class=\"string\">\"cd /path/to/git/repo &amp;&amp; git log -n 3 test -- path/to/file\"</span></span><br><span class=\"line\">git archive --remote=git@git.test.me:/path/to/git/repo d787416b0aec88747075ef0f5909bc4f863aa26e path/to/file  --format zip -o /tmp/a.zip</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/</span><br><span class=\"line\">unzip /tmp/a.zip</span><br><span class=\"line\">cp path/to/file /path/to/dest</span><br></pre></td></tr></table></figure>\n<h1 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/target-eclipse/classes</span><br><span class=\"line\">/web-app/WEB-INF/classes</span><br><span class=\"line\">/target/</span><br><span class=\"line\">/out/</span><br><span class=\"line\">/test/</span><br><span class=\"line\">/overlays/</span><br><span class=\"line\">/db/</span><br><span class=\"line\">.classpath</span><br><span class=\"line\">.settings/</span><br><span class=\"line\">.project</span><br><span class=\"line\">.idea/</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">*.iml</span><br><span class=\"line\">*.ipr</span><br><span class=\"line\">*.iws</span><br><span class=\"line\">*.swp</span><br><span class=\"line\">*.log</span><br></pre></td></tr></table></figure>\n<p>注意：如果要忽略特定的目录中的文件，但还想在远程仓库中保持该目录，则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emptyDir/*</span><br><span class=\"line\">!emptyDir/.gitkeep</span><br></pre></td></tr></table></figure>\n<h1 id=\"撤销提交\"><a href=\"#撤销提交\" class=\"headerlink\" title=\"撤销提交\"></a>撤销提交</h1><h2 id=\"编辑最后一次本地提交\"><a href=\"#编辑最后一次本地提交\" class=\"headerlink\" title=\"编辑最后一次本地提交\"></a>编辑最后一次本地提交</h2><p>也即，本地已经commit，但是没push到远程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --soft HEAD~1             <span class=\"comment\"># 先reset，会copy HEAD为.git/ORIG_HEAD</span></span><br><span class=\"line\">doSomeEdit</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -c ORIG_HEAD             <span class=\"comment\"># 使用原来的commit消息，并提交</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"本地已经commit，也已经push到远程，但其他开发人员尚未拉取\"><a href=\"#本地已经commit，也已经push到远程，但其他开发人员尚未拉取\" class=\"headerlink\" title=\"本地已经commit，也已经push到远程，但其他开发人员尚未拉取\"></a>本地已经commit，也已经push到远程，但其他开发人员尚未拉取</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -f                         <span class=\"comment\"># 本地修改之后，强制提交</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\"><a href=\"#本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\" class=\"headerlink\" title=\"本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\"></a>本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rever &lt;commit-id&gt;               <span class=\"comment\"># 该方法通过在最新commit之后新建一个commit来达到回滚的效果。</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"统计\"><a href=\"#统计\" class=\"headerlink\" title=\"统计\"></a>统计</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一定时期内的代码提交次数</span><br><span class=\"line\">git log --after=2015-01-01 --before=2016-03-01 --pretty=&apos;%ae&apos; | sort | uniq -c | sort -k1 -n -r</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 统计代码修改量</span><br><span class=\"line\">git log --after=2015-01-01 --before=2016-03-01 --pretty=&apos;%an&apos; | sort -u</span><br><span class=\"line\">git log --author=&quot;btpka3&quot; --pretty=tformat: --numstat \\</span><br><span class=\"line\">    | gawk &apos;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; \\</span><br><span class=\"line\">    END &#123; printf &quot;added lines: %s removed lines : %s total lines: %s\\n&quot;,add,subs,loc &#125;&apos; -</span><br><span class=\"line\"></span><br><span class=\"line\"># gitstats</span><br><span class=\"line\">gitstats -c project_name=qh-app \\</span><br><span class=\"line\">    -c commit_begin=`git log --date-order --date=iso --before=2015-01-01 -n 1 --pretty=&apos;%H&apos;` \\</span><br><span class=\"line\">    -c commit_end=`git log --date-order --date=iso --before=2016-03-01  -n 1 --pretty=&apos;%H&apos;`  \\</span><br><span class=\"line\">    qh-app \\</span><br><span class=\"line\">    stat/qh-app</span><br></pre></td></tr></table></figure>\n<h1 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\"sync\"></a>sync</h1><h2 id=\"repo\"><a href=\"#repo\" class=\"headerlink\" title=\"repo\"></a>repo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone http://git.oschina.net/btpka3/btpka3.wiki.git</span><br><span class=\"line\">cd btpka3.wiki</span><br><span class=\"line\">git remote add gitlab git@git.kingsilk.xyz:btpka3/btpka3.wiki.git</span><br><span class=\"line\">git config --list</span><br></pre></td></tr></table></figure>\n<h2 id=\"crontab\"><a href=\"#crontab\" class=\"headerlink\" title=\"crontab\"></a>crontab</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 */1  *   *   *   /home/zll/work/git-repo/oschina/sync-wiki.sh 2&gt;&amp;1 &gt;&gt;  /home/zll/work/git-repo/oschina/sync-wiki.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"sync-wiki-sh\"><a href=\"#sync-wiki-sh\" class=\"headerlink\" title=\"sync-wiki.sh\"></a>sync-wiki.sh</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">TIME=&quot;date +%Y-%m-%d.%H:%M:%S&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">cd /home/zll/work/git-repo/oschina/btpka3.wiki</span><br><span class=\"line\">echo `$TIME` pull from gitlab</span><br><span class=\"line\">git pull --rebase gitlab master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` pull from oschina</span><br><span class=\"line\">git pull --rebase origin master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` push to oschina</span><br><span class=\"line\">git push origin master:master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` push to oschina</span><br><span class=\"line\">git push -f gitlab master:master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` Done.</span><br></pre></td></tr></table></figure>\n<h2 id=\"pull-request-merge-request\"><a href=\"#pull-request-merge-request\" class=\"headerlink\" title=\"pull request, merge request\"></a>pull request, merge request</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 开发人员fork一个要修改的分支(比如 \"master\")，修改、测试、并推送到远程（比如：远程分支 \"zll-123\")</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 要合并的人员进行以下操作：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.0 先获取最新</span></span><br><span class=\"line\">git pull --all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.1 先获取最新，并检出经过修改的分支</span></span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git checkout -b zll-123 origin/zll-123</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2 再检出要合并到的目标分支，</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff zll-123</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.3 进行代码审查和测试</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.4 推送的远程</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"change-remote\"><a href=\"#change-remote\" class=\"headerlink\" title=\"change remote\"></a>change remote</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APP=xhs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$&#123;APP&#125;</span></span><br><span class=\"line\">git status .</span><br><span class=\"line\">git branch -av</span><br><span class=\"line\">git remote -v</span><br><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin git@gitlab.com:kingsilk/<span class=\"variable\">$&#123;APP&#125;</span>.git</span><br><span class=\"line\">git fetch</span><br><span class=\"line\">git branch --<span class=\"built_in\">set</span>-upstream-to=origin/master master</span><br><span class=\"line\">git remote -v</span><br><span class=\"line\">git pull</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br></pre></td></tr></table></figure>\n<h2 id=\"transfer\"><a href=\"#transfer\" class=\"headerlink\" title=\"transfer\"></a>transfer</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /tmp</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> root@192.168.0.12:/home/git/repositories/kingsilk/env.wiki.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> env.wiki</span><br><span class=\"line\">git remote show</span><br><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin git@gitlab.com:kingsilk/qh-env.wiki.git</span><br><span class=\"line\">git push -u origin --all</span><br><span class=\"line\">git push -u origin --tags</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><a href=\"http://git-scm.com/book/zh\" target=\"_blank\" rel=\"noopener\">Git中文手册</a>、</li>\n<li><a href=\"http://git-scm.com/book/zh/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-The-Refspec\" target=\"_blank\" rel=\"noopener\">git Refspec</a>、</li>\n<li><a href=\"http://stackoverflow.com/questions/4044368/what-does-tree-ish-mean-in-git/18605496#18605496\" target=\"_blank\" rel=\"noopener\">Git Commit-ish/Tree-ish </a></li>\n<li>git工作量统计： <a href=\"http://btpka3.github.io/js/node/git-stat/stat/\" target=\"_blank\" rel=\"noopener\">查看</a>， <a href=\"https://github.com/btpka3/btpka3.github.com/blob/master/js/node/git-stat/\" target=\"_blank\" rel=\"noopener\">源码</a></li>\n</ul>\n<h1 id=\"记住密码\"><a href=\"#记住密码\" class=\"headerlink\" title=\"记住密码\"></a>记住密码</h1><p>使用ssh协议，可以使用ssh key来免密码登录。但是如果使用 http/https 协议来clone，则可以参考 <a href=\"https://help.github.com/articles/caching-your-github-password-in-git/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Mac</span><br><span class=\"line\">git credential-osxkeychain</span><br><span class=\"line\">brew install git</span><br><span class=\"line\">brew install git-lfs</span><br><span class=\"line\">brew install gitk</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global credential.helper osxkeychain</span><br><span class=\"line\"></span><br><span class=\"line\">git credential-osxkeychain erase</span><br><span class=\"line\"></span><br><span class=\"line\"># Windows</span><br><span class=\"line\">git config --global credential.helper wincred</span><br><span class=\"line\"></span><br><span class=\"line\"># Linux</span><br><span class=\"line\">git config --global credential.helper &apos;cache --timeout=3600&apos;   # 保存在内存中</span><br><span class=\"line\"># 保存在磁盘上, 默认查找 ~/.git-credentials  $XDG_CONFIG_HOME/git/credentials</span><br><span class=\"line\">git config credential.helper &apos;store --file=&lt;path&gt;&apos;</span><br></pre></td></tr></table></figure>\n<h1 id=\"git-lfs\"><a href=\"#git-lfs\" class=\"headerlink\" title=\"git lfs\"></a>git lfs</h1><p><a href=\"brew install git-lfs\">git-lfs</a> </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install git-lfs</span><br><span class=\"line\"></span><br><span class=\"line\">git lfs install</span><br><span class=\"line\"><span class=\"built_in\">cd</span> xxx.git</span><br><span class=\"line\">git lfs track <span class=\"string\">\"*.psd\"</span></span><br><span class=\"line\">git add .gitattributes</span><br><span class=\"line\">git add *.psd</span><br><span class=\"line\">git commit -m <span class=\"string\">\"log msg\"</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n<h1 id=\"git-archive\"><a href=\"#git-archive\" class=\"headerlink\" title=\"git archive\"></a>git archive</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git archive --format=tar --remote=https://github.com/vozlt/nginx-module-vts.git HEAD | tar xf -</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用户级的配置文件路径</span></span><br><span class=\"line\">~/.gitconfig</span><br><span class=\"line\"><span class=\"comment\"># 配置用户身份</span></span><br><span class=\"line\">git config --global user.name <span class=\"string\">\"zhangll\"</span></span><br><span class=\"line\">git config --global user.email zhangll@lizi.com</span><br><span class=\"line\">git config --global core.editor vim</span><br><span class=\"line\">git config --global merge.tool vimdiff</span><br><span class=\"line\">git config --global push.default simple           <span class=\"comment\"># 在 \"git push\" 时，会推到当前分支跟踪的远程分支（可能名称不同）</span></span><br><span class=\"line\">git config --global core.filemode <span class=\"literal\">false</span>           <span class=\"comment\"># 忽略文件仅文件权限的变更（比如 old mode 100755  new mode 100644）</span></span><br><span class=\"line\">git config --global color.ui auto                 <span class=\"comment\"># git命令下会使用红色、绿色等来突出显示。</span></span><br><span class=\"line\">git config --global branch.autosetuprebase always <span class=\"comment\"># 在 \"git pull\" 时，总会自动rebase</span></span><br><span class=\"line\">git config --global credential.helper cache       <span class=\"comment\"># 在 clone `https` 类型的URL时，可减少用户名密码输入次数</span></span><br><span class=\"line\">git config --global core.quotepath <span class=\"literal\">false</span>          <span class=\"comment\"># 在提交中文名称的文件时，不转义为 \\350\\256\\256\\346\\200\\273\\347\\273\\223.xlsx</span></span><br><span class=\"line\">git config --global core.ignorecase <span class=\"literal\">false</span>         <span class=\"comment\"># 文件名区分大小写 </span></span><br><span class=\"line\">git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">git config --global http.proxy <span class=\"string\">'socks5://127.0.0.1:9999'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add path/file              <span class=\"comment\"># 添加新文件</span></span><br><span class=\"line\">git reset HEAD path/file       <span class=\"comment\"># 取消添加</span></span><br><span class=\"line\">git commit  -m <span class=\"string\">\"commit msg\"</span>    <span class=\"comment\"># 提交修改</span></span><br><span class=\"line\">git push                       <span class=\"comment\"># 推送到远程</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h1><p><a href=\"https://cms-sw.github.io/tutorial-proxy.html\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<h2 id=\"git-协议\"><a href=\"#git-协议\" class=\"headerlink\" title=\"git 协议\"></a>git 协议</h2><p>需要配置 ssh 的相关代理配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ~/.ssh/config  @ internal </span></span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">    User                    git</span><br><span class=\"line\">    ProxyCommand            ssh user@gateway.host /usr/bin/nc %h %p</span><br><span class=\"line\">    IdentityFile             ~/.ssh/id_rsa.gitlab</span><br></pre></td></tr></table></figure>\n<h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> --mirror git@gitlab.com:kingsilk/qh-env.wiki.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> qh-env.wiki.git</span><br><span class=\"line\">git remote update</span><br></pre></td></tr></table></figure>\n<h2 id=\"http-https-协议\"><a href=\"#http-https-协议\" class=\"headerlink\" title=\"http, https 协议\"></a>http, https 协议</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># @gateway  开启 socks5 代理</span></span><br><span class=\"line\">/usr/bin/ssh proxy@gateway.kingsilk.net \\</span><br><span class=\"line\">    -C -N -g -D gateway.kingsilk.net:9999 \\</span><br><span class=\"line\">    -o ExitOnForwardFailure=yes \\</span><br><span class=\"line\">    -o ServerAliveInterval=60</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># @internal 配置 git 使用代理</span></span><br><span class=\"line\">git config --global http.proxy socks5://gateway.kingsilk.net:9999</span><br><span class=\"line\"><span class=\"comment\">#git config core.gitproxy  socks5://prod11.kingsilk.net:9999</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"git-协议-1\"><a href=\"#git-协议-1\" class=\"headerlink\" title=\"git 协议\"></a>git 协议</h2><p>参考: <a href=\"https://www.emilsit.net/blog/archives/how-to-use-the-git-protocol-through-a-http-connect-proxy/\" target=\"_blank\" rel=\"noopener\">1</a>、<br><a href=\"https://gist.github.com/sit/49288\" target=\"_blank\" rel=\"noopener\">2</a>、<br><a href=\"https://github.com/cms-sw/cms-git-tools/blob/master/git-proxy\" target=\"_blank\" rel=\"noopener\">git-proxy@cms-sw/cms-git-tools</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># @gateway  开启 socks5 代理</span></span><br><span class=\"line\">/usr/bin/ssh proxy@gateway.kingsilk.net \\</span><br><span class=\"line\">    -C -N -g -D gateway.kingsilk.net:9999 \\</span><br><span class=\"line\">    -o ExitOnForwardFailure=yes \\</span><br><span class=\"line\">    -o ServerAliveInterval=60</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">vi /data0/git-proxy</span><br><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">nc -x gateway.kingsilk.net:9999 <span class=\"variable\">$1</span> <span class=\"variable\">$2</span></span><br><span class=\"line\"></span><br><span class=\"line\">chmod +x /data0/git-proxy</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global core.gitproxy <span class=\"string\">\"/data0/git-proxy\"</span></span><br><span class=\"line\">git config --global socks.proxy <span class=\"string\">\"localhost:1080\"</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a>创建仓库</h1><p>参考：<a href=\"http://gitref.org/\" target=\"_blank\" rel=\"noopener\">http://gitref.org/</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 远程服务器创建</span></span><br><span class=\"line\">mkdir lizi-tmp</span><br><span class=\"line\"><span class=\"built_in\">cd</span> lizi-tmp</span><br><span class=\"line\">git --bare init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本地创建</span></span><br><span class=\"line\">mkdir zll</span><br><span class=\"line\"><span class=\"built_in\">cd</span> zll</span><br><span class=\"line\">git init</span><br><span class=\"line\"><span class=\"built_in\">echo</span> hello &gt; README</span><br><span class=\"line\">git add README</span><br><span class=\"line\">git commit -m <span class=\"string\">\"first commit\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地设置为跟踪远程服务器</span></span><br><span class=\"line\">git remote add origin git@newcrm.nalashop.com:~/web/lizi-tmp</span><br><span class=\"line\">git push --<span class=\"built_in\">set</span>-upstream origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除</span></span><br><span class=\"line\">git rm README</span><br><span class=\"line\">git mv file_from file_to</span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在提交前，将已标记为要提交的文件移除。</span></span><br><span class=\"line\">git reset HEAD xxxFile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 取消修改</span></span><br><span class=\"line\">git checkout -- benchmarks.rb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改最后一次提交</span></span><br><span class=\"line\">git commit --amend</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前工作区的状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"><span class=\"comment\"># .gitignore 中可以忽略特定的文件</span></span><br><span class=\"line\">git diff</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看远程仓库的URL</span></span><br><span class=\"line\">git config --get remote.origin.url</span><br></pre></td></tr></table></figure>\n<h1 id=\"远程\"><a href=\"#远程\" class=\"headerlink\" title=\"远程\"></a>远程</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果使用ssh key，就不要使用https协议</span></span><br><span class=\"line\">git remote add origin git@10.1.18.153:zhangliangliang/test.git</span><br><span class=\"line\">git remote <span class=\"built_in\">set</span>-url origin git@new-host:new-url</span><br><span class=\"line\">git remote show</span><br><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git push -u origin master:master  <span class=\"comment\"># 第一个master是本地分支，第二个master是远程分支</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重命名</span></span><br><span class=\"line\">git remote rename origin xx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库上获取最新内容（不合并本地已经修改的内容）</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：分支号前面的加号可选</span></span><br><span class=\"line\"><span class=\"comment\"># 如果 :local-branch-name 省略，则默认与remote-branch-name 相同</span></span><br><span class=\"line\">git fetch remote-name  +remote-branch-name:<span class=\"built_in\">local</span>-branchName</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库上获取最新内容（合并本地已经修改的内容）</span></span><br><span class=\"line\">git pull --rebase</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交到远程服务器</span></span><br><span class=\"line\">git push remote-name [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## FIXME fetch, pull 是保存到工作空间？还是状态空间？</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Tag\"><a href=\"#Tag\" class=\"headerlink\" title=\"Tag\"></a>Tag</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 显示本地所有tag</span></span><br><span class=\"line\">git tag</span><br><span class=\"line\"><span class=\"comment\"># 显示指定前缀的tag</span></span><br><span class=\"line\">git tag -l <span class=\"string\">\"v1.1*\"</span></span><br><span class=\"line\"><span class=\"comment\"># 显示具体某个tag的详情</span></span><br><span class=\"line\">git show tag-name</span><br><span class=\"line\"><span class=\"comment\"># 显示远程所有的分支和标签</span></span><br><span class=\"line\">git ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建轻量级tag（不要使用 -a -s -m 选项）</span></span><br><span class=\"line\">git tag v1.4-lw</span><br><span class=\"line\"><span class=\"comment\"># 新建tag(默认是对当前状态进行tag)</span></span><br><span class=\"line\">git tag -a new-tag-name -m some-message [commit-hash]</span><br><span class=\"line\"><span class=\"comment\"># 新建签名的tag(不要使用 -a 选项）</span></span><br><span class=\"line\">git tag -s tag-name -m some-message</span><br><span class=\"line\"><span class=\"comment\"># 验证签名tag：会使用GPG进行验证，需要预先下载签名者的公钥</span></span><br><span class=\"line\">git tag -v tag-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交指定的tag到远程</span></span><br><span class=\"line\">git push remote-name tag-name</span><br><span class=\"line\"><span class=\"comment\"># 提交所有的tag到远程</span></span><br><span class=\"line\">git push remote-name --tags</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除本地tag</span></span><br><span class=\"line\">git tag -d tag-name</span><br><span class=\"line\"><span class=\"comment\"># 删除远程tag</span></span><br><span class=\"line\">git push origin :refs/tags/tag-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检出tag</span></span><br><span class=\"line\">git checkout tags/tag-name</span><br></pre></td></tr></table></figure>\n<h1 id=\"Branch\"><a href=\"#Branch\" class=\"headerlink\" title=\"Branch\"></a>Branch</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建分支</span></span><br><span class=\"line\">git branch branch-name</span><br><span class=\"line\"><span class=\"comment\"># 检出远程分支</span></span><br><span class=\"line\">git checkout -b <span class=\"built_in\">local</span>-branch-name origin/remote-branch-name</span><br><span class=\"line\"><span class=\"comment\"># 切换本地分支</span></span><br><span class=\"line\">git checkout branch-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建并切换到该新分支(等价于上述两个命令)</span></span><br><span class=\"line\">git checkout -b new-branch-name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看本地所有分支，以及工作空间所用的分支（前缀有*号）</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"><span class=\"comment\"># 查看远程分支</span></span><br><span class=\"line\">git branch -r</span><br><span class=\"line\"><span class=\"comment\"># 查看所有分支（本地和远程）</span></span><br><span class=\"line\">git branch -av</span><br><span class=\"line\">git show-branch</span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支是track远程的哪个分支</span></span><br><span class=\"line\">git remote show origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看分支最后一个提交对象</span></span><br><span class=\"line\">git branch -v</span><br><span class=\"line\">（分别叫做 stashing 和 commit amending）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果有有合并冲突的文件，需要手动合并后，再使用以下命令就OK了</span></span><br><span class=\"line\">git add merged-by-hand-file</span><br><span class=\"line\">git commit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地分支推送到远程其他分支</span></span><br><span class=\"line\">git push &lt;REMOTENAME&gt; &lt;LOCALBRANCHNAME&gt;:&lt;REMOTEBRANCHNAME&gt; </span><br><span class=\"line\">git push origin master:1.0.x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除分支(本地)</span></span><br><span class=\"line\">git branch -d branch-name</span><br><span class=\"line\"><span class=\"comment\"># 删除分支(远程)</span></span><br><span class=\"line\">git push origin --delete &lt;branch_name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###  合并分支</span></span><br><span class=\"line\"><span class=\"comment\">#          A---B---C 2.0.x</span></span><br><span class=\"line\"><span class=\"comment\">#         /</span></span><br><span class=\"line\"><span class=\"comment\">#    D---E---F---G master</span></span><br><span class=\"line\"></span><br><span class=\"line\">git checkout 2.0.x</span><br><span class=\"line\">git rebase master</span><br><span class=\"line\"><span class=\"comment\">#git rebase master 2.0.x</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#                  A'--B'--C' 2.0.x</span></span><br><span class=\"line\"><span class=\"comment\">#                 /</span></span><br><span class=\"line\"><span class=\"comment\">#    D---E---F---G master</span></span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge 2.0.x         <span class=\"comment\"># 这种情形是可以 fast-forwad 的</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"远程分支\"><a href=\"#远程分支\" class=\"headerlink\" title=\"远程分支\"></a>远程分支</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建远程分支</span></span><br><span class=\"line\">git push origin <span class=\"built_in\">test</span>:master         // 提交本地<span class=\"built_in\">test</span>分支作为远程的master分支</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并远程分支</span></span><br><span class=\"line\">git checkout remoteBranch1                 <span class=\"comment\"># ??? git checkout origin/branch1</span></span><br><span class=\"line\">git push origin remoteBranch1:remoteBranch2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除远程分支</span></span><br><span class=\"line\">git push origin :remoteBranch2</span><br></pre></td></tr></table></figure>\n<h1 id=\"取消本地所有修改\"><a href=\"#取消本地所有修改\" class=\"headerlink\" title=\"取消本地所有修改\"></a>取消本地所有修改</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 取消对文件的修改</span></span><br><span class=\"line\">git reset --hard HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除本地未索引的文件</span></span><br><span class=\"line\">git clean -fdx</span><br><span class=\"line\"></span><br><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<h1 id=\"删除最后几次commit\"><a href=\"#删除最后几次commit\" class=\"headerlink\" title=\"删除最后几次commit\"></a>删除最后几次commit</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看提交的log，并找到想要回滚到的commit的</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\">git reset --hard &lt;sha1-commit-id&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>假如有新修改提交到本地了。在push前进行pull的时候，<br>git自动合并并创建了一个新的commit，其注释为 “Merge branch ‘xxx’ of git@xxxx/path/to/xxx.git into xxx”。此时，大家应当立即运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitk  <span class=\"comment\"># 此时有比较复杂的路线图</span></span><br><span class=\"line\">git rebase</span><br><span class=\"line\">gitk  <span class=\"comment\"># 此时就变成单线路了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># rebase之后，会将本地的多个提交合并成一个提交，原来的多个提交的历史记录可以通过以下命令找到</span></span><br><span class=\"line\">git reflog</span><br><span class=\"line\">git cherry-pick 12944d8</span><br></pre></td></tr></table></figure>\n<h1 id=\"单个文件\"><a href=\"#单个文件\" class=\"headerlink\" title=\"单个文件\"></a>单个文件</h1><h2 id=\"查看日志\"><a href=\"#查看日志\" class=\"headerlink\" title=\"查看日志\"></a>查看日志</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> path/to/file</span><br></pre></td></tr></table></figure>\n<h2 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff &lt;sha1-commit-id1&gt; &lt;sha1-commit-id2&gt; path/to/file</span><br></pre></td></tr></table></figure>\n<h2 id=\"检出特定版本\"><a href=\"#检出特定版本\" class=\"headerlink\" title=\"检出特定版本\"></a>检出特定版本</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout &lt;sha1-commit-id&gt; path/to/file</span><br></pre></td></tr></table></figure>\n<h2 id=\"无本地copy情况下，从远程仓库检出最新的指定文件\"><a href=\"#无本地copy情况下，从远程仓库检出最新的指定文件\" class=\"headerlink\" title=\"无本地copy情况下，从远程仓库检出最新的指定文件\"></a>无本地copy情况下，从远程仓库检出最新的指定文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git ls-remote git@git.test.me:/path/to/git/repo</span><br><span class=\"line\">git archive --remote=git@git.test.me:/path/to/git/repo refs/heads/<span class=\"built_in\">test</span> path/to/file  --format zip -o /tmp/a.zip</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/</span><br><span class=\"line\">unzip /tmp/a.zip</span><br><span class=\"line\">cp path/to/file /path/to/dest</span><br></pre></td></tr></table></figure>\n<h2 id=\"无本地copy情况下，从远程仓库检出指定版本的指定文件\"><a href=\"#无本地copy情况下，从远程仓库检出指定版本的指定文件\" class=\"headerlink\" title=\"无本地copy情况下，从远程仓库检出指定版本的指定文件\"></a>无本地copy情况下，从远程仓库检出指定版本的指定文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 先通过SSH登录到远程仓库，看一下test分支上指定文件的最近3条日志，找到所需的commit SHA1.</span></span><br><span class=\"line\">ssh git@git.test.me <span class=\"string\">\"cd /path/to/git/repo &amp;&amp; git log -n 3 test -- path/to/file\"</span></span><br><span class=\"line\">git archive --remote=git@git.test.me:/path/to/git/repo d787416b0aec88747075ef0f5909bc4f863aa26e path/to/file  --format zip -o /tmp/a.zip</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/</span><br><span class=\"line\">unzip /tmp/a.zip</span><br><span class=\"line\">cp path/to/file /path/to/dest</span><br></pre></td></tr></table></figure>\n<h1 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/target-eclipse/classes</span><br><span class=\"line\">/web-app/WEB-INF/classes</span><br><span class=\"line\">/target/</span><br><span class=\"line\">/out/</span><br><span class=\"line\">/test/</span><br><span class=\"line\">/overlays/</span><br><span class=\"line\">/db/</span><br><span class=\"line\">.classpath</span><br><span class=\"line\">.settings/</span><br><span class=\"line\">.project</span><br><span class=\"line\">.idea/</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">*.iml</span><br><span class=\"line\">*.ipr</span><br><span class=\"line\">*.iws</span><br><span class=\"line\">*.swp</span><br><span class=\"line\">*.log</span><br></pre></td></tr></table></figure>\n<p>注意：如果要忽略特定的目录中的文件，但还想在远程仓库中保持该目录，则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">emptyDir/*</span><br><span class=\"line\">!emptyDir/.gitkeep</span><br></pre></td></tr></table></figure>\n<h1 id=\"撤销提交\"><a href=\"#撤销提交\" class=\"headerlink\" title=\"撤销提交\"></a>撤销提交</h1><h2 id=\"编辑最后一次本地提交\"><a href=\"#编辑最后一次本地提交\" class=\"headerlink\" title=\"编辑最后一次本地提交\"></a>编辑最后一次本地提交</h2><p>也即，本地已经commit，但是没push到远程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --soft HEAD~1             <span class=\"comment\"># 先reset，会copy HEAD为.git/ORIG_HEAD</span></span><br><span class=\"line\">doSomeEdit</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -c ORIG_HEAD             <span class=\"comment\"># 使用原来的commit消息，并提交</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"本地已经commit，也已经push到远程，但其他开发人员尚未拉取\"><a href=\"#本地已经commit，也已经push到远程，但其他开发人员尚未拉取\" class=\"headerlink\" title=\"本地已经commit，也已经push到远程，但其他开发人员尚未拉取\"></a>本地已经commit，也已经push到远程，但其他开发人员尚未拉取</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -f                         <span class=\"comment\"># 本地修改之后，强制提交</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\"><a href=\"#本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\" class=\"headerlink\" title=\"本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交\"></a>本地已经commit，也已经push到远程，但其他开发人员已经拉取，且进行了多次提交</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rever &lt;commit-id&gt;               <span class=\"comment\"># 该方法通过在最新commit之后新建一个commit来达到回滚的效果。</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"统计\"><a href=\"#统计\" class=\"headerlink\" title=\"统计\"></a>统计</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 一定时期内的代码提交次数</span><br><span class=\"line\">git log --after=2015-01-01 --before=2016-03-01 --pretty=&apos;%ae&apos; | sort | uniq -c | sort -k1 -n -r</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 统计代码修改量</span><br><span class=\"line\">git log --after=2015-01-01 --before=2016-03-01 --pretty=&apos;%an&apos; | sort -u</span><br><span class=\"line\">git log --author=&quot;btpka3&quot; --pretty=tformat: --numstat \\</span><br><span class=\"line\">    | gawk &apos;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; \\</span><br><span class=\"line\">    END &#123; printf &quot;added lines: %s removed lines : %s total lines: %s\\n&quot;,add,subs,loc &#125;&apos; -</span><br><span class=\"line\"></span><br><span class=\"line\"># gitstats</span><br><span class=\"line\">gitstats -c project_name=qh-app \\</span><br><span class=\"line\">    -c commit_begin=`git log --date-order --date=iso --before=2015-01-01 -n 1 --pretty=&apos;%H&apos;` \\</span><br><span class=\"line\">    -c commit_end=`git log --date-order --date=iso --before=2016-03-01  -n 1 --pretty=&apos;%H&apos;`  \\</span><br><span class=\"line\">    qh-app \\</span><br><span class=\"line\">    stat/qh-app</span><br></pre></td></tr></table></figure>\n<h1 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\"sync\"></a>sync</h1><h2 id=\"repo\"><a href=\"#repo\" class=\"headerlink\" title=\"repo\"></a>repo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone http://git.oschina.net/btpka3/btpka3.wiki.git</span><br><span class=\"line\">cd btpka3.wiki</span><br><span class=\"line\">git remote add gitlab git@git.kingsilk.xyz:btpka3/btpka3.wiki.git</span><br><span class=\"line\">git config --list</span><br></pre></td></tr></table></figure>\n<h2 id=\"crontab\"><a href=\"#crontab\" class=\"headerlink\" title=\"crontab\"></a>crontab</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 */1  *   *   *   /home/zll/work/git-repo/oschina/sync-wiki.sh 2&gt;&amp;1 &gt;&gt;  /home/zll/work/git-repo/oschina/sync-wiki.log</span><br></pre></td></tr></table></figure>\n<h2 id=\"sync-wiki-sh\"><a href=\"#sync-wiki-sh\" class=\"headerlink\" title=\"sync-wiki.sh\"></a>sync-wiki.sh</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">TIME=&quot;date +%Y-%m-%d.%H:%M:%S&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">cd /home/zll/work/git-repo/oschina/btpka3.wiki</span><br><span class=\"line\">echo `$TIME` pull from gitlab</span><br><span class=\"line\">git pull --rebase gitlab master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` pull from oschina</span><br><span class=\"line\">git pull --rebase origin master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` push to oschina</span><br><span class=\"line\">git push origin master:master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` push to oschina</span><br><span class=\"line\">git push -f gitlab master:master</span><br><span class=\"line\">[ $? = 0 ] || exit -1</span><br><span class=\"line\"></span><br><span class=\"line\">echo `$TIME` Done.</span><br></pre></td></tr></table></figure>\n<h2 id=\"pull-request-merge-request\"><a href=\"#pull-request-merge-request\" class=\"headerlink\" title=\"pull request, merge request\"></a>pull request, merge request</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. 开发人员fork一个要修改的分支(比如 \"master\")，修改、测试、并推送到远程（比如：远程分支 \"zll-123\")</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 要合并的人员进行以下操作：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.0 先获取最新</span></span><br><span class=\"line\">git pull --all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.1 先获取最新，并检出经过修改的分支</span></span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git checkout -b zll-123 origin/zll-123</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2 再检出要合并到的目标分支，</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff zll-123</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.3 进行代码审查和测试</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.4 推送的远程</span></span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<h2 id=\"change-remote\"><a href=\"#change-remote\" class=\"headerlink\" title=\"change remote\"></a>change remote</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">APP=xhs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$&#123;APP&#125;</span></span><br><span class=\"line\">git status .</span><br><span class=\"line\">git branch -av</span><br><span class=\"line\">git remote -v</span><br><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin git@gitlab.com:kingsilk/<span class=\"variable\">$&#123;APP&#125;</span>.git</span><br><span class=\"line\">git fetch</span><br><span class=\"line\">git branch --<span class=\"built_in\">set</span>-upstream-to=origin/master master</span><br><span class=\"line\">git remote -v</span><br><span class=\"line\">git pull</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br></pre></td></tr></table></figure>\n<h2 id=\"transfer\"><a href=\"#transfer\" class=\"headerlink\" title=\"transfer\"></a>transfer</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /tmp</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> root@192.168.0.12:/home/git/repositories/kingsilk/env.wiki.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> env.wiki</span><br><span class=\"line\">git remote show</span><br><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin git@gitlab.com:kingsilk/qh-env.wiki.git</span><br><span class=\"line\">git push -u origin --all</span><br><span class=\"line\">git push -u origin --tags</span><br><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br></pre></td></tr></table></figure>\n"},{"title":"linux时区更改","description":"linux时区更改","date":"2017-10-19T22:49:50.000Z","comments":0,"_content":"\n### 时区更改\n```bash\n#查看当前时区\ndate -R\n#修改设置Linux服务器时区\ntzselect\n#复制相应的时区文件，替换系统时区文件；或者创建链接文件\ncp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime\n#例如：在设置中国时区使用亚洲/上海（+8）\ncp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```","source":"_posts/service/linux/linux-note.md","raw":"---\ntitle : linux时区更改\ndescription: linux时区更改\ndate: 2017-10-20 06:49:50\ncomments: false\n---\n\n### 时区更改\n```bash\n#查看当前时区\ndate -R\n#修改设置Linux服务器时区\ntzselect\n#复制相应的时区文件，替换系统时区文件；或者创建链接文件\ncp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime\n#例如：在设置中国时区使用亚洲/上海（+8）\ncp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```","slug":"service/linux/linux-note","published":1,"updated":"2017-12-15T08:12:58.875Z","layout":"post","photos":[],"link":"","_id":"cjclsgbqx00276dofgei0760b","content":"<h3 id=\"时区更改\"><a href=\"#时区更改\" class=\"headerlink\" title=\"时区更改\"></a>时区更改</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查看当前时区</span></span><br><span class=\"line\">date -R</span><br><span class=\"line\"><span class=\"comment\">#修改设置Linux服务器时区</span></span><br><span class=\"line\">tzselect</span><br><span class=\"line\"><span class=\"comment\">#复制相应的时区文件，替换系统时区文件；或者创建链接文件</span></span><br><span class=\"line\">cp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime</span><br><span class=\"line\"><span class=\"comment\">#例如：在设置中国时区使用亚洲/上海（+8）</span></span><br><span class=\"line\">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"时区更改\"><a href=\"#时区更改\" class=\"headerlink\" title=\"时区更改\"></a>时区更改</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#查看当前时区</span></span><br><span class=\"line\">date -R</span><br><span class=\"line\"><span class=\"comment\">#修改设置Linux服务器时区</span></span><br><span class=\"line\">tzselect</span><br><span class=\"line\"><span class=\"comment\">#复制相应的时区文件，替换系统时区文件；或者创建链接文件</span></span><br><span class=\"line\">cp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime</span><br><span class=\"line\"><span class=\"comment\">#例如：在设置中国时区使用亚洲/上海（+8）</span></span><br><span class=\"line\">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>"},{"title":"leanote 搭建过程","date":"2017-11-20T02:34:22.000Z","description":"久闻leanote大名，今天入坑试一试","_content":"## 安装 golang\n\n```bash\nwget http://www.golangtc.com/static/go/1.6/go1.6.linux-amd64.tar.gz\ncd /home/leanote\ntar -xzvf go1.6.linux-amd64.tar.gz\nmkdir /home/user1/gopackage #这里面会放go的包和编译后的文件\nmkdir /home/leanote/gopackage\n```\n    \n配置环境变量, 编辑/etc/profile文件：\n```bash\nsudo vim /etc/profile\nexport GOROOT=/home/leanote/go\nexport GOPATH=/home/leanote/gopackage\nexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin\nsource /etc/profile\n```\n    \n查看go是否安装成功:\n```bash\ngo version\n```\n## 获取Revel和 Leanote 的源码\n\n请下载 leante-all-master.zip。解压后，将src文件夹复制到 /home/leanote/gopackage/使用如下命令生成revel二进制命令, 稍后运行Leanote需要用到：\n\n```bash\ngo install github.com/revel/cmd/revel\n```\n    \n## 安装Mongodb\n### 安装Mongodb\n```bash\nwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz\ncd /home/leanote\ntar -xzvf mongodb-linux-x86_64-3.0.1.tgz/\nsudo vim /etc/profile\nexport PATH=$PATH:/home/leanote/mongodb-linux-x86_64-3.0.1/bin\nsource /etc/profile\n```\n    \n### 测试Mongodb安装\n```bash\nmkdir /home/leanote/data\nmongod --dbpath /home/leanote/data\n```\n    \n```\n# 首先切换到leanote数据库下\n> use leanote;\n# 添加一个用户root, 密码是abc123\n> db.createUser({\n    user: 'root',\n    pwd: '19930317.tong',\n    roles: [{role: 'dbOwner', db: 'leanote'}]\n});\n# 测试下是否正确\n> db.auth(\"root\", \"19930317.tong\");\n1 # 返回1表示正确\n```\n    \n添加到服务中：\n\n```\n[Unit]\nDescription=mongodb\nAfter=network.target remote-fs.target nss-lookup.target\n \n[Service]\nType=forking\nPIDFile=/home/leanote/data/mongod.lock\nExecStart=/home/leanote/mongodb-linux-x86_64-3.0.1/bin/mongod --dbpath=/home/leanote/data --logpath=/home/leanote/log/mongodb.log --logappend --fork\nExecReload=/bin/kill -s HUP $MAINPID\nExecStop=/bin/kill -s QUIT $MAINPID\nPrivateTmp=true\n \n[Install]\nWantedBy=multi-user.target\n```\n\n\n## 导入初始数据\n```bash\nmongorestore -h localhost -d leanote --dir /home/leanote/gopackage/src/github.com/leanote/leanote/mongodb_backup/leanote_install_data\n```\n    \n## 配置Leanote\n\n```bash\nvi conf/app.conf\n```\n    \n```\nhttp.port=80\nsite.url=http://a.com\napp.secret=XXXXXXXXXXXXXXXX\ndb.host=localhost\ndb.port=27017\ndb.dbname=leanote # required\ndb.username=root # if not exists, please leave blank\ndb.password=abc123 # if not exists, please leave blank\n```\n    \n配置开机启动：\n```\n#!/bin/bash\n    nohup mongod --dbpath /root/mongodb/data --auth 2>&1 &\n    nohup revel run github.com/leanote/leanote 2>&1 &\n    sstr=$(echo -e $str)\n    echo \"$sstr\"\n    \n    vi /etc/rc.local\n    \n    source /etc/profile\n    /root/gopackage/run.sh\n```\n\n## 运行Leanote\n\n```\nrevel run github.com/leanote/leanote\n```","source":"_posts/service/other/leanote-install.md","raw":"---\ntitle: leanote 搭建过程\ndate: 2017-11-20 10:34:22\ncategories: 服务器\ntags: [server]\ndescription: 久闻leanote大名，今天入坑试一试\n---\n## 安装 golang\n\n```bash\nwget http://www.golangtc.com/static/go/1.6/go1.6.linux-amd64.tar.gz\ncd /home/leanote\ntar -xzvf go1.6.linux-amd64.tar.gz\nmkdir /home/user1/gopackage #这里面会放go的包和编译后的文件\nmkdir /home/leanote/gopackage\n```\n    \n配置环境变量, 编辑/etc/profile文件：\n```bash\nsudo vim /etc/profile\nexport GOROOT=/home/leanote/go\nexport GOPATH=/home/leanote/gopackage\nexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin\nsource /etc/profile\n```\n    \n查看go是否安装成功:\n```bash\ngo version\n```\n## 获取Revel和 Leanote 的源码\n\n请下载 leante-all-master.zip。解压后，将src文件夹复制到 /home/leanote/gopackage/使用如下命令生成revel二进制命令, 稍后运行Leanote需要用到：\n\n```bash\ngo install github.com/revel/cmd/revel\n```\n    \n## 安装Mongodb\n### 安装Mongodb\n```bash\nwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz\ncd /home/leanote\ntar -xzvf mongodb-linux-x86_64-3.0.1.tgz/\nsudo vim /etc/profile\nexport PATH=$PATH:/home/leanote/mongodb-linux-x86_64-3.0.1/bin\nsource /etc/profile\n```\n    \n### 测试Mongodb安装\n```bash\nmkdir /home/leanote/data\nmongod --dbpath /home/leanote/data\n```\n    \n```\n# 首先切换到leanote数据库下\n> use leanote;\n# 添加一个用户root, 密码是abc123\n> db.createUser({\n    user: 'root',\n    pwd: '19930317.tong',\n    roles: [{role: 'dbOwner', db: 'leanote'}]\n});\n# 测试下是否正确\n> db.auth(\"root\", \"19930317.tong\");\n1 # 返回1表示正确\n```\n    \n添加到服务中：\n\n```\n[Unit]\nDescription=mongodb\nAfter=network.target remote-fs.target nss-lookup.target\n \n[Service]\nType=forking\nPIDFile=/home/leanote/data/mongod.lock\nExecStart=/home/leanote/mongodb-linux-x86_64-3.0.1/bin/mongod --dbpath=/home/leanote/data --logpath=/home/leanote/log/mongodb.log --logappend --fork\nExecReload=/bin/kill -s HUP $MAINPID\nExecStop=/bin/kill -s QUIT $MAINPID\nPrivateTmp=true\n \n[Install]\nWantedBy=multi-user.target\n```\n\n\n## 导入初始数据\n```bash\nmongorestore -h localhost -d leanote --dir /home/leanote/gopackage/src/github.com/leanote/leanote/mongodb_backup/leanote_install_data\n```\n    \n## 配置Leanote\n\n```bash\nvi conf/app.conf\n```\n    \n```\nhttp.port=80\nsite.url=http://a.com\napp.secret=XXXXXXXXXXXXXXXX\ndb.host=localhost\ndb.port=27017\ndb.dbname=leanote # required\ndb.username=root # if not exists, please leave blank\ndb.password=abc123 # if not exists, please leave blank\n```\n    \n配置开机启动：\n```\n#!/bin/bash\n    nohup mongod --dbpath /root/mongodb/data --auth 2>&1 &\n    nohup revel run github.com/leanote/leanote 2>&1 &\n    sstr=$(echo -e $str)\n    echo \"$sstr\"\n    \n    vi /etc/rc.local\n    \n    source /etc/profile\n    /root/gopackage/run.sh\n```\n\n## 运行Leanote\n\n```\nrevel run github.com/leanote/leanote\n```","slug":"service/other/leanote-install","published":1,"updated":"2017-12-15T08:12:58.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbqy002c6dofqz37ju4p","content":"<h2 id=\"安装-golang\"><a href=\"#安装-golang\" class=\"headerlink\" title=\"安装 golang\"></a>安装 golang</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://www.golangtc.com/static/go/1.6/go1.6.linux-amd64.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/leanote</span><br><span class=\"line\">tar -xzvf go1.6.linux-amd64.tar.gz</span><br><span class=\"line\">mkdir /home/user1/gopackage <span class=\"comment\">#这里面会放go的包和编译后的文件</span></span><br><span class=\"line\">mkdir /home/leanote/gopackage</span><br></pre></td></tr></table></figure>\n<p>配置环境变量, 编辑/etc/profile文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"built_in\">export</span> GOROOT=/home/leanote/go</span><br><span class=\"line\"><span class=\"built_in\">export</span> GOPATH=/home/leanote/gopackage</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$GOROOT</span>/bin:<span class=\"variable\">$GOPATH</span>/bin</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p>\n<p>查看go是否安装成功:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go version</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"获取Revel和-Leanote-的源码\"><a href=\"#获取Revel和-Leanote-的源码\" class=\"headerlink\" title=\"获取Revel和 Leanote 的源码\"></a>获取Revel和 Leanote 的源码</h2><p>请下载 leante-all-master.zip。解压后，将src文件夹复制到 /home/leanote/gopackage/使用如下命令生成revel二进制命令, 稍后运行Leanote需要用到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install github.com/revel/cmd/revel</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Mongodb\"><a href=\"#安装Mongodb\" class=\"headerlink\" title=\"安装Mongodb\"></a>安装Mongodb</h2><h3 id=\"安装Mongodb-1\"><a href=\"#安装Mongodb-1\" class=\"headerlink\" title=\"安装Mongodb\"></a>安装Mongodb</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/leanote</span><br><span class=\"line\">tar -xzvf mongodb-linux-x86_64-3.0.1.tgz/</span><br><span class=\"line\">sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/home/leanote/mongodb-linux-x86_64-3.0.1/bin</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试Mongodb安装\"><a href=\"#测试Mongodb安装\" class=\"headerlink\" title=\"测试Mongodb安装\"></a>测试Mongodb安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /home/leanote/data</span><br><span class=\"line\">mongod --dbpath /home/leanote/data</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 首先切换到leanote数据库下</span><br><span class=\"line\">&gt; use leanote;</span><br><span class=\"line\"># 添加一个用户root, 密码是abc123</span><br><span class=\"line\">&gt; db.createUser(&#123;</span><br><span class=\"line\">    user: &apos;root&apos;,</span><br><span class=\"line\">    pwd: &apos;19930317.tong&apos;,</span><br><span class=\"line\">    roles: [&#123;role: &apos;dbOwner&apos;, db: &apos;leanote&apos;&#125;]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"># 测试下是否正确</span><br><span class=\"line\">&gt; db.auth(&quot;root&quot;, &quot;19930317.tong&quot;);</span><br><span class=\"line\">1 # 返回1表示正确</span><br></pre></td></tr></table></figure>\n<p>添加到服务中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=mongodb</span><br><span class=\"line\">After=network.target remote-fs.target nss-lookup.target</span><br><span class=\"line\"> </span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">PIDFile=/home/leanote/data/mongod.lock</span><br><span class=\"line\">ExecStart=/home/leanote/mongodb-linux-x86_64-3.0.1/bin/mongod --dbpath=/home/leanote/data --logpath=/home/leanote/log/mongodb.log --logappend --fork</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class=\"line\">PrivateTmp=true</span><br><span class=\"line\"> </span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<h2 id=\"导入初始数据\"><a href=\"#导入初始数据\" class=\"headerlink\" title=\"导入初始数据\"></a>导入初始数据</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongorestore -h localhost -d leanote --dir /home/leanote/gopackage/src/github.com/leanote/leanote/mongodb_backup/leanote_install_data</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Leanote\"><a href=\"#配置Leanote\" class=\"headerlink\" title=\"配置Leanote\"></a>配置Leanote</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi conf/app.conf</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.port=80</span><br><span class=\"line\">site.url=http://a.com</span><br><span class=\"line\">app.secret=XXXXXXXXXXXXXXXX</span><br><span class=\"line\">db.host=localhost</span><br><span class=\"line\">db.port=27017</span><br><span class=\"line\">db.dbname=leanote # required</span><br><span class=\"line\">db.username=root # if not exists, please leave blank</span><br><span class=\"line\">db.password=abc123 # if not exists, please leave blank</span><br></pre></td></tr></table></figure>\n<p>配置开机启动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">    nohup mongod --dbpath /root/mongodb/data --auth 2&gt;&amp;1 &amp;</span><br><span class=\"line\">    nohup revel run github.com/leanote/leanote 2&gt;&amp;1 &amp;</span><br><span class=\"line\">    sstr=$(echo -e $str)</span><br><span class=\"line\">    echo &quot;$sstr&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vi /etc/rc.local</span><br><span class=\"line\">    </span><br><span class=\"line\">    source /etc/profile</span><br><span class=\"line\">    /root/gopackage/run.sh</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"运行Leanote\"><a href=\"#运行Leanote\" class=\"headerlink\" title=\"运行Leanote\"></a>运行Leanote</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revel run github.com/leanote/leanote</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装-golang\"><a href=\"#安装-golang\" class=\"headerlink\" title=\"安装 golang\"></a>安装 golang</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://www.golangtc.com/static/go/1.6/go1.6.linux-amd64.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/leanote</span><br><span class=\"line\">tar -xzvf go1.6.linux-amd64.tar.gz</span><br><span class=\"line\">mkdir /home/user1/gopackage <span class=\"comment\">#这里面会放go的包和编译后的文件</span></span><br><span class=\"line\">mkdir /home/leanote/gopackage</span><br></pre></td></tr></table></figure>\n<p>配置环境变量, 编辑/etc/profile文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"built_in\">export</span> GOROOT=/home/leanote/go</span><br><span class=\"line\"><span class=\"built_in\">export</span> GOPATH=/home/leanote/gopackage</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$GOROOT</span>/bin:<span class=\"variable\">$GOPATH</span>/bin</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure></p>\n<p>查看go是否安装成功:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go version</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"获取Revel和-Leanote-的源码\"><a href=\"#获取Revel和-Leanote-的源码\" class=\"headerlink\" title=\"获取Revel和 Leanote 的源码\"></a>获取Revel和 Leanote 的源码</h2><p>请下载 leante-all-master.zip。解压后，将src文件夹复制到 /home/leanote/gopackage/使用如下命令生成revel二进制命令, 稍后运行Leanote需要用到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install github.com/revel/cmd/revel</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Mongodb\"><a href=\"#安装Mongodb\" class=\"headerlink\" title=\"安装Mongodb\"></a>安装Mongodb</h2><h3 id=\"安装Mongodb-1\"><a href=\"#安装Mongodb-1\" class=\"headerlink\" title=\"安装Mongodb\"></a>安装Mongodb</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /home/leanote</span><br><span class=\"line\">tar -xzvf mongodb-linux-x86_64-3.0.1.tgz/</span><br><span class=\"line\">sudo vim /etc/profile</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:/home/leanote/mongodb-linux-x86_64-3.0.1/bin</span><br><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试Mongodb安装\"><a href=\"#测试Mongodb安装\" class=\"headerlink\" title=\"测试Mongodb安装\"></a>测试Mongodb安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /home/leanote/data</span><br><span class=\"line\">mongod --dbpath /home/leanote/data</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 首先切换到leanote数据库下</span><br><span class=\"line\">&gt; use leanote;</span><br><span class=\"line\"># 添加一个用户root, 密码是abc123</span><br><span class=\"line\">&gt; db.createUser(&#123;</span><br><span class=\"line\">    user: &apos;root&apos;,</span><br><span class=\"line\">    pwd: &apos;19930317.tong&apos;,</span><br><span class=\"line\">    roles: [&#123;role: &apos;dbOwner&apos;, db: &apos;leanote&apos;&#125;]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"># 测试下是否正确</span><br><span class=\"line\">&gt; db.auth(&quot;root&quot;, &quot;19930317.tong&quot;);</span><br><span class=\"line\">1 # 返回1表示正确</span><br></pre></td></tr></table></figure>\n<p>添加到服务中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=mongodb</span><br><span class=\"line\">After=network.target remote-fs.target nss-lookup.target</span><br><span class=\"line\"> </span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=forking</span><br><span class=\"line\">PIDFile=/home/leanote/data/mongod.lock</span><br><span class=\"line\">ExecStart=/home/leanote/mongodb-linux-x86_64-3.0.1/bin/mongod --dbpath=/home/leanote/data --logpath=/home/leanote/log/mongodb.log --logappend --fork</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class=\"line\">PrivateTmp=true</span><br><span class=\"line\"> </span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<h2 id=\"导入初始数据\"><a href=\"#导入初始数据\" class=\"headerlink\" title=\"导入初始数据\"></a>导入初始数据</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongorestore -h localhost -d leanote --dir /home/leanote/gopackage/src/github.com/leanote/leanote/mongodb_backup/leanote_install_data</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置Leanote\"><a href=\"#配置Leanote\" class=\"headerlink\" title=\"配置Leanote\"></a>配置Leanote</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi conf/app.conf</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.port=80</span><br><span class=\"line\">site.url=http://a.com</span><br><span class=\"line\">app.secret=XXXXXXXXXXXXXXXX</span><br><span class=\"line\">db.host=localhost</span><br><span class=\"line\">db.port=27017</span><br><span class=\"line\">db.dbname=leanote # required</span><br><span class=\"line\">db.username=root # if not exists, please leave blank</span><br><span class=\"line\">db.password=abc123 # if not exists, please leave blank</span><br></pre></td></tr></table></figure>\n<p>配置开机启动：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">    nohup mongod --dbpath /root/mongodb/data --auth 2&gt;&amp;1 &amp;</span><br><span class=\"line\">    nohup revel run github.com/leanote/leanote 2&gt;&amp;1 &amp;</span><br><span class=\"line\">    sstr=$(echo -e $str)</span><br><span class=\"line\">    echo &quot;$sstr&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vi /etc/rc.local</span><br><span class=\"line\">    </span><br><span class=\"line\">    source /etc/profile</span><br><span class=\"line\">    /root/gopackage/run.sh</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"运行Leanote\"><a href=\"#运行Leanote\" class=\"headerlink\" title=\"运行Leanote\"></a>运行Leanote</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revel run github.com/leanote/leanote</span><br></pre></td></tr></table></figure>"},{"title":"一个mongo备份的脚本","description":"一个mongo备份的脚本","date":"2017-10-20T22:49:50.000Z","comments":0,"_content":"### 一个mongo备份的脚本\n\n```bash\n    #!/bin/sh                                     \n    # ==================================================== 配置项\n    \n    # mongodump备份文件执行路径 \n    #DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.0.5/bin/mongodump \n    DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.2.7/bin/mongodump \n    # 当前shell脚本所在的目录\n    DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\n    # 临时备份目录\n    WORK_DIR=$DIR/work \n    # 备份存放路径\n    BAK_DIR=$DIR/bak\n    # 获取当前系统时间\n    NOW=`date +%Y-%m-%d.%H:%M:%S` \n    NOW1=`date +%Y%m%d.%H%M%S` \n    TIME=\"date +%Y-%m-%d.%H:%M:%S\"\n    # 备份的是哪个数据库\n    DB=agency \n    # 数据库账号\n    DB_USER=agency\n    # 数据库密码\n    DB_PASS=\"agency\"\n    # 保存多少份数量\n    COUNT=20\n    # 最终保存的数据库备份文件名\n    BAK_NAME=\"mongo_${DB}_$NOW1\"\n    \n    # ==================================================== 代码区\n    cd $DIR\n    \n    echo -e \"\\n\\n\\n======================================================\"\n    echo \"`$TIME` mongodb 定时备份 ${DB} 开始\"\n    echo \"`$TIME` ---- 当前目录是 : ${DIR}\"\n    echo \"`$TIME` ---- 清空临时工作目录 : ${WORK_DIR}\"\n    rm -fr ${WORK_DIR}/ *\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 创建备份文件目录 : $WORK_DIR/$BAK_NAME\"\n    mkdir -p $WORK_DIR/$BAK_NAME\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 备份 mongodb 数据库: ${DB}\"\n    $DUMP -d $DB -u $DB_USER -p $DB_PASS -o $WORK_DIR/$BAK_NAME\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 将数据文件打包: $BAK_DIR/${BAK_NAME}.tar.gz \"\n    tar -zcvf $BAK_DIR/${BAK_NAME}.tar.gz  $WORK_DIR/$BAK_NAME\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 删除过期的备份文件（最多保留${COUNT}份)\"\n    dirList=(`find $BAK_DIR -maxdepth 1 -type f -name *.tar.gz|sort`)\n    [ $? = 0 ] || exit -1\n    \n    # 下面的循环为闭区间。所以在长度在减去1，下标是从0开始的\n    let loopEnd=${#dirList[@]}-$COUNT-1\n    for i in `seq 0 $loopEnd`\n    do\n      echo \"`$TIME` -------- 删除: ${dirList[i]}\"\n      rm -fr ${dirList[i]} 2>&1  || {\n        exit $?\n      }\n    done\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` mongo定时备份 ${DB} 结束\"\n\n```","source":"_posts/service/mongo/mongo_backup.md","raw":"---\ntitle : 一个mongo备份的脚本\ndescription: 一个mongo备份的脚本\ndate: 2017-10-21 06:49:50\ntags: [mongo,shell]\ncomments: false\n---\n### 一个mongo备份的脚本\n\n```bash\n    #!/bin/sh                                     \n    # ==================================================== 配置项\n    \n    # mongodump备份文件执行路径 \n    #DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.0.5/bin/mongodump \n    DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.2.7/bin/mongodump \n    # 当前shell脚本所在的目录\n    DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"\n    # 临时备份目录\n    WORK_DIR=$DIR/work \n    # 备份存放路径\n    BAK_DIR=$DIR/bak\n    # 获取当前系统时间\n    NOW=`date +%Y-%m-%d.%H:%M:%S` \n    NOW1=`date +%Y%m%d.%H%M%S` \n    TIME=\"date +%Y-%m-%d.%H:%M:%S\"\n    # 备份的是哪个数据库\n    DB=agency \n    # 数据库账号\n    DB_USER=agency\n    # 数据库密码\n    DB_PASS=\"agency\"\n    # 保存多少份数量\n    COUNT=20\n    # 最终保存的数据库备份文件名\n    BAK_NAME=\"mongo_${DB}_$NOW1\"\n    \n    # ==================================================== 代码区\n    cd $DIR\n    \n    echo -e \"\\n\\n\\n======================================================\"\n    echo \"`$TIME` mongodb 定时备份 ${DB} 开始\"\n    echo \"`$TIME` ---- 当前目录是 : ${DIR}\"\n    echo \"`$TIME` ---- 清空临时工作目录 : ${WORK_DIR}\"\n    rm -fr ${WORK_DIR}/ *\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 创建备份文件目录 : $WORK_DIR/$BAK_NAME\"\n    mkdir -p $WORK_DIR/$BAK_NAME\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 备份 mongodb 数据库: ${DB}\"\n    $DUMP -d $DB -u $DB_USER -p $DB_PASS -o $WORK_DIR/$BAK_NAME\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 将数据文件打包: $BAK_DIR/${BAK_NAME}.tar.gz \"\n    tar -zcvf $BAK_DIR/${BAK_NAME}.tar.gz  $WORK_DIR/$BAK_NAME\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` ---- 删除过期的备份文件（最多保留${COUNT}份)\"\n    dirList=(`find $BAK_DIR -maxdepth 1 -type f -name *.tar.gz|sort`)\n    [ $? = 0 ] || exit -1\n    \n    # 下面的循环为闭区间。所以在长度在减去1，下标是从0开始的\n    let loopEnd=${#dirList[@]}-$COUNT-1\n    for i in `seq 0 $loopEnd`\n    do\n      echo \"`$TIME` -------- 删除: ${dirList[i]}\"\n      rm -fr ${dirList[i]} 2>&1  || {\n        exit $?\n      }\n    done\n    [ $? = 0 ] || exit -1\n    \n    echo \"`$TIME` mongo定时备份 ${DB} 结束\"\n\n```","slug":"service/mongo/mongo_backup","published":1,"updated":"2017-12-15T08:12:58.875Z","layout":"post","photos":[],"link":"","_id":"cjclsgbqz002e6dofdhvd9q5n","content":"<h3 id=\"一个mongo备份的脚本\"><a href=\"#一个mongo备份的脚本\" class=\"headerlink\" title=\"一个mongo备份的脚本\"></a>一个mongo备份的脚本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh                                     </span></span><br><span class=\"line\"><span class=\"comment\"># ==================================================== 配置项</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># mongodump备份文件执行路径 </span></span><br><span class=\"line\"><span class=\"comment\">#DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.0.5/bin/mongodump </span></span><br><span class=\"line\">DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.2.7/bin/mongodump </span><br><span class=\"line\"><span class=\"comment\"># 当前shell脚本所在的目录</span></span><br><span class=\"line\">DIR=<span class=\"string\">\"<span class=\"variable\">$( cd \"$( dirname \"$&#123;BASH_SOURCE[0]&#125;\" )</span>\"</span> &amp;&amp; <span class=\"built_in\">pwd</span> )<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"># 临时备份目录</span></span><br><span class=\"line\"><span class=\"string\">WORK_DIR=<span class=\"variable\">$DIR</span>/work </span></span><br><span class=\"line\"><span class=\"string\"># 备份存放路径</span></span><br><span class=\"line\"><span class=\"string\">BAK_DIR=<span class=\"variable\">$DIR</span>/bak</span></span><br><span class=\"line\"><span class=\"string\"># 获取当前系统时间</span></span><br><span class=\"line\"><span class=\"string\">NOW=`date +%Y-%m-%d.%H:%M:%S` </span></span><br><span class=\"line\"><span class=\"string\">NOW1=`date +%Y%m%d.%H%M%S` </span></span><br><span class=\"line\"><span class=\"string\">TIME=\"</span>date +%Y-%m-%d.%H:%M:%S<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"># 备份的是哪个数据库</span></span><br><span class=\"line\"><span class=\"string\">DB=agency </span></span><br><span class=\"line\"><span class=\"string\"># 数据库账号</span></span><br><span class=\"line\"><span class=\"string\">DB_USER=agency</span></span><br><span class=\"line\"><span class=\"string\"># 数据库密码</span></span><br><span class=\"line\"><span class=\"string\">DB_PASS=\"</span>agency<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"># 保存多少份数量</span></span><br><span class=\"line\"><span class=\"string\">COUNT=20</span></span><br><span class=\"line\"><span class=\"string\"># 最终保存的数据库备份文件名</span></span><br><span class=\"line\"><span class=\"string\">BAK_NAME=\"</span>mongo_<span class=\"variable\">$&#123;DB&#125;</span>_<span class=\"variable\">$NOW1</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># ==================================================== 代码区</span></span><br><span class=\"line\"><span class=\"string\">cd <span class=\"variable\">$DIR</span></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo -e \"</span>\\n\\n\\n======================================================<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` mongodb 定时备份 <span class=\"variable\">$&#123;DB&#125;</span> 开始<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 当前目录是 : <span class=\"variable\">$&#123;DIR&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 清空临时工作目录 : <span class=\"variable\">$&#123;WORK_DIR&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">rm -fr <span class=\"variable\">$&#123;WORK_DIR&#125;</span>/ *</span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 创建备份文件目录 : <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">mkdir -p <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span></span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 备份 mongodb 数据库: <span class=\"variable\">$&#123;DB&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"><span class=\"variable\">$DUMP</span> -d <span class=\"variable\">$DB</span> -u <span class=\"variable\">$DB_USER</span> -p <span class=\"variable\">$DB_PASS</span> -o <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span></span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 将数据文件打包: <span class=\"variable\">$BAK_DIR</span>/<span class=\"variable\">$&#123;BAK_NAME&#125;</span>.tar.gz <span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">tar -zcvf <span class=\"variable\">$BAK_DIR</span>/<span class=\"variable\">$&#123;BAK_NAME&#125;</span>.tar.gz  <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span></span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 删除过期的备份文件（最多保留<span class=\"variable\">$&#123;COUNT&#125;</span>份)<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">dirList=(`find <span class=\"variable\">$BAK_DIR</span> -maxdepth 1 -type f -name *.tar.gz|sort`)</span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 下面的循环为闭区间。所以在长度在减去1，下标是从0开始的</span></span><br><span class=\"line\"><span class=\"string\">let loopEnd=<span class=\"variable\">$&#123;#dirList[@]&#125;</span>-<span class=\"variable\">$COUNT</span>-1</span></span><br><span class=\"line\"><span class=\"string\">for i in `seq 0 <span class=\"variable\">$loopEnd</span>`</span></span><br><span class=\"line\"><span class=\"string\">do</span></span><br><span class=\"line\"><span class=\"string\">  echo \"</span>`<span class=\"variable\">$TIME</span>` -------- 删除: <span class=\"variable\">$&#123;dirList[i]&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">  rm -fr <span class=\"variable\">$&#123;dirList[i]&#125;</span> 2&gt;&amp;1  || &#123;</span></span><br><span class=\"line\"><span class=\"string\">    exit $?</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` mongo定时备份 <span class=\"variable\">$&#123;DB&#125;</span> 结束<span class=\"string\">\"</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一个mongo备份的脚本\"><a href=\"#一个mongo备份的脚本\" class=\"headerlink\" title=\"一个mongo备份的脚本\"></a>一个mongo备份的脚本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh                                     </span></span><br><span class=\"line\"><span class=\"comment\"># ==================================================== 配置项</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># mongodump备份文件执行路径 </span></span><br><span class=\"line\"><span class=\"comment\">#DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.0.5/bin/mongodump </span></span><br><span class=\"line\">DUMP=/data0/soft/mongodb/mongodb-linux-x86_64-rhel70-3.2.7/bin/mongodump </span><br><span class=\"line\"><span class=\"comment\"># 当前shell脚本所在的目录</span></span><br><span class=\"line\">DIR=<span class=\"string\">\"<span class=\"variable\">$( cd \"$( dirname \"$&#123;BASH_SOURCE[0]&#125;\" )</span>\"</span> &amp;&amp; <span class=\"built_in\">pwd</span> )<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"># 临时备份目录</span></span><br><span class=\"line\"><span class=\"string\">WORK_DIR=<span class=\"variable\">$DIR</span>/work </span></span><br><span class=\"line\"><span class=\"string\"># 备份存放路径</span></span><br><span class=\"line\"><span class=\"string\">BAK_DIR=<span class=\"variable\">$DIR</span>/bak</span></span><br><span class=\"line\"><span class=\"string\"># 获取当前系统时间</span></span><br><span class=\"line\"><span class=\"string\">NOW=`date +%Y-%m-%d.%H:%M:%S` </span></span><br><span class=\"line\"><span class=\"string\">NOW1=`date +%Y%m%d.%H%M%S` </span></span><br><span class=\"line\"><span class=\"string\">TIME=\"</span>date +%Y-%m-%d.%H:%M:%S<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"># 备份的是哪个数据库</span></span><br><span class=\"line\"><span class=\"string\">DB=agency </span></span><br><span class=\"line\"><span class=\"string\"># 数据库账号</span></span><br><span class=\"line\"><span class=\"string\">DB_USER=agency</span></span><br><span class=\"line\"><span class=\"string\"># 数据库密码</span></span><br><span class=\"line\"><span class=\"string\">DB_PASS=\"</span>agency<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"># 保存多少份数量</span></span><br><span class=\"line\"><span class=\"string\">COUNT=20</span></span><br><span class=\"line\"><span class=\"string\"># 最终保存的数据库备份文件名</span></span><br><span class=\"line\"><span class=\"string\">BAK_NAME=\"</span>mongo_<span class=\"variable\">$&#123;DB&#125;</span>_<span class=\"variable\">$NOW1</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># ==================================================== 代码区</span></span><br><span class=\"line\"><span class=\"string\">cd <span class=\"variable\">$DIR</span></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo -e \"</span>\\n\\n\\n======================================================<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` mongodb 定时备份 <span class=\"variable\">$&#123;DB&#125;</span> 开始<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 当前目录是 : <span class=\"variable\">$&#123;DIR&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 清空临时工作目录 : <span class=\"variable\">$&#123;WORK_DIR&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">rm -fr <span class=\"variable\">$&#123;WORK_DIR&#125;</span>/ *</span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 创建备份文件目录 : <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">mkdir -p <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span></span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 备份 mongodb 数据库: <span class=\"variable\">$&#123;DB&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\"><span class=\"variable\">$DUMP</span> -d <span class=\"variable\">$DB</span> -u <span class=\"variable\">$DB_USER</span> -p <span class=\"variable\">$DB_PASS</span> -o <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span></span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 将数据文件打包: <span class=\"variable\">$BAK_DIR</span>/<span class=\"variable\">$&#123;BAK_NAME&#125;</span>.tar.gz <span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">tar -zcvf <span class=\"variable\">$BAK_DIR</span>/<span class=\"variable\">$&#123;BAK_NAME&#125;</span>.tar.gz  <span class=\"variable\">$WORK_DIR</span>/<span class=\"variable\">$BAK_NAME</span></span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` ---- 删除过期的备份文件（最多保留<span class=\"variable\">$&#123;COUNT&#125;</span>份)<span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">dirList=(`find <span class=\"variable\">$BAK_DIR</span> -maxdepth 1 -type f -name *.tar.gz|sort`)</span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"># 下面的循环为闭区间。所以在长度在减去1，下标是从0开始的</span></span><br><span class=\"line\"><span class=\"string\">let loopEnd=<span class=\"variable\">$&#123;#dirList[@]&#125;</span>-<span class=\"variable\">$COUNT</span>-1</span></span><br><span class=\"line\"><span class=\"string\">for i in `seq 0 <span class=\"variable\">$loopEnd</span>`</span></span><br><span class=\"line\"><span class=\"string\">do</span></span><br><span class=\"line\"><span class=\"string\">  echo \"</span>`<span class=\"variable\">$TIME</span>` -------- 删除: <span class=\"variable\">$&#123;dirList[i]&#125;</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">  rm -fr <span class=\"variable\">$&#123;dirList[i]&#125;</span> 2&gt;&amp;1  || &#123;</span></span><br><span class=\"line\"><span class=\"string\">    exit $?</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">done</span></span><br><span class=\"line\"><span class=\"string\">[ $? = 0 ] || exit -1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">echo \"</span>`<span class=\"variable\">$TIME</span>` mongo定时备份 <span class=\"variable\">$&#123;DB&#125;</span> 结束<span class=\"string\">\"</span></span><br></pre></td></tr></table></figure>"},{"title":"各个PC系统好用插件软件","description":"各个PC系统好用插件软件","date":"2017-10-20T22:49:50.000Z","comments":0,"_content":"\n### IP定位\n```bash\nhttps://www.opengps.cn/Data/IP/LocHighAcc.aspx\n```\n### Windows\n```bash\neverything      #快速文件查找\n```\n### MAC\n```bash\nEasyFind    #快速文件查找\n```\n### firefox\n```bash\nFont Finder     #浏览器字体查看工具\n```\n","source":"_posts/service/pc/soft.md","raw":"---\ntitle : 各个PC系统好用插件软件\ndescription: 各个PC系统好用插件软件\ndate: 2017-10-21 06:49:50\ncomments: false\n---\n\n### IP定位\n```bash\nhttps://www.opengps.cn/Data/IP/LocHighAcc.aspx\n```\n### Windows\n```bash\neverything      #快速文件查找\n```\n### MAC\n```bash\nEasyFind    #快速文件查找\n```\n### firefox\n```bash\nFont Finder     #浏览器字体查看工具\n```\n","slug":"service/pc/soft","published":1,"updated":"2017-12-15T08:12:58.876Z","layout":"post","photos":[],"link":"","_id":"cjclsgbr1002j6dofidvkhl8m","content":"<h3 id=\"IP定位\"><a href=\"#IP定位\" class=\"headerlink\" title=\"IP定位\"></a>IP定位</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.opengps.cn/Data/IP/LocHighAcc.aspx</span><br></pre></td></tr></table></figure>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">everything      <span class=\"comment\">#快速文件查找</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"MAC\"><a href=\"#MAC\" class=\"headerlink\" title=\"MAC\"></a>MAC</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EasyFind    <span class=\"comment\">#快速文件查找</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"firefox\"><a href=\"#firefox\" class=\"headerlink\" title=\"firefox\"></a>firefox</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Font Finder     <span class=\"comment\">#浏览器字体查看工具</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"IP定位\"><a href=\"#IP定位\" class=\"headerlink\" title=\"IP定位\"></a>IP定位</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://www.opengps.cn/Data/IP/LocHighAcc.aspx</span><br></pre></td></tr></table></figure>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">everything      <span class=\"comment\">#快速文件查找</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"MAC\"><a href=\"#MAC\" class=\"headerlink\" title=\"MAC\"></a>MAC</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EasyFind    <span class=\"comment\">#快速文件查找</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"firefox\"><a href=\"#firefox\" class=\"headerlink\" title=\"firefox\"></a>firefox</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Font Finder     <span class=\"comment\">#浏览器字体查看工具</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Mac日常使用心得","date":"2017-12-20T02:34:22.000Z","description":"Mac下安装Node并切换taobao.org源","_content":"\n```bash\nsudo tmutil disable local  # 关闭时间机器本地备份\nsudo tmutil enable local   # 打开时间机器本地备份\n```","source":"_posts/OS/Mac/Mac-handle.md","raw":"---\ntitle: Mac日常使用心得\ndate: 2017-12-20 10:34:22\ncategories: PC\ntags: [OS,Mac]\ndescription: Mac下安装Node并切换taobao.org源\n---\n\n```bash\nsudo tmutil disable local  # 关闭时间机器本地备份\nsudo tmutil enable local   # 打开时间机器本地备份\n```","slug":"OS/Mac/Mac-handle","published":1,"updated":"2017-12-25T07:11:35.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbs6003l6dof828bvdho","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo tmutil <span class=\"built_in\">disable</span> <span class=\"built_in\">local</span>  <span class=\"comment\"># 关闭时间机器本地备份</span></span><br><span class=\"line\">sudo tmutil <span class=\"built_in\">enable</span> <span class=\"built_in\">local</span>   <span class=\"comment\"># 打开时间机器本地备份</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo tmutil <span class=\"built_in\">disable</span> <span class=\"built_in\">local</span>  <span class=\"comment\"># 关闭时间机器本地备份</span></span><br><span class=\"line\">sudo tmutil <span class=\"built_in\">enable</span> <span class=\"built_in\">local</span>   <span class=\"comment\"># 打开时间机器本地备份</span></span><br></pre></td></tr></table></figure>"},{"title":"spring中scope概述","date":"2017-11-21T02:34:22.000Z","description":"spring中scope是一个非常关键的概念，简单说就是对象在spring容器（IOC容器）中的生命周期，也可以理解为对象在spring容器中的创建方式。","_content":"\n## singleton （单一实例）\n此取值时表明容器中创建时只存在一个实例，所有引用此bean都是单一实例。如同每个国家都有一个总统，国家的所有人共用此总统，而这个国家就是一个spring容器，总统就是spring创建的类的bean，国家中的人就是其它调用者，总统是一个表明其在spring中的scope为singleton，也就是单例模型。\n此外，singleton类型的bean定义从容器启动到第一次被请求而实例化开始，只要容器不销毁或退出，该类型的bean的单一实例就会一直存活，典型单例模式，如同servlet在web容器中的生命周期。\n\n## prototype\nspring容器在进行输出prototype的bean对象时，会每次都重新生成一个新的对象给请求方，虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不在拥有当前对象的引用，请求方需要自己负责当前对象后继生命周期的管理工作，包括该对象的销毁。也就是说，容器每次返回请求方该对象的一个新的实例之后，就由这个对象“自生自灭”，最典型的体现就是spring与struts2进行整合时，要把action的scope改为prototype。\n如同分苹果，将苹果的bean的scope属性声明为prototype，在每个人领取苹果的时候，我们都是发一个新的苹果给他，发完之后，别人爱怎么吃就怎么吃，爱什么时候吃什么时候吃，但是注意吃完要把苹果核扔到垃圾箱！对于那些不能共享使用的对象类型，应该将其定义的scope设为prototype。\n\n## request\n再次说明request，session和global session类型只实用于web程序，通常是和XmlWebApplicationContext共同使用。\n`<bean id =\"requestPrecessor\" class=\"...RequestPrecessor\"   scope=\"request\" />`\nSpring容器，即XmlWebApplicationContext 会为每个HTTP请求创建一个全新的RequestPrecessor对象，当请求结束后，该对象的生命周期即告结束，如同java web中request的生命周期。当同时有10个HTTP请求进来的时候，容器会分别针对这10个请求创建10个全新的RequestPrecessor实例，且他们相互之间互不干扰，简单来讲，request可以看做prototype的一种特例，除了场景更加具体之外，语意上差不多\n\n## session\n对于web应用来说，放到session中最普遍的就是用户的登录信息，对于这种放到session中的信息，我们可以使用如下形式的制定scope为session：\n`<bean id =\"userPreferences\" class=\"...UserPreferences\"   scope=\"session\" />`\nSpring容器会为每个独立的session创建属于自己的全新的UserPreferences实例，比request scope的bean会存活更长的时间，其他的方面没区别，如java web中session的生命周期。\n\n## global session\n`<bean id =\"userPreferences\" class=\"...UserPreferences\"   scope=\"globalsession\" />`\nglobal session只有应用在基于porlet的web应用程序中才有意义，它映射到porlet的global范围的session，如果普通的servlet的web 应用中使用了这个scope，容器会把它作为普通的session的scope对待。","source":"_posts/Java/frame/spring/spring-scope-intro.md","raw":"---\ntitle: spring中scope概述\ndate: 2017-11-21 10:34:22\ncategories: 框架\ntags: [Java,spring]\ndescription: spring中scope是一个非常关键的概念，简单说就是对象在spring容器（IOC容器）中的生命周期，也可以理解为对象在spring容器中的创建方式。\n---\n\n## singleton （单一实例）\n此取值时表明容器中创建时只存在一个实例，所有引用此bean都是单一实例。如同每个国家都有一个总统，国家的所有人共用此总统，而这个国家就是一个spring容器，总统就是spring创建的类的bean，国家中的人就是其它调用者，总统是一个表明其在spring中的scope为singleton，也就是单例模型。\n此外，singleton类型的bean定义从容器启动到第一次被请求而实例化开始，只要容器不销毁或退出，该类型的bean的单一实例就会一直存活，典型单例模式，如同servlet在web容器中的生命周期。\n\n## prototype\nspring容器在进行输出prototype的bean对象时，会每次都重新生成一个新的对象给请求方，虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不在拥有当前对象的引用，请求方需要自己负责当前对象后继生命周期的管理工作，包括该对象的销毁。也就是说，容器每次返回请求方该对象的一个新的实例之后，就由这个对象“自生自灭”，最典型的体现就是spring与struts2进行整合时，要把action的scope改为prototype。\n如同分苹果，将苹果的bean的scope属性声明为prototype，在每个人领取苹果的时候，我们都是发一个新的苹果给他，发完之后，别人爱怎么吃就怎么吃，爱什么时候吃什么时候吃，但是注意吃完要把苹果核扔到垃圾箱！对于那些不能共享使用的对象类型，应该将其定义的scope设为prototype。\n\n## request\n再次说明request，session和global session类型只实用于web程序，通常是和XmlWebApplicationContext共同使用。\n`<bean id =\"requestPrecessor\" class=\"...RequestPrecessor\"   scope=\"request\" />`\nSpring容器，即XmlWebApplicationContext 会为每个HTTP请求创建一个全新的RequestPrecessor对象，当请求结束后，该对象的生命周期即告结束，如同java web中request的生命周期。当同时有10个HTTP请求进来的时候，容器会分别针对这10个请求创建10个全新的RequestPrecessor实例，且他们相互之间互不干扰，简单来讲，request可以看做prototype的一种特例，除了场景更加具体之外，语意上差不多\n\n## session\n对于web应用来说，放到session中最普遍的就是用户的登录信息，对于这种放到session中的信息，我们可以使用如下形式的制定scope为session：\n`<bean id =\"userPreferences\" class=\"...UserPreferences\"   scope=\"session\" />`\nSpring容器会为每个独立的session创建属于自己的全新的UserPreferences实例，比request scope的bean会存活更长的时间，其他的方面没区别，如java web中session的生命周期。\n\n## global session\n`<bean id =\"userPreferences\" class=\"...UserPreferences\"   scope=\"globalsession\" />`\nglobal session只有应用在基于porlet的web应用程序中才有意义，它映射到porlet的global范围的session，如果普通的servlet的web 应用中使用了这个scope，容器会把它作为普通的session的scope对待。","slug":"Java/frame/spring/spring-scope-intro","published":1,"updated":"2017-12-15T08:12:58.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjclsgbse003p6dofhr7zs2yf","content":"<h2 id=\"singleton-（单一实例）\"><a href=\"#singleton-（单一实例）\" class=\"headerlink\" title=\"singleton （单一实例）\"></a>singleton （单一实例）</h2><p>此取值时表明容器中创建时只存在一个实例，所有引用此bean都是单一实例。如同每个国家都有一个总统，国家的所有人共用此总统，而这个国家就是一个spring容器，总统就是spring创建的类的bean，国家中的人就是其它调用者，总统是一个表明其在spring中的scope为singleton，也就是单例模型。<br>此外，singleton类型的bean定义从容器启动到第一次被请求而实例化开始，只要容器不销毁或退出，该类型的bean的单一实例就会一直存活，典型单例模式，如同servlet在web容器中的生命周期。</p>\n<h2 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h2><p>spring容器在进行输出prototype的bean对象时，会每次都重新生成一个新的对象给请求方，虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不在拥有当前对象的引用，请求方需要自己负责当前对象后继生命周期的管理工作，包括该对象的销毁。也就是说，容器每次返回请求方该对象的一个新的实例之后，就由这个对象“自生自灭”，最典型的体现就是spring与struts2进行整合时，要把action的scope改为prototype。<br>如同分苹果，将苹果的bean的scope属性声明为prototype，在每个人领取苹果的时候，我们都是发一个新的苹果给他，发完之后，别人爱怎么吃就怎么吃，爱什么时候吃什么时候吃，但是注意吃完要把苹果核扔到垃圾箱！对于那些不能共享使用的对象类型，应该将其定义的scope设为prototype。</p>\n<h2 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h2><p>再次说明request，session和global session类型只实用于web程序，通常是和XmlWebApplicationContext共同使用。<br><code>&lt;bean id =&quot;requestPrecessor&quot; class=&quot;...RequestPrecessor&quot;   scope=&quot;request&quot; /&gt;</code><br>Spring容器，即XmlWebApplicationContext 会为每个HTTP请求创建一个全新的RequestPrecessor对象，当请求结束后，该对象的生命周期即告结束，如同java web中request的生命周期。当同时有10个HTTP请求进来的时候，容器会分别针对这10个请求创建10个全新的RequestPrecessor实例，且他们相互之间互不干扰，简单来讲，request可以看做prototype的一种特例，除了场景更加具体之外，语意上差不多</p>\n<h2 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h2><p>对于web应用来说，放到session中最普遍的就是用户的登录信息，对于这种放到session中的信息，我们可以使用如下形式的制定scope为session：<br><code>&lt;bean id =&quot;userPreferences&quot; class=&quot;...UserPreferences&quot;   scope=&quot;session&quot; /&gt;</code><br>Spring容器会为每个独立的session创建属于自己的全新的UserPreferences实例，比request scope的bean会存活更长的时间，其他的方面没区别，如java web中session的生命周期。</p>\n<h2 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h2><p><code>&lt;bean id =&quot;userPreferences&quot; class=&quot;...UserPreferences&quot;   scope=&quot;globalsession&quot; /&gt;</code><br>global session只有应用在基于porlet的web应用程序中才有意义，它映射到porlet的global范围的session，如果普通的servlet的web 应用中使用了这个scope，容器会把它作为普通的session的scope对待。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"singleton-（单一实例）\"><a href=\"#singleton-（单一实例）\" class=\"headerlink\" title=\"singleton （单一实例）\"></a>singleton （单一实例）</h2><p>此取值时表明容器中创建时只存在一个实例，所有引用此bean都是单一实例。如同每个国家都有一个总统，国家的所有人共用此总统，而这个国家就是一个spring容器，总统就是spring创建的类的bean，国家中的人就是其它调用者，总统是一个表明其在spring中的scope为singleton，也就是单例模型。<br>此外，singleton类型的bean定义从容器启动到第一次被请求而实例化开始，只要容器不销毁或退出，该类型的bean的单一实例就会一直存活，典型单例模式，如同servlet在web容器中的生命周期。</p>\n<h2 id=\"prototype\"><a href=\"#prototype\" class=\"headerlink\" title=\"prototype\"></a>prototype</h2><p>spring容器在进行输出prototype的bean对象时，会每次都重新生成一个新的对象给请求方，虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不在拥有当前对象的引用，请求方需要自己负责当前对象后继生命周期的管理工作，包括该对象的销毁。也就是说，容器每次返回请求方该对象的一个新的实例之后，就由这个对象“自生自灭”，最典型的体现就是spring与struts2进行整合时，要把action的scope改为prototype。<br>如同分苹果，将苹果的bean的scope属性声明为prototype，在每个人领取苹果的时候，我们都是发一个新的苹果给他，发完之后，别人爱怎么吃就怎么吃，爱什么时候吃什么时候吃，但是注意吃完要把苹果核扔到垃圾箱！对于那些不能共享使用的对象类型，应该将其定义的scope设为prototype。</p>\n<h2 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h2><p>再次说明request，session和global session类型只实用于web程序，通常是和XmlWebApplicationContext共同使用。<br><code>&lt;bean id =&quot;requestPrecessor&quot; class=&quot;...RequestPrecessor&quot;   scope=&quot;request&quot; /&gt;</code><br>Spring容器，即XmlWebApplicationContext 会为每个HTTP请求创建一个全新的RequestPrecessor对象，当请求结束后，该对象的生命周期即告结束，如同java web中request的生命周期。当同时有10个HTTP请求进来的时候，容器会分别针对这10个请求创建10个全新的RequestPrecessor实例，且他们相互之间互不干扰，简单来讲，request可以看做prototype的一种特例，除了场景更加具体之外，语意上差不多</p>\n<h2 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h2><p>对于web应用来说，放到session中最普遍的就是用户的登录信息，对于这种放到session中的信息，我们可以使用如下形式的制定scope为session：<br><code>&lt;bean id =&quot;userPreferences&quot; class=&quot;...UserPreferences&quot;   scope=&quot;session&quot; /&gt;</code><br>Spring容器会为每个独立的session创建属于自己的全新的UserPreferences实例，比request scope的bean会存活更长的时间，其他的方面没区别，如java web中session的生命周期。</p>\n<h2 id=\"global-session\"><a href=\"#global-session\" class=\"headerlink\" title=\"global session\"></a>global session</h2><p><code>&lt;bean id =&quot;userPreferences&quot; class=&quot;...UserPreferences&quot;   scope=&quot;globalsession&quot; /&gt;</code><br>global session只有应用在基于porlet的web应用程序中才有意义，它映射到porlet的global范围的session，如果普通的servlet的web 应用中使用了这个scope，容器会把它作为普通的session的scope对待。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjclsgbnz00036dofraukfkce","category_id":"cjclsgbo500056dofcditth6u","_id":"cjclsgboc000f6dofgv1zoyev"},{"post_id":"cjclsgbo100046dofzpx5idzs","category_id":"cjclsgbo500056dofcditth6u","_id":"cjclsgboe000i6dofx32f8zm5"},{"post_id":"cjclsgbo700076dofhsd2w2gq","category_id":"cjclsgboc000e6dofe4i52iga","_id":"cjclsgbof000m6dofx7fh6kzb"},{"post_id":"cjclsgbo700086dofx87cxaqi","category_id":"cjclsgboe000k6dof45xykhy4","_id":"cjclsgbog000r6dof8081by4y"},{"post_id":"cjclsgbo800096doftbfg0ble","category_id":"cjclsgbog000o6dofi4l6ihmq","_id":"cjclsgbog000v6dof73m6u2iv"},{"post_id":"cjclsgbob000c6dofjd374o5a","category_id":"cjclsgbog000t6doffy7t41k5","_id":"cjclsgboi000z6dofcw7wiv2j"},{"post_id":"cjclsgboc000d6dof1ajrucen","category_id":"cjclsgbog000o6dofi4l6ihmq","_id":"cjclsgboi00126dofdrrifwjg"},{"post_id":"cjclsgbqb00166dofhj4x9j8w","category_id":"cjclsgbqc00186dof6v2vhare","_id":"cjclsgbql001j6dofgg4orjmt"},{"post_id":"cjclsgbqc00176dofunkmdj81","category_id":"cjclsgbqc00186dof6v2vhare","_id":"cjclsgbqq001p6dofawj7bu9x"},{"post_id":"cjclsgbqd001a6doffzwf5tw9","category_id":"cjclsgbqc00186dof6v2vhare","_id":"cjclsgbqt001u6dofxvty82zf"},{"post_id":"cjclsgbqr001s6dofntrh7cc9","category_id":"cjclsgbqc00186dof6v2vhare","_id":"cjclsgbqw00206dofleijtnvx"},{"post_id":"cjclsgbqe001b6dof7sosk7j2","category_id":"cjclsgbqq001o6dofa6u13y6l","_id":"cjclsgbqx00256dofd7qwrvd7"},{"post_id":"cjclsgbqg001c6dofsixdh3li","category_id":"cjclsgbqq001o6dofa6u13y6l","_id":"cjclsgbqy002a6dof9wlodyb9"},{"post_id":"cjclsgbqi001g6dofyqiv2cpj","category_id":"cjclsgbqq001o6dofa6u13y6l","_id":"cjclsgbr0002g6dof2k8irub0"},{"post_id":"cjclsgbqk001h6dofycan9sus","category_id":"cjclsgbqy00296dof3swn4zh6","_id":"cjclsgbr1002k6dofa4qy2p8y"},{"post_id":"cjclsgbqn001m6dofv7dw18f1","category_id":"cjclsgbr0002h6dofvew8e0wn","_id":"cjclsgbr2002q6dof34oxmdmy"},{"post_id":"cjclsgbqp001n6dofe92ldf35","category_id":"cjclsgbr0002h6dofvew8e0wn","_id":"cjclsgbr2002s6dof88jllka2"},{"post_id":"cjclsgbqs001t6dofvmtg64g9","category_id":"cjclsgbr2002p6dof9ol8mg0e","_id":"cjclsgbr3002x6dofrkagyzos"},{"post_id":"cjclsgbqu001x6dofaesdwn6d","category_id":"cjclsgbr2002p6dof9ol8mg0e","_id":"cjclsgbr400326dof9dkw1gjh"},{"post_id":"cjclsgbqv001z6doflup929aj","category_id":"cjclsgbr2002p6dof9ol8mg0e","_id":"cjclsgbr400346dofgzkbwvd6"},{"post_id":"cjclsgbqy002c6dofqz37ju4p","category_id":"cjclsgbr2002p6dof9ol8mg0e","_id":"cjclsgbr500376dofqhtr930k"},{"post_id":"cjclsgbs6003l6dof828bvdho","category_id":"cjclsgbqy00296dof3swn4zh6","_id":"cjclsgbs7003o6dofbjk408z3"},{"post_id":"cjclsgbse003p6dofhr7zs2yf","category_id":"cjclsgbsg003q6dofgbdyeqv9","_id":"cjclsgbsg003u6dofobfsaw0h"}],"PostTag":[{"post_id":"cjclsgbnz00036dofraukfkce","tag_id":"cjclsgbo600066dofdt02nix4","_id":"cjclsgboe000h6dofzgm97l6r"},{"post_id":"cjclsgbnz00036dofraukfkce","tag_id":"cjclsgbo9000b6dofxdh6wvwd","_id":"cjclsgboe000j6dofwpjq50an"},{"post_id":"cjclsgbo100046dofzpx5idzs","tag_id":"cjclsgbo600066dofdt02nix4","_id":"cjclsgbog000p6dof5efv4tyb"},{"post_id":"cjclsgbo100046dofzpx5idzs","tag_id":"cjclsgbo9000b6dofxdh6wvwd","_id":"cjclsgbog000q6dofnaubdsz5"},{"post_id":"cjclsgbo700076dofhsd2w2gq","tag_id":"cjclsgbof000n6dofgu4kcrqn","_id":"cjclsgbog000u6dofz3p3uv0k"},{"post_id":"cjclsgbo700086dofx87cxaqi","tag_id":"cjclsgbog000s6dof8r3hnokz","_id":"cjclsgboh000y6dofln669sxu"},{"post_id":"cjclsgbo800096doftbfg0ble","tag_id":"cjclsgbog000w6dof7m31yec3","_id":"cjclsgboi00116doftpgh21me"},{"post_id":"cjclsgbob000c6dofjd374o5a","tag_id":"cjclsgboi00106doft8afeloq","_id":"cjclsgboj00146dof0o19sxwy"},{"post_id":"cjclsgboc000d6dof1ajrucen","tag_id":"cjclsgbog000w6dof7m31yec3","_id":"cjclsgboj00156dofd8za9diz"},{"post_id":"cjclsgbqb00166dofhj4x9j8w","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbqi001f6dof1b3vdfyr"},{"post_id":"cjclsgbqc00176dofunkmdj81","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbqn001l6dofgan1u4xh"},{"post_id":"cjclsgbqd001a6doffzwf5tw9","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbqr001r6dofu8gc0d75"},{"post_id":"cjclsgbqe001b6dof7sosk7j2","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbqu001y6dofgkz5sv62"},{"post_id":"cjclsgbqe001b6dof7sosk7j2","tag_id":"cjclsgbqq001q6dofrwyte9ug","_id":"cjclsgbqw00216dofkz3nqj45"},{"post_id":"cjclsgbqg001c6dofsixdh3li","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbqx00266dofz2vxe7wc"},{"post_id":"cjclsgbqg001c6dofsixdh3li","tag_id":"cjclsgbqq001q6dofrwyte9ug","_id":"cjclsgbqy00286dofuqdjk12g"},{"post_id":"cjclsgbqi001g6dofyqiv2cpj","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbqz002d6dofx2hp09xh"},{"post_id":"cjclsgbqi001g6dofyqiv2cpj","tag_id":"cjclsgbqq001q6dofrwyte9ug","_id":"cjclsgbr0002f6dof0jf2rwbr"},{"post_id":"cjclsgbqk001h6dofycan9sus","tag_id":"cjclsgbqy002b6dofnzjy9cdm","_id":"cjclsgbr2002n6dofhh4wnkum"},{"post_id":"cjclsgbqk001h6dofycan9sus","tag_id":"cjclsgbr0002i6dofjk3q5adc","_id":"cjclsgbr2002o6dofoqj2tsno"},{"post_id":"cjclsgbqn001m6dofv7dw18f1","tag_id":"cjclsgbr1002m6dof41xjpj4a","_id":"cjclsgbr3002v6dofi29x15bh"},{"post_id":"cjclsgbqn001m6dofv7dw18f1","tag_id":"cjclsgbr2002r6dofzjp1qr0w","_id":"cjclsgbr3002y6dofcjvs7u80"},{"post_id":"cjclsgbqp001n6dofe92ldf35","tag_id":"cjclsgbr1002m6dof41xjpj4a","_id":"cjclsgbr400306dofhach7vh2"},{"post_id":"cjclsgbqr001s6dofntrh7cc9","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbr500366dofer10mj7w"},{"post_id":"cjclsgbqr001s6dofntrh7cc9","tag_id":"cjclsgbr3002z6dof3keygwim","_id":"cjclsgbr500386dofx3kor6c6"},{"post_id":"cjclsgbqr001s6dofntrh7cc9","tag_id":"cjclsgbr400336dofhnfi17hw","_id":"cjclsgbr5003a6dofyvr5uazi"},{"post_id":"cjclsgbqs001t6dofvmtg64g9","tag_id":"cjclsgbr400356dof5eg9ytr7","_id":"cjclsgbr5003b6dof6ntlailm"},{"post_id":"cjclsgbqu001x6dofaesdwn6d","tag_id":"cjclsgbr500396dof4zf0bqxc","_id":"cjclsgbr5003d6dofjbv6tqry"},{"post_id":"cjclsgbqv001z6doflup929aj","tag_id":"cjclsgbr5003c6dof833fmw2q","_id":"cjclsgbr6003f6dofdgp4qq01"},{"post_id":"cjclsgbqy002c6dofqz37ju4p","tag_id":"cjclsgbr500396dof4zf0bqxc","_id":"cjclsgbr6003h6dofq0b6jpii"},{"post_id":"cjclsgbqz002e6dofdhvd9q5n","tag_id":"cjclsgbr6003g6dofs3nfxslp","_id":"cjclsgbr6003j6dofuo0iyfxq"},{"post_id":"cjclsgbqz002e6dofdhvd9q5n","tag_id":"cjclsgbr6003i6dofgn8kqzu6","_id":"cjclsgbr6003k6dofr7gkp5ds"},{"post_id":"cjclsgbs6003l6dof828bvdho","tag_id":"cjclsgbqy002b6dofnzjy9cdm","_id":"cjclsgbs7003m6dof3o3hp8np"},{"post_id":"cjclsgbs6003l6dof828bvdho","tag_id":"cjclsgbr0002i6dofjk3q5adc","_id":"cjclsgbs7003n6dofp73q158i"},{"post_id":"cjclsgbse003p6dofhr7zs2yf","tag_id":"cjclsgbqc00196dofh9loo4b1","_id":"cjclsgbsg003s6dofnyfp9lqg"},{"post_id":"cjclsgbse003p6dofhr7zs2yf","tag_id":"cjclsgbsg003r6dofg7hkgtgw","_id":"cjclsgbsg003t6dofy50dd470"}],"Tag":[{"name":"angular","_id":"cjclsgbo600066dofdt02nix4"},{"name":"nvm","_id":"cjclsgbo9000b6dofxdh6wvwd"},{"name":"Person","_id":"cjclsgbof000n6dofgu4kcrqn"},{"name":"Crack","_id":"cjclsgbog000s6dof8r3hnokz"},{"name":"design","_id":"cjclsgbog000w6dof7m31yec3"},{"name":"Linux","_id":"cjclsgboi00106doft8afeloq"},{"name":"Java","_id":"cjclsgbqc00196dofh9loo4b1"},{"name":"Task","_id":"cjclsgbqq001q6dofrwyte9ug"},{"name":"OS","_id":"cjclsgbqy002b6dofnzjy9cdm"},{"name":"Mac","_id":"cjclsgbr0002i6dofjk3q5adc"},{"name":"Python","_id":"cjclsgbr1002m6dof41xjpj4a"},{"name":"Scrapy","_id":"cjclsgbr2002r6dofzjp1qr0w"},{"name":"Lambda","_id":"cjclsgbr3002z6dof3keygwim"},{"name":"Stream","_id":"cjclsgbr400336dofhnfi17hw"},{"name":"docker","_id":"cjclsgbr400356dof5eg9ytr7"},{"name":"server","_id":"cjclsgbr500396dof4zf0bqxc"},{"name":"elasticsearch","_id":"cjclsgbr5003c6dof833fmw2q"},{"name":"mongo","_id":"cjclsgbr6003g6dofs3nfxslp"},{"name":"shell","_id":"cjclsgbr6003i6dofgn8kqzu6"},{"name":"spring","_id":"cjclsgbsg003r6dofg7hkgtgw"}]}}